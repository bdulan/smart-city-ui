Index: bower_components/ui-leaflet/dist/ui-leaflet.min.no-header.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/dist/ui-leaflet.min.no-header.js	(revision )
+++ bower_components/ui-leaflet/dist/ui-leaflet.min.no-header.js	(revision )
@@ -0,0 +1,8 @@
+/*!
+*  ui-leaflet 2.0.0 2016-10-04
+*  ui-leaflet - An AngularJS directive to easily interact with Leaflet maps
+*  git: https://github.com/angular-ui/ui-leaflet
+*/
+!function(a){"use strict";a.module("ui-leaflet",["nemLogging"]).directive("leaflet",["$q","leafletData","leafletMapDefaults","leafletHelpers","leafletMapEvents",function(a,b,c,d,e){return{restrict:"EA",replace:!0,scope:{center:"=",lfCenter:"=",defaults:"=",maxbounds:"=",bounds:"=",markers:"=",legend:"=",geojson:"=",paths:"=",tiles:"=",layers:"=",controls:"=",decorations:"=",eventBroadcast:"=",watchOptions:"=",id:"@"},transclude:!0,template:'<div class="angular-leaflet-map"><div ng-transclude></div></div>',controller:["$scope",function(b){this._leafletMap=a.defer(),this.getMap=function(){return this._leafletMap.promise},this.getLeafletScope=function(){return b}}],link:function(a,f,g,h){function i(){isNaN(g.width)?f.css("width",g.width):f.css("width",g.width+"px")}function j(){isNaN(g.height)?f.css("height",g.height):f.css("height",g.height+"px")}var k=d.isDefined,l=c.setDefaults(a.defaults,g.id),m=e.getAvailableMapEvents(),n=e.addEvents;a.mapId=g.id,b.setDirectiveControls({},g.id);var o=new L.Map(f[0],c.getMapCreationDefaults(g.id));if(h._leafletMap.resolve(o),k(g.width)&&(i(),a.$watch(function(){return f[0].getAttribute("width")},function(){i(),o.invalidateSize()})),k(g.height)&&(j(),a.$watch(function(){return f[0].getAttribute("height")},function(){j(),o.invalidateSize()})),k(g.center)||k(g.lfCenter)||o.setView([l.center.lat,l.center.lng],l.center.zoom),!k(g.tiles)&&!k(g.layers)){var p=L.tileLayer(l.tileLayer,l.tileLayerOptions);p.addTo(o),b.setTiles(p,g.id)}if(k(o.zoomControl)&&k(l.zoomControlPosition)&&o.zoomControl.setPosition(l.zoomControlPosition),k(o.zoomControl)&&l.zoomControl===!1&&o.zoomControl.removeFrom(o),k(o.zoomsliderControl)&&k(l.zoomsliderControl)&&l.zoomsliderControl===!1&&o.zoomsliderControl.removeFrom(o),!k(g.eventBroadcast)){var q="broadcast";n(o,g.id,m,"eventName",a,q)}o.whenReady(function(){b.setMap(o,g.id)}),a.$on("$destroy",function(){c.reset(),o.remove(),b.unresolveMap(g.id)}),a.$on("invalidateSize",function(){o.invalidateSize()})}}}]),function(){a.module("ui-leaflet").factory("eventManager",[function(){var a=function(){this.listeners={}};return a.prototype={addEventListener:function(a,b,c){for(var d=[],e=arguments.length,f=0;f<e;f++)d.push(arguments[f]);d=d.length>3?d.splice(3,d.length-1):[],"undefined"!=typeof this.listeners[a]?this.listeners[a].push({scope:c,callback:b,args:d}):this.listeners[a]=[{scope:c,callback:b,args:d}]},removeEventListener:function(a,b,c){if("undefined"!=typeof this.listeners[a]){for(var d=this.listeners[a].length,e=[],f=0;f<d;f++){var g=this.listeners[a][f];g.scope===c&&g.callback===b||e.push(g)}this.listeners[a]=e}},hasEventListener:function(a,b,c){if("undefined"!=typeof this.listeners[a]){var d=this.listeners[a].length;if(void 0===b&&void 0===c)return d>0;for(var e=0;e<d;e++){var f=this.listeners[a][e];if((!c||f.scope===c)&&f.callback===b)return!0}}return!1},dispatch:function(a,b){for(var c=0,d={type:a,target:b},e=[],f=arguments.length,g=0;g<f;g++)e.push(arguments[g]);if(e=e.length>2?e.splice(2,e.length-1):[],e=[d].concat(e),"undefined"!=typeof this.listeners[a])for(var h=this.listeners[a].length,i=0;i<h;i++){var j=this.listeners[a][i];if(j&&j.callback){var k=e.concat(j.args);j.callback.apply(j.scope,k),c+=1}}},getEvents:function(){var a="";for(var b in this.listeners)for(var c=this.listeners[b].length,d=0;d<c;d++){var e=this.listeners[b][d];a+=e.scope&&e.scope.className?e.scope.className:"anonymous",a+=" listen for '"+b+"'\n"}return a}},a}]).service("eventManager",["EventManager",function(a){return new a}])}(),a.module("ui-leaflet").factory("leafletBoundsHelpers",["leafletLogger","leafletHelpers",function(b,c){function d(b){return a.isDefined(b)&&a.isDefined(b.southWest)&&a.isDefined(b.northEast)&&a.isNumber(b.southWest.lat)&&a.isNumber(b.southWest.lng)&&a.isNumber(b.northEast.lat)&&a.isNumber(b.northEast.lng)}var e=c.isArray,f=c.isNumber,g=c.isFunction,h=c.isDefined,i=b;return{createLeafletBounds:function(a){if(d(a))return L.latLngBounds([a.southWest.lat,a.southWest.lng],[a.northEast.lat,a.northEast.lng])},isValidBounds:d,createBoundsFromArray:function(a){return e(a)&&2===a.length&&e(a[0])&&e(a[1])&&2===a[0].length&&2===a[1].length&&f(a[0][0])&&f(a[0][1])&&f(a[1][0])&&f(a[1][1])?{northEast:{lat:a[0][0],lng:a[0][1]},southWest:{lat:a[1][0],lng:a[1][1]}}:void i.error("[AngularJS - Leaflet] The bounds array is not valid.")},createBoundsFromLeaflet:function(a){if(!(h(a)&&g(a.getNorthEast)&&g(a.getSouthWest)))return void i.error("[AngularJS - Leaflet] The leaflet bounds is not valid object.");var b=a.getNorthEast(),c=a.getSouthWest();return{northEast:{lat:b.lat,lng:b.lng},southWest:{lat:c.lat,lng:c.lng}}}}}]),a.module("ui-leaflet").factory("leafletControlHelpers",["$rootScope","leafletLogger","leafletHelpers","leafletLayerHelpers","leafletMapDefaults",function(b,c,d,e,f){var g=d.isDefined,h=d.isObject,i=e.createLayer,j={},k=d.errorHeader+" [Controls] ",l=c,m=function(a,b,c){var d=f.getDefaults(c);if(!d.controls.layers.visible)return!1;var e=!1;return h(a)&&Object.keys(a).forEach(function(b){var c=a[b];g(c.layerOptions)&&c.layerOptions.showOnSelector===!1||(e=!0)}),h(b)&&Object.keys(b).forEach(function(a){var c=b[a];g(c.layerParams)&&c.layerParams.showOnSelector===!1||(e=!0)}),e},n=function(b){var c=f.getDefaults(b),d={collapsed:c.controls.layers.collapsed,position:c.controls.layers.position,autoZIndex:!1};a.extend(d,c.controls.layers.options);var e;return e=c.controls.layers&&g(c.controls.layers.control)?c.controls.layers.control.apply(this,[[],[],d]):new L.control.layers([],[],d)},o={draw:{isPluginLoaded:function(){return!!a.isDefined(L.Control.Draw)||(l.error(k+" Draw plugin is not loaded."),!1)},checkValidParams:function(){return!0},createControl:function(a){return new L.Control.Draw(a)}},scale:{isPluginLoaded:function(){return!0},checkValidParams:function(){return!0},createControl:function(a){return new L.control.scale(a)}},fullscreen:{isPluginLoaded:function(){return!!a.isDefined(L.Control.Fullscreen)||(l.error(k+" Fullscreen plugin is not loaded."),!1)},checkValidParams:function(){return!0},createControl:function(a){return new L.Control.Fullscreen(a)}},search:{isPluginLoaded:function(){return!!a.isDefined(L.Control.Search)||(l.error(k+" Search plugin is not loaded."),!1)},checkValidParams:function(){return!0},createControl:function(a){return new L.Control.Search(a)}},custom:{},minimap:{isPluginLoaded:function(){return!!a.isDefined(L.Control.MiniMap)||(l.error(k+" Minimap plugin is not loaded."),!1)},checkValidParams:function(a){return!!g(a.layer)||(l.warn(k+' minimap "layer" option should be defined.'),!1)},createControl:function(a){var b=i(a.layer);return g(b)?new L.Control.MiniMap(b,a):void l.warn(k+' minimap control "layer" could not be created.')}}};return{layersControlMustBeVisible:m,isValidControlType:function(a){return Object.keys(o).indexOf(a)!==-1},createControl:function(a,b){if(o[a].checkValidParams(b))return o[a].createControl(b)},updateLayersControl:function(a,b,c,d,e,f){var h,i=j[b],k=m(d,e,b);if(g(i)&&c){for(h in f.baselayers)i.removeLayer(f.baselayers[h]);for(h in f.overlays)i.removeLayer(f.overlays[h]);a.removeControl(i),delete j[b]}if(k){i=n(b),j[b]=i;for(h in d){var l=g(d[h].layerOptions)&&d[h].layerOptions.showOnSelector===!1;!l&&g(f.baselayers[h])&&i.addBaseLayer(f.baselayers[h],d[h].name)}for(h in e){var o=g(e[h].layerParams)&&e[h].layerParams.showOnSelector===!1;!o&&g(f.overlays[h])&&i.addOverlay(f.overlays[h],e[h].name)}a.addControl(i)}return k},destroyMapLayersControl:function(a){delete j[a]}}}]),a.module("ui-leaflet").service("leafletData",["leafletLogger","$q","leafletHelpers",function(a,b,c){var d=c.getDefer,e=c.getUnresolvedDefer,f=c.setResolvedDefer,g={},h=this,i=function(a){return a.charAt(0).toUpperCase()+a.slice(1)},j=["map","tiles","layers","paths","markers","geoJSON","UTFGrid","decorations","directiveControls"];j.forEach(function(a){g[a]={}}),this.unresolveMap=function(a){var b=c.obtainEffectiveMapId(g.map,a);j.forEach(function(a){g[a][b]=void 0})},j.forEach(function(a){var b=i(a);h["set"+b]=function(b,c){var d=e(g[a],c);d.resolve(b),f(g[a],c)},h["get"+b]=function(b){var c=d(g[a],b);return c.promise}})}]),a.module("ui-leaflet").service("leafletDirectiveControlsHelpers",["leafletLogger","leafletData","leafletHelpers",function(b,c,d){var e=d.isDefined,f=d.isString,g=d.isObject,h=d.errorHeader,i=b,j=h+"[leafletDirectiveControlsHelpers",k=function(b,d,h,k){var l=j+".extend] ",m={};if(!e(d))return void i.error(l+"thingToAddName cannot be undefined");if(f(d)&&e(h)&&e(k))m[d]={create:h,clean:k};else{if(!g(d)||e(h)||e(k))return void i.error(l+"incorrect arguments");m=d}c.getDirectiveControls().then(function(d){a.extend(d,m),c.setDirectiveControls(d,b)})};return{extend:k}}]),a.module("ui-leaflet").service("leafletGeoJsonHelpers",["leafletHelpers","leafletIterators",function(b,c){var d=b,e=c,f=function(a,b){return this.lat=a,this.lng=b,this},g=function(a){return Array.isArray(a)&&2===a.length?a[1]:d.isDefined(a.type)&&"Point"===a.type?+a.coordinates[1]:+a.lat},h=function(a){return Array.isArray(a)&&2===a.length?a[0]:d.isDefined(a.type)&&"Point"===a.type?+a.coordinates[0]:+a.lng},i=function(a){if(d.isUndefined(a))return!1;if(d.isArray(a)){if(2===a.length&&d.isNumber(a[0])&&d.isNumber(a[1]))return!0}else if(d.isDefined(a.type)&&"Point"===a.type&&d.isArray(a.coordinates)&&2===a.coordinates.length&&d.isNumber(a.coordinates[0])&&d.isNumber(a.coordinates[1]))return!0;var b=e.all(["lat","lng"],function(b){return d.isDefined(a[b])&&d.isNumber(a[b])});return b},j=function(b){if(b&&i(b)){var c=null;if(Array.isArray(b)&&2===b.length)c=new f(b[1],b[0]);else{if(!d.isDefined(b.type)||"Point"!==b.type)return b;c=new f(b.coordinates[1],b.coordinates[0])}return a.extend(b,c)}};return{getLat:g,getLng:h,validateCoords:i,getCoords:j}}]),a.module("ui-leaflet").service("leafletHelpers",["$q","$log","$timeout",function(b,c,d){function e(b,d){var e,f;if(a.isDefined(d))e=d;else if(0===Object.keys(b).length)e="main";else if(Object.keys(b).length>=1)for(f in b)b.hasOwnProperty(f)&&(e=f);else c.error(g+"- You have more than 1 map on the DOM, you must provide the map ID to the leafletData.getXXX call");return e}function f(c,d){var f,g=e(c,d);return a.isDefined(c[g])&&c[g].resolvedDefer!==!0?f=c[g].defer:(f=b.defer(),c[g]={defer:f,resolvedDefer:!1}),f}var g="[ui-leaflet] ",h=a.copy,i=h,j=function(b,c){var d;if(b&&a.isObject(b))return null!==c&&a.isString(c)?(d=b,c.split(".").forEach(function(a){d&&(d=d[a])}),d):c},k=function(a){return a.split(".").reduce(function(a,b){return a+'["'+b+'"]'})},l=function(a){return a.reduce(function(a,b){return a+"."+b})},m=function(b){return a.isDefined(b)&&null!==b},n=function(a){return!m(a)},o=/([\:\-\_]+(.))/g,p=/^moz([A-Z])/,q=/^((?:x|data)[\:\-_])/i,r=function(a){return a.replace(o,function(a,b,c,d){return d?c.toUpperCase():c}).replace(p,"Moz$1")},s=function(a){return r(a.replace(q,""))},t=10,u=function(a,b,c){if(!a)throw new Error(g+"trapObj is undefined");if(!b)throw new Error(g+"trapField is undefined");a[b]=!0;var e=c();return d(function(){a[b]=!1},t),e};return{watchTrapDelayMilliSec:t,modelChangeInDirective:u,camelCase:r,directiveNormalize:s,copy:h,clone:i,errorHeader:g,getObjectValue:j,getObjectArrayPath:k,getObjectDotPath:l,defaultTo:function(a,b){return m(a)?a:b},isTruthy:function(a){return"true"===a||a===!0},isEmpty:function(a){return 0===Object.keys(a).length},isUndefinedOrEmpty:function(b){return a.isUndefined(b)||null===b||0===Object.keys(b).length},isDefined:m,isUndefined:n,isNumber:a.isNumber,isString:a.isString,isArray:a.isArray,isObject:a.isObject,isFunction:a.isFunction,equals:a.equals,isValidCenter:function(b){return a.isDefined(b)&&a.isNumber(b.lat)&&a.isNumber(b.lng)&&a.isNumber(b.zoom)},isValidPoint:function(b){return!!a.isDefined(b)&&(a.isArray(b)?2===b.length&&a.isNumber(b[0])&&a.isNumber(b[1]):a.isNumber(b.lat)&&a.isNumber(b.lng))},isSameCenterOnMap:function(a,b){var c=b.getCenter(),d=b.getZoom();return!(!a.lat||!a.lng||c.lat.toFixed(4)!==a.lat.toFixed(4)||c.lng.toFixed(4)!==a.lng.toFixed(4)||d!==a.zoom)},safeApply:function(a,b){var c=a.$root.$$phase;"$apply"===c||"$digest"===c?a.$eval(b):a.$evalAsync(b)},obtainEffectiveMapId:e,getDefer:function(b,c){var d,g=e(b,c);return d=a.isDefined(b[g])&&b[g].resolvedDefer!==!1?b[g].defer:f(b,c)},getUnresolvedDefer:f,setResolvedDefer:function(a,b){var c=e(a,b);a[c].resolvedDefer=!0},rangeIsSupported:function(){var a=document.createElement("input");return a.setAttribute("type","range"),"range"===a.type},FullScreenControlPlugin:{isLoaded:function(){return a.isDefined(L.Control.Fullscreen)}},MiniMapControlPlugin:{isLoaded:function(){return a.isDefined(L.Control.MiniMap)}},AwesomeMarkersPlugin:{isLoaded:function(){return a.isDefined(L.AwesomeMarkers)&&a.isDefined(L.AwesomeMarkers.Icon)},is:function(a){return!!this.isLoaded()&&a instanceof L.AwesomeMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},VectorMarkersPlugin:{isLoaded:function(){return a.isDefined(L.VectorMarkers)&&a.isDefined(L.VectorMarkers.Icon)},is:function(a){return!!this.isLoaded()&&a instanceof L.VectorMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},DomMarkersPlugin:{isLoaded:function(){return!(!a.isDefined(L.DomMarkers)||!a.isDefined(L.DomMarkers.Icon))},is:function(a){return!!this.isLoaded()&&a instanceof L.DomMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},PolylineDecoratorPlugin:{isLoaded:function(){return!!a.isDefined(L.PolylineDecorator)},is:function(a){return!!this.isLoaded()&&a instanceof L.PolylineDecorator},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},MakiMarkersPlugin:{isLoaded:function(){return!(!a.isDefined(L.MakiMarkers)||!a.isDefined(L.MakiMarkers.Icon))},is:function(a){return!!this.isLoaded()&&a instanceof L.MakiMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},ExtraMarkersPlugin:{isLoaded:function(){return!(!a.isDefined(L.ExtraMarkers)||!a.isDefined(L.ExtraMarkers.Icon))},is:function(a){return!!this.isLoaded()&&a instanceof L.ExtraMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},LabelPlugin:{isLoaded:function(){return a.isDefined(L.Label)},is:function(a){return!!this.isLoaded()&&a instanceof L.MarkerClusterGroup}},MarkerClusterPlugin:{isLoaded:function(){return a.isDefined(L.MarkerClusterGroup)},is:function(a){return!!this.isLoaded()&&a instanceof L.MarkerClusterGroup}},GeoJSONPlugin:{isLoaded:function(){return a.isDefined(L.TileLayer.GeoJSON)},is:function(a){return!!this.isLoaded()&&a instanceof L.TileLayer.GeoJSON}},CartoDB:{isLoaded:function(){return cartodb},is:function(){return!0}},Leaflet:{DivIcon:{is:function(a){return a instanceof L.DivIcon},equal:function(b,c){return!!this.is(b)&&a.equals(b,c)}},Icon:{is:function(a){return a instanceof L.Icon},equal:function(b,c){return!!this.is(b)&&a.equals(b,c)}}},watchOptions:{type:"watchDeep",individual:{type:"watchDeep"}}}}]),a.module("ui-leaflet").service("leafletIterators",["leafletLogger","leafletHelpers",function(a,b){var c,d=b,e=b.errorHeader+"leafletIterators: ",f=Object.keys,g=d.isFunction,h=d.isObject,i=a,j=Math.pow(2,53)-1,k=function(a){var b=null!==a&&a.length;return d.isNumber(b)&&b>=0&&b<=j},l=function(a){return a},m=function(a){return function(b){return null===b?void 0:b[a]}},n=function(a,b,c){if(void 0===b)return a;switch(null===c?3:c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)};case 4:return function(c,d,e,f){return a.call(b,c,d,e,f)}}return function(){return a.apply(b,arguments)}},o=function(a,b){return function(c){var d=arguments.length;if(d<2||null===c)return c;for(var e=1;e<d;e++)for(var f=arguments[e],g=a(f),h=g.length,i=0;i<h;i++){var j=g[i];b&&void 0!==c[j]||(c[j]=f[j])}return c}},p=null;c=p=o(f);var q,r=function(a,b){var c=f(b),d=c.length;if(null===a)return!d;for(var e=Object(a),g=0;g<d;g++){var h=c[g];if(b[h]!==e[h]||!(h in e))return!1}return!0},s=null;q=s=function(a){return a=c({},a),function(b){return r(b,a)}};var t,u=function(a,b,c){return null===a?l:g(a)?n(a,b,c):h(a)?q(a):m(a)},v=null;t=v=function(a,b,c){b=u(b,c);for(var d=!k(a)&&f(a),e=(d||a).length,g=0;g<e;g++){var h=d?d[g]:g;if(!b(a[h],h,a))return!1}return!0};var w=function(a,b,c,f){return!(c||d.isDefined(a)&&d.isDefined(b))||!d.isFunction(b)&&(f=d.defaultTo(b,"cb"),i.error(e+f+" is not a function"),!0)},x=function(a,b,c){if(!w(void 0,c,!0,"internalCb")&&!w(a,b))for(var d in a)a.hasOwnProperty(d)&&c(a[d],d)},y=function(a,b){x(a,b,function(a,c){b(a,c)})};return{each:y,forEach:y,every:t,all:v}}]),a.module("ui-leaflet").factory("leafletLayerHelpers",["$rootScope","$q","leafletLogger","leafletHelpers","leafletIterators",function(b,c,d,e,f){function g(a){return l(a.type)?Object.keys(t).indexOf(a.type)===-1?(r.error("[AngularJS - Leaflet] A layer must have a valid type: "+Object.keys(t)),!1):t[a.type].mustHaveUrl&&!l(a.url)?(r.error("[AngularJS - Leaflet] A base layer must have an url"),!1):t[a.type].mustHaveData&&!o(a.data)?(r.error('[AngularJS - Leaflet] The base layer must have a "data" array attribute'),!1):t[a.type].mustHaveLayer&&!o(a.layer)?(r.error("[AngularJS - Leaflet] The type of layer "+a.type+" must have an layer defined"),!1):t[a.type].mustHaveBounds&&!o(a.bounds)?(r.error("[AngularJS - Leaflet] The type of layer "+a.type+" must have bounds defined"),!1):!(t[a.type].mustHaveKey&&!o(a.key))||(r.error("[AngularJS - Leaflet] The type of layer "+a.type+" must have key defined"),!1):(r.error("[AngularJS - Leaflet] A layer must have a valid type defined."),!1)}function h(a){if(g(a)){if(!l(a.name))return void r.error("[AngularJS - Leaflet] A base layer must have a name");m(a.layerParams)||(a.layerParams={}),m(a.layerOptions)||(a.layerOptions={});for(var b in a.layerParams)a.layerOptions[b]=a.layerParams[b];var c={url:a.url,data:a.data,options:a.layerOptions,layer:a.layer,icon:a.icon,type:a.layerType,bounds:a.bounds,key:a.key,apiKey:a.apiKey,pluginOptions:a.pluginOptions,user:a.user,$parent:a};return t[a.type].createLayer(c)}}function i(a,b){b&&"function"==typeof b.addTo?b.addTo(a):a.addLayer(b)}function j(b,c,d){if(o(d)&&o(d.loadedDefer))if(a.isFunction(d.loadedDefer)){var e=d.loadedDefer();r.debug("Loaded Deferred",e);var f=e.length;if(f>0)for(var g=function(){f--,0===f&&b.removeLayer(c)},h=0;h<e.length;h++)e[h].promise.then(g);else b.removeLayer(c)}else d.loadedDefer.promise.then(function(){b.removeLayer(c)});else b.removeLayer(c)}var k=e,l=e.isString,m=e.isObject,n=e.isArray,o=e.isDefined,p=e.errorHeader,q=f,r=d,s=function(c){if(!k.UTFGridPlugin.isLoaded())return void r.error("[AngularJS - Leaflet] The UTFGrid plugin is not loaded.");var d=new L.UtfGrid(c.url,c.pluginOptions),e={model:c.$parent};return d.on("mouseover",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridMouseover",e)}),d.on("mouseout",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridMouseout",e)}),d.on("click",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridClick",e)}),d.on("mousemove",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridMousemove",e)}),d},t={xyz:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer(a.url,a.options)}},geoJSON:{mustHaveUrl:!0,createLayer:function(a){if(k.GeoJSONPlugin.isLoaded())return new L.TileLayer.GeoJSON(a.url,a.pluginOptions,a.options)}},geoJSONShape:{mustHaveUrl:!1,createLayer:function(a){return new L.GeoJSON(a.data,a.options)}},geoJSONAwesomeMarker:{mustHaveUrl:!1,createLayer:function(a){return new L.geoJson(a.data,{pointToLayer:function(b,c){return L.marker(c,{icon:L.AwesomeMarkers.icon(a.icon)})}})}},geoJSONVectorMarker:{mustHaveUrl:!1,createLayer:function(a){return new L.geoJson(a.data,{pointToLayer:function(b,c){return L.marker(c,{icon:L.VectorMarkers.icon(a.icon)})}})}},cartodbTiles:{mustHaveKey:!0,createLayer:function(a){var b=o(a.url)?a.url+"/"+a.user:"//"+a.user+".cartodb.com";return b+="/api/v1/map/"+a.key+"/{z}/{x}/{y}.png",L.tileLayer(b,a.options)}},cartodbUTFGrid:{mustHaveKey:!0,mustHaveLayer:!0,createLayer:function(a){var b=o(a.url)?a.url+"/"+a.user:"//"+a.user+".cartodb.com";return a.url=b+"/api/v1/map/"+a.key+"/"+a.layer+"/{z}/{x}/{y}.grid.json",s(a)}},cartodbInteractive:{mustHaveKey:!0,mustHaveLayer:!0,createLayer:function(b){var c=o(b.url)?b.url+"/"+b.user:"//"+b.user+".cartodb.com",d=c+"/api/v1/map/"+b.key+"/{z}/{x}/{y}.png",e=L.tileLayer(d,b.options),f=[e],g=function(b,d,e){var f=a.copy(d);f.url=c+"/api/v1/map/"+f.key+"/"+e+"/{z}/{x}/{y}.grid.json",b.push(s(f))};if(n(b.layer))for(var h=0;h<b.layer.length;h++)g(f,b,b.layer[h]);else g(f,b,b.layer);return L.layerGroup(f)}},wms:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer.wms(a.url,a.options)}},wmts:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer.wmts(a.url,a.options)}},group:{mustHaveUrl:!1,createLayer:function(a){var b=[];return q.each(a.options.layers,function(a){b.push(h(a))}),a.options.loadedDefer=function(){var b=[];if(o(a.options.layers))for(var c=0;c<a.options.layers.length;c++){var d=a.options.layers[c].layerOptions.loadedDefer;o(d)&&b.push(d)}return b},L.layerGroup(b)}},featureGroup:{mustHaveUrl:!1,createLayer:function(){return L.featureGroup()}},markercluster:{mustHaveUrl:!1,createLayer:function(a){return k.MarkerClusterPlugin.isLoaded()?new L.MarkerClusterGroup(a.options):void r.warn(p+" The markercluster plugin is not loaded.")}},imageOverlay:{mustHaveUrl:!0,mustHaveBounds:!0,createLayer:function(a){return L.imageOverlay(a.url,a.bounds,a.options)}},iip:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer.iip(a.url,a.options)}},custom:{createLayer:function(b){return b.layer instanceof L.Class?a.copy(b.layer):void r.error("[AngularJS - Leaflet] A custom layer must be a leaflet Class")}},cartodb:{mustHaveUrl:!0,createLayer:function(a){return cartodb.createLayer(a.map,a.url)}}},u=function(a){return function(b){o(b.setOpacity)&&b.setOpacity(a)}};return{createLayer:h,layerTypes:t,safeAddLayer:i,safeRemoveLayer:j,changeOpacityListener:u}}]),a.module("ui-leaflet").factory("leafletLegendHelpers",["$http","$q","$log","leafletHelpers",function(a,b,c,d){var e={},f=d.isDefined,g=function b(c){var d=e[c],f=d[0];a(f.c).then(function(a){d.shift(),f.d.resolve(a),d.length>0&&b(c)},function(a){d.shift(),f.d.reject(a),d.length>0&&b(c)})},h=function(a,b,c,d){if(a.innerHTML="",b.error)a.innerHTML+='<div class="info-title alert alert-danger">'+b.error.message+"</div>";else if("arcgis"===c)for(var e=0;e<b.layers.length;e++){var f=b.layers[e];a.innerHTML+='<div class="info-title" data-layerid="'+f.layerId+'">'+f.layerName+"</div>";for(var g=0;g<f.legend.length;g++){var h=f.legend[g];a.innerHTML+='<div class="inline" data-layerid="'+f.layerId+'"><img src="data:'+h.contentType+";base64,"+h.imageData+'" /></div><div class="info-label" data-layerid="'+f.layerId+'">'+h.label+"</div>"}}else"image"===c&&(a.innerHTML='<img src="'+d+'"/>')},i=function(a,b,c,d){return function(){var e=L.DomUtil.create("div",b);return L.Browser.touch?L.DomEvent.on(e,"click",L.DomEvent.stopPropagation):(L.DomEvent.disableClickPropagation(e),L.DomEvent.on(e,"mousewheel",L.DomEvent.stopPropagation)),h(e,a,c,d),e}},j=function(a,b){return function(){for(var c=L.DomUtil.create("div",b),d=0;d<a.colors.length;d++)c.innerHTML+='<div class="outline"><i style="background:'+a.colors[d]+'"></i></div><div class="info-label">'+a.labels[d]+"</div>";return L.Browser.touch?L.DomEvent.on(c,"click",L.DomEvent.stopPropagation):(L.DomEvent.disableClickPropagation(c),L.DomEvent.on(c,"mousewheel",L.DomEvent.stopPropagation)),c}};return{getOnAddLegend:i,getOnAddArrayLegend:j,updateLegend:h,addLegendURL:function(a,c){var d=b.defer();return f(e[a])||(e[a]=[]),e[a].push({c:c,d:d}),1===e[a].length&&g(a),d.promise}}}]),a.module("ui-leaflet").factory("leafletMapDefaults",["$q","leafletHelpers",function(b,c){function d(){return{keyboard:!0,dragging:!0,worldCopyJump:!1,doubleClickZoom:!0,scrollWheelZoom:!0,tap:!0,touchZoom:!0,zoomControl:!0,zoomsliderControl:!1,zoomControlPosition:"topleft",attributionControl:!0,controls:{layers:{visible:!0,position:"topright",collapsed:!0}},nominatim:{server:" http://nominatim.openstreetmap.org/search"},crs:L.CRS.EPSG3857,tileLayer:"//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",tileLayerOptions:{attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'},path:{weight:10,opacity:1,color:"#0000ff"},center:{lat:0,lng:0,zoom:1},trackResize:!0}}var e=c.isDefined,f=c.isObject,g=c.obtainEffectiveMapId,h={};return{reset:function(){h={}},getDefaults:function(a){var b=g(h,a);return h[b]},getMapCreationDefaults:function(a){var b=g(h,a),c=h[b],d={maxZoom:c.maxZoom,keyboard:c.keyboard,dragging:c.dragging,zoomControl:c.zoomControl,doubleClickZoom:c.doubleClickZoom,scrollWheelZoom:c.scrollWheelZoom,tap:c.tap,touchZoom:c.touchZoom,attributionControl:c.attributionControl,worldCopyJump:c.worldCopyJump,crs:c.crs,trackResize:c.trackResize};if(e(c.minZoom)&&(d.minZoom=c.minZoom),e(c.zoomAnimation)&&(d.zoomAnimation=c.zoomAnimation),e(c.fadeAnimation)&&(d.fadeAnimation=c.fadeAnimation),e(c.markerZoomAnimation)&&(d.markerZoomAnimation=c.markerZoomAnimation),c.map)for(var f in c.map)d[f]=c.map[f];return d},setDefaults:function(b,c){var i=d();e(b)&&(i.doubleClickZoom=e(b.doubleClickZoom)?b.doubleClickZoom:i.doubleClickZoom,i.scrollWheelZoom=e(b.scrollWheelZoom)?b.scrollWheelZoom:i.doubleClickZoom,i.tap=e(b.tap)?b.tap:i.tap,i.touchZoom=e(b.touchZoom)?b.touchZoom:i.doubleClickZoom,i.zoomControl=e(b.zoomControl)?b.zoomControl:i.zoomControl,i.zoomsliderControl=e(b.zoomsliderControl)?b.zoomsliderControl:i.zoomsliderControl,i.attributionControl=e(b.attributionControl)?b.attributionControl:i.attributionControl,i.tileLayer=e(b.tileLayer)?b.tileLayer:i.tileLayer,i.zoomControlPosition=e(b.zoomControlPosition)?b.zoomControlPosition:i.zoomControlPosition,i.keyboard=e(b.keyboard)?b.keyboard:i.keyboard,i.dragging=e(b.dragging)?b.dragging:i.dragging,i.trackResize=e(b.trackResize)?b.trackResize:i.trackResize,e(b.controls)&&a.extend(i.controls,b.controls),f(b.crs)?i.crs=b.crs:e(L.CRS[b.crs])&&(i.crs=L.CRS[b.crs]),e(b.center)&&a.copy(b.center,i.center),e(b.tileLayerOptions)&&a.copy(b.tileLayerOptions,i.tileLayerOptions),e(b.maxZoom)&&(i.maxZoom=b.maxZoom),e(b.minZoom)&&(i.minZoom=b.minZoom),e(b.zoomAnimation)&&(i.zoomAnimation=b.zoomAnimation),e(b.fadeAnimation)&&(i.fadeAnimation=b.fadeAnimation),e(b.markerZoomAnimation)&&(i.markerZoomAnimation=b.markerZoomAnimation),e(b.worldCopyJump)&&(i.worldCopyJump=b.worldCopyJump),e(b.map)&&(i.map=b.map),e(b.path)&&(i.path=b.path));var j=g(h,c);return h[j]=i,i}}}]),a.module("ui-leaflet").service("leafletMarkersHelpers",["$rootScope","$timeout","leafletHelpers","leafletLogger","$compile","leafletGeoJsonHelpers","leafletWatchHelpers",function(b,c,d,e,f,g,h){var i=d.isDefined,j=d.defaultTo,k=d.MarkerClusterPlugin,l=d.AwesomeMarkersPlugin,m=d.VectorMarkersPlugin,n=d.MakiMarkersPlugin,o=d.ExtraMarkersPlugin,p=d.DomMarkersPlugin,q=d.safeApply,r=d,s=d.isString,t=d.isNumber,u=d.isObject,v={},w=g,x=d.errorHeader,y=h.maybeWatch,z=e,A=function(a){var b="";return["_icon","_latlng","_leaflet_id","_map","_shadow"].forEach(function(c){b+=c+": "+j(a[c],"undefined")+" \n"}),"[leafletMarker] : \n"+b},B=function(a,b){var c=b?console:z;c.debug(A(a))},C=function(b){return a.element(v[b]._map._container).parent().length>0},D=function(c){if(i(c)&&i(c.type)&&"awesomeMarker"===c.type)return l.isLoaded()||z.error(x+" The AwesomeMarkers Plugin is not loaded."),new L.AwesomeMarkers.icon(c);if(i(c)&&i(c.type)&&"vectorMarker"===c.type)return m.isLoaded()||z.error(x+" The VectorMarkers Plugin is not loaded."),new L.VectorMarkers.icon(c);if(i(c)&&i(c.type)&&"makiMarker"===c.type)return n.isLoaded()||z.error(x+"The MakiMarkers Plugin is not loaded."),new L.MakiMarkers.icon(c);if(i(c)&&i(c.type)&&"extraMarker"===c.type)return o.isLoaded()||z.error(x+"The ExtraMarkers Plugin is not loaded."),new L.ExtraMarkers.icon(c);if(i(c)&&i(c.type)&&"div"===c.type)return new L.divIcon(c);if(i(c)&&i(c.type)&&"dom"===c.type){p.isLoaded()||z.error(x+"The DomMarkers Plugin is not loaded.");var d=a.isFunction(c.getMarkerScope)?c.getMarkerScope().$new():b,e=f(c.template)(d),g=a.copy(c);return g.ngElement=e,g.element=e[0],a.isFunction(c.getMarkerScope)&&(g.scope=d),new L.DomMarkers.icon(g)}if(i(c)&&i(c.type)&&"icon"===c.type)return c.icon;var h="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAGmklEQVRYw7VXeUyTZxjvNnfELFuyIzOabermMZEeQC/OclkO49CpOHXOLJl/CAURuYbQi3KLgEhbrhZ1aDwmaoGqKII6odATmH/scDFbdC7LvFqOCc+e95s2VG50X/LLm/f4/Z7neY/ne18aANCmAr5E/xZf1uDOkTcGcWR6hl9247tT5U7Y6SNvWsKT63P58qbfeLJG8M5qcgTknrvvrdDbsT7Ml+tv82X6vVxJE33aRmgSyYtcWVMqX97Yv2JvW39UhRE2HuyBL+t+gK1116ly06EeWFNlAmHxlQE0OMiV6mQCScusKRlhS3QLeVJdl1+23h5dY4FNB3thrbYboqptEFlphTC1hSpJnbRvxP4NWgsE5Jyz86QNNi/5qSUTGuFk1gu54tN9wuK2wc3o+Wc13RCmsoBwEqzGcZsxsvCSy/9wJKf7UWf1mEY8JWfewc67UUoDbDjQC+FqK4QqLVMGGR9d2wurKzqBk3nqIT/9zLxRRjgZ9bqQgub+DdoeCC03Q8j+0QhFhBHR/eP3U/zCln7Uu+hihJ1+bBNffLIvmkyP0gpBZWYXhKussK6mBz5HT6M1Nqpcp+mBCPXosYQfrekGvrjewd59/GvKCE7TbK/04/ZV5QZYVWmDwH1mF3xa2Q3ra3DBC5vBT1oP7PTj4C0+CcL8c7C2CtejqhuCnuIQHaKHzvcRfZpnylFfXsYJx3pNLwhKzRAwAhEqG0SpusBHfAKkxw3w4627MPhoCH798z7s0ZnBJ/MEJbZSbXPhER2ih7p2ok/zSj2cEJDd4CAe+5WYnBCgR2uruyEw6zRoW6/DWJ/OeAP8pd/BGtzOZKpG8oke0SX6GMmRk6GFlyAc59K32OTEinILRJRchah8HQwND8N435Z9Z0FY1EqtxUg+0SO6RJ/mmXz4VuS+DpxXC3gXmZwIL7dBSH4zKE50wESf8qwVgrP1EIlTO5JP9Igu0aexdh28F1lmAEGJGfh7jE6ElyM5Rw/FDcYJjWhbeiBYoYNIpc2FT/SILivp0F1ipDWk4BIEo2VuodEJUifhbiltnNBIXPUFCMpthtAyqws/BPlEF/VbaIxErdxPphsU7rcCp8DohC+GvBIPJS/tW2jtvTmmAeuNO8BNOYQeG8G/2OzCJ3q+soYB5i6NhMaKr17FSal7GIHheuV3uSCY8qYVuEm1cOzqdWr7ku/R0BDoTT+DT+ohCM6/CCvKLKO4RI+dXPeAuaMqksaKrZ7L3FE5FIFbkIceeOZ2OcHO6wIhTkNo0ffgjRGxEqogXHYUPHfWAC/lADpwGcLRY3aeK4/oRGCKYcZXPVoeX/kelVYY8dUGf8V5EBRbgJXT5QIPhP9ePJi428JKOiEYhYXFBqou2Guh+p/mEB1/RfMw6rY7cxcjTrneI1FrDyuzUSRm9miwEJx8E/gUmqlyvHGkneiwErR21F3tNOK5Tf0yXaT+O7DgCvALTUBXdM4YhC/IawPU+2PduqMvuaR6eoxSwUk75ggqsYJ7VicsnwGIkZBSXKOUww73WGXyqP+J2/b9c+gi1YAg/xpwck3gJuucNrh5JvDPvQr0WFXf0piyt8f8/WI0hV4pRxxkQZdJDfDJNOAmM0Ag8jyT6hz0WGXWuP94Yh2jcfjmXAGvHCMslRimDHYuHuDsy2QtHuIavznhbYURq5R57KpzBBRZKPJi8eQg48h4j8SDdowifdIrEVdU+gbO6QNvRRt4ZBthUaZhUnjlYObNagV3keoeru3rU7rcuceqU1mJBxy+BWZYlNEBH+0eH4vRiB+OYybU2hnblYlTvkHinM4m54YnxSyaZYSF6R3jwgP7udKLGIX6r/lbNa9N6y5MFynjWDtrHd75ZvTYAPO/6RgF0k76mQla3FGq7dO+cH8sKn0Vo7nDllwAhqwLPkxrHwWmHJOo+AKJ4rab5OgrM7rVu8eWb2Pu0Dh4eDgXoOfvp7Y7QeqknRmvcTBEyq9m/HQQSCSz6LHq3z0yzsNySRfMS253wl2KyRDbcZPcfJKjZmSEOjcxyi+Y8dUOtsIEH6R2wNykdqrkYJ0RV92H0W58pkfQk7cKevsLK10Py8SdMGfXNXATY+pPbyJR/ET6n9nIfztNtZYRV9XniQu9IA2vOVgy4ir7GCLVmmd+zjkH0eAF9Po6K61pmCXHxU5rHMYd1ftc3owjwRSVRzLjKvqZEty6cRUD7jGqiOdu5HG6MdHjNcNYGqfDm5YRzLBBCCDl/2bk8a8gdbqcfwECu62Fg/HrggAAAABJRU5ErkJggg==",j="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=";
+return i(c)&&i(c.iconUrl)?new L.Icon(c):new L.Icon.Default({iconUrl:h,shadowUrl:j,iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]})},E=function(a){i(v[a])&&delete v[a]},F=function(){v={}},G=function(){for(var a in v)C(a)||E(a)},H=function(a){a.options.icon.options.ngElement&&a.options.icon.options.ngElement.remove(),a.options.icon.options.scope&&a.options.icon.options.scope.$destroy()},I=function(a,b,c){if(a.closePopup(),a.options.icon&&a.options.icon.options&&"dom"===a.options.icon.options.type&&H(a),i(c)&&i(c.overlays))for(var d in c.overlays)if((c.overlays[d]instanceof L.LayerGroup||c.overlays[d]instanceof L.FeatureGroup)&&c.overlays[d].hasLayer(a))return void c.overlays[d].removeLayer(a);if(i(v))for(var e in v)v[e].hasLayer(a)&&v[e].removeLayer(a);b.hasLayer(a)&&b.removeLayer(a)},J=function(a,b){var c=a._popup._container.offsetHeight,d=new L.Point(a._popup._containerLeft,-c-a._popup._containerBottom),e=b.layerPointToContainerPoint(d);null!==e&&a._popup._adjustPan()},K=function(a,b){f(a._popup._contentNode)(b)},M=function a(b,d,e){var f=b._popup._contentNode.innerText||b._popup._contentNode.textContent;f.length<1&&c(function(){a(b,d,e)});var g=b._popup._contentNode.offsetWidth;return b._popup._updateLayout(),b._popup._updatePosition(),b._popup.options.autoPan&&J(b,e),g},N=function(c,d,e){var f=a.isFunction(d.getMessageScope)?d.getMessageScope():b,g=!i(d.compileMessage)||d.compileMessage;if(g){if(!i(c._popup)||!i(c._popup._contentNode))return z.error(x+"Popup is invalid or does not have any content."),!1;K(c,f),M(c,d,e)}},O=function(c,d){var e=a.isFunction(d.getMessageScope)?d.getMessageScope():b,g=a.isFunction(d.getLabelScope)?d.getLabelScope():e,h=!i(d.compileMessage)||d.compileMessage;r.LabelPlugin.isLoaded()&&i(d.label)&&(i(d.label.options)&&d.label.options.noHide===!0&&c.showLabel(),h&&i(c.label)&&f(c.label._container)(g))},P=function(b,c,d,e,f,g,h){if(i(c)){if(!w.validateCoords(b))return z.warn("There are problems with lat-lng data, please verify your marker model"),void I(d,h,g);var j=b===c;if(i(b.iconAngle)&&c.iconAngle!==b.iconAngle&&d.setIconAngle(b.iconAngle),s(b.layer)||s(c.layer)&&(i(g.overlays[c.layer])&&g.overlays[c.layer].hasLayer(d)&&(g.overlays[c.layer].removeLayer(d),d.closePopup()),h.hasLayer(d)||h.addLayer(d)),(t(b.opacity)||t(parseFloat(b.opacity)))&&b.opacity!==c.opacity&&d.setOpacity(b.opacity),s(b.layer)&&c.layer!==b.layer){if(s(c.layer)&&i(g.overlays[c.layer])&&g.overlays[c.layer].hasLayer(d)&&g.overlays[c.layer].removeLayer(d),d.closePopup(),h.hasLayer(d)&&h.removeLayer(d),!i(g.overlays[b.layer]))return void z.error(x+"You must use a name of an existing layer");var k=g.overlays[b.layer];if(!(k instanceof L.LayerGroup||k instanceof L.FeatureGroup))return void z.error(x+'A marker can only be added to a layer of type "group" or "featureGroup"');k.addLayer(d),h.hasLayer(d)&&b.focus===!0&&d.openPopup()}if(b.draggable!==!0&&c.draggable===!0&&i(d.dragging)&&d.dragging.disable(),b.draggable===!0&&c.draggable!==!0&&(d.dragging?d.dragging.enable():L.Handler.MarkerDrag&&(d.dragging=new L.Handler.MarkerDrag(d),d.options.draggable=!0,d.dragging.enable())),u(b.icon)||u(c.icon)&&("dom"===c.icon.type&&H(d),d.setIcon(D()),d.closePopup(),d.unbindPopup(),s(b.message)&&d.bindPopup(b.message,b.popupOptions)),u(b.icon)&&u(c.icon)&&!a.equals(b.icon,c.icon)){var l=!1;d.dragging&&(l=d.dragging.enabled()),"dom"===c.icon.type&&H(d),d.setIcon(D(b.icon)),l&&d.dragging.enable(),d.closePopup(),d.unbindPopup(),s(b.message)&&(d.bindPopup(b.message,b.popupOptions),h.hasLayer(d)&&b.focus===!0&&d.openPopup())}!s(b.message)&&s(c.message)&&(d.closePopup(),d.unbindPopup()),r.LabelPlugin.isLoaded()&&(i(b.label)&&i(b.label.message)?"label"in c&&"message"in c.label&&!a.equals(b.label.message,c.label.message)?d.updateLabelContent(b.label.message):!a.isFunction(d.getLabel)||a.isFunction(d.getLabel)&&!i(d.getLabel())?(d.bindLabel(b.label.message,b.label.options),O(d,b)):O(d,b):"label"in b&&!("message"in b.label)||a.isFunction(d.unbindLabel)&&d.unbindLabel()),s(b.message)&&!s(c.message)&&d.bindPopup(b.message,b.popupOptions),s(b.message)&&s(c.message)&&b.message!==c.message&&d.setPopupContent(b.message);var m=!1;b.focus!==!0&&c.focus===!0&&(d.closePopup(),m=!0),(b.focus===!0&&(!i(c.focus)||c.focus===!1)||j&&b.focus===!0)&&(d.openPopup(),m=!0),c.zIndexOffset!==b.zIndexOffset&&d.setZIndexOffset(b.zIndexOffset);var n=d.getLatLng(),o=s(b.layer)&&r.MarkerClusterPlugin.is(g.overlays[b.layer]);o?m?b.lat===c.lat&&b.lng===c.lng||(g.overlays[b.layer].removeLayer(d),d.setLatLng([b.lat,b.lng]),g.overlays[b.layer].addLayer(d)):n.lat!==b.lat||n.lng!==b.lng?(g.overlays[b.layer].removeLayer(d),d.setLatLng([b.lat,b.lng]),g.overlays[b.layer].addLayer(d)):b.lat!==c.lat||b.lng!==c.lng?(g.overlays[b.layer].removeLayer(d),d.setLatLng([b.lat,b.lng]),g.overlays[b.layer].addLayer(d)):u(b.icon)&&u(c.icon)&&!a.equals(b.icon,c.icon)&&(g.overlays[b.layer].removeLayer(d),g.overlays[b.layer].addLayer(d)):n.lat===b.lat&&n.lng===b.lng||d.setLatLng([b.lat,b.lng])}},Q=function(a,b){if(i(a))return b?a[b]:a},R=function(a,b,c){if(i(a))return b?c?a[c][b]:a[b]:void z.error(x+"marker id missing in getMarker")};return{resetMarkerGroup:E,resetMarkerGroups:F,resetUnusedMarkerGroups:G,deleteMarker:I,manageOpenPopup:N,manageOpenLabel:O,createMarker:function(a){if(!i(a)||!w.validateCoords(a))return void z.error(x+"The marker definition is not valid.");var b=w.getCoords(a);if(!i(b))return void z.error(x+"Unable to get coordinates from markerData.");var c={icon:D(a.icon),title:i(a.title)?a.title:"",draggable:!!i(a.draggable)&&a.draggable,clickable:!i(a.clickable)||a.clickable,riseOnHover:!!i(a.riseOnHover)&&a.riseOnHover,zIndexOffset:i(a.zIndexOffset)?a.zIndexOffset:0,iconAngle:i(a.iconAngle)?a.iconAngle:0};for(var d in a)a.hasOwnProperty(d)&&!c.hasOwnProperty(d)&&(c[d]=a[d]);var e=new L.marker(b,c);return s(a.message)||e.unbindPopup(),e},addMarkerToGroup:function(a,b,c,d){return s(b)?k.isLoaded()?(i(v[b])||(v[b]=new L.MarkerClusterGroup(c),d.addLayer(v[b])),void v[b].addLayer(a)):void z.error(x+"The MarkerCluster plugin is not loaded."):void z.error(x+"The marker group you have specified is invalid.")},listenMarkerEvents:function(a,b,c,d,e){a.on("popupopen",function(){q(c,function(){(i(a._popup)||i(a._popup._contentNode))&&(b.focus=!0,N(a,b,e))})}),a.on("popupclose",function(){q(c,function(){b.focus=!1})}),a.on("add",function(){q(c,function(){"label"in b&&O(a,b)})})},updateMarker:P,addMarkerWatcher:function(a,b,c,d,e,f){var g=r.getObjectArrayPath("markers."+b);y(c,g,f,function(f,g,h){return i(f)?void P(f,g,a,b,c,d,e):(I(a,e,d),void h())})},string:A,log:B,getModelFromModels:R,getLayerModels:Q}}]),a.module("ui-leaflet").factory("leafletPathsHelpers",["$rootScope","leafletLogger","leafletHelpers",function(a,b,c){function d(a){return a.filter(function(a){return k(a)}).map(function(a){return e(a)})}function e(a){return i(a)?new L.LatLng(a[0],a[1]):new L.LatLng(a.lat,a.lng)}function f(a){return a.map(function(a){return d(a)})}function g(a,b){for(var c={},d=0;d<m.length;d++){var e=m[d];h(a[e])?c[e]=a[e]:h(b.path[e])&&(c[e]=b.path[e])}return c}var h=c.isDefined,i=c.isArray,j=c.isNumber,k=c.isValidPoint,l=b,m=["stroke","weight","color","opacity","fill","fillColor","fillOpacity","dashArray","lineCap","lineJoin","clickable","pointerEvents","className","smoothFactor","noClip"],n=function(a,b){for(var c={},d=0;d<m.length;d++){var e=m[d];h(b[e])&&(c[e]=b[e])}a.setStyle(b)},o=function(a){if(!i(a))return!1;for(var b=0;b<a.length;b++){var c=a[b];if(!k(c))return!1}return!0},p={polyline:{isValid:function(a){var b=a.latlngs;return o(b)},createPath:function(a){return new L.Polyline([],a)},setPath:function(a,b){a.setLatLngs(d(b.latlngs)),n(a,b)}},multiPolyline:{isValid:function(a){var b=a.latlngs;if(!i(b))return!1;for(var c in b){var d=b[c];if(!o(d))return!1}return!0},createPath:function(a){return new L.multiPolyline([[[0,0],[1,1]]],a)},setPath:function(a,b){a.setLatLngs(f(b.latlngs)),n(a,b)}},polygon:{isValid:function(a){var b=a.latlngs;return o(b)},createPath:function(a){return new L.Polygon([],a)},setPath:function(a,b){a.setLatLngs(d(b.latlngs)),n(a,b)}},multiPolygon:{isValid:function(a){var b=a.latlngs;if(!i(b))return!1;for(var c in b){var d=b[c];if(!o(d))return!1}return!0},createPath:function(a){return new L.MultiPolygon([[[0,0],[1,1],[0,1]]],a)},setPath:function(a,b){a.setLatLngs(f(b.latlngs)),n(a,b)}},rectangle:{isValid:function(a){var b=a.latlngs;if(!i(b)||2!==b.length)return!1;for(var c in b){var d=b[c];if(!k(d))return!1}return!0},createPath:function(a){return new L.Rectangle([[0,0],[1,1]],a)},setPath:function(a,b){a.setBounds(new L.LatLngBounds(d(b.latlngs))),n(a,b)}},circle:{isValid:function(a){var b=a.latlngs;return k(b)&&j(a.radius)},createPath:function(a){return new L.Circle([0,0],1,a)},setPath:function(a,b){a.setLatLng(e(b.latlngs)),h(b.radius)&&a.setRadius(b.radius),n(a,b)}},circleMarker:{isValid:function(a){var b=a.latlngs;return k(b)&&j(a.radius)},createPath:function(a){return new L.CircleMarker([0,0],a)},setPath:function(a,b){a.setLatLng(e(b.latlngs)),h(b.radius)&&a.setRadius(b.radius),n(a,b)}}},q=function(a){var b={};return a.latlngs&&(b.latlngs=a.latlngs),a.radius&&(b.radius=a.radius),b};return{setPathOptions:function(a,b,c){h(b)||(b="polyline"),p[b].setPath(a,c)},createPath:function(a,b,c){h(b.type)||(b.type="polyline");var d=g(b,c),e=q(b);return p[b.type].isValid(e)?p[b.type].createPath(d):void l.error("[AngularJS - Leaflet] Invalid data passed to the "+b.type+" path")}}}]),a.module("ui-leaflet").service("leafletWatchHelpers",function(){var a=function(a,b,c,d,e){var f=a[b](c,function(a,b){e(a,b,f),null===d.type&&f()},"watchDeep"===d.type);return f},b=function(b,c,d,e){var f;return f="watchCollection"===d.type?"$watchCollection":"$watch",a(b,f,c,d,e)};return{maybeWatch:b}}),a.module("ui-leaflet").service("leafletLogger",["nemSimpleLogger",function(a){return a.spawn()}]),a.module("ui-leaflet").factory("nominatimService",["$q","$http","leafletHelpers","leafletMapDefaults",function(a,b,c,d){var e=c.isDefined;return{query:function(c,f){var g=d.getDefaults(f),h=g.nominatim.server,i=a.defer();return b.get(h,{params:{format:"json",limit:1,q:c}}).success(function(a){a.length>0&&e(a[0].boundingbox)?i.resolve(a[0]):i.reject("[Nominatim] Invalid address")}),i.promise}}}]),a.module("ui-leaflet").directive("bounds",["leafletLogger","$timeout","$http","leafletHelpers","nominatimService","leafletBoundsHelpers",function(b,c,d,e,f,g){var h=b;return{restrict:"A",scope:!1,replace:!1,require:["leaflet"],link:function(b,d,i,j){var k=e.isDefined,l=g.createLeafletBounds,m=j[0].getLeafletScope(),n=j[0],o=e.errorHeader+" [Bounds] ",p=function(a){return 0===a._southWest.lat&&0===a._southWest.lng&&0===a._northEast.lat&&0===a._northEast.lng};n.getMap().then(function(d){m.$on("boundsChanged",function(b){var e=b.currentScope,f=d.getBounds();if(!p(f)&&!e.settingBoundsFromScope){e.settingBoundsFromLeaflet=!0;var g={northEast:{lat:f._northEast.lat,lng:f._northEast.lng},southWest:{lat:f._southWest.lat,lng:f._southWest.lng},options:f.options};a.equals(e.bounds,g)||(e.bounds=g),c(function(){e.settingBoundsFromLeaflet=!1})}});var e;m.$watch("bounds",function(a){if(!b.settingBoundsFromLeaflet){if(k(a.address)&&a.address!==e)return b.settingBoundsFromScope=!0,f.query(a.address,i.id).then(function(a){var b=a.boundingbox,c=[[b[0],b[2]],[b[1],b[3]]];d.fitBounds(c)},function(a){h.error(o+" "+a+".")}),e=a.address,void c(function(){b.settingBoundsFromScope=!1});var g=l(a);g&&!d.getBounds().equals(g)&&(b.settingBoundsFromScope=!0,d.fitBounds(g,a.options),c(function(){b.settingBoundsFromScope=!1}))}},!0)})}}}]);var b=["center","lfCenter"],c={};b.forEach(function(b){c[b]=["leafletLogger","$q","$location","$timeout","leafletMapDefaults","leafletHelpers","leafletBoundsHelpers","leafletMapEvents",function(c,d,e,f,g,h,i,j){var k,l=h.isDefined,m=h.isNumber,n=h.isSameCenterOnMap,o=h.safeApply,p=h.isValidCenter,q=i.isValidBounds,r=h.isUndefinedOrEmpty,s=h.errorHeader,t=c,u=function(a,b){return l(a)&&q(a)&&r(b)};return{restrict:"A",scope:!1,replace:!1,require:"leaflet",controller:function(){k=d.defer(),this.getCenter=function(){return k.promise}},link:function(c,d,h,q){var r=q.getLeafletScope(),v=r[b];q.getMap().then(function(c){var d=g.getDefaults(h.id);if(h[b].search("-")!==-1)return t.error(s+' The "center" variable can\'t use a "-" on its key name: "'+h[b]+'".'),void c.setView([d.center.lat,d.center.lng],d.center.zoom);if(u(r.bounds,v))c.fitBounds(i.createLeafletBounds(r.bounds),r.bounds.options),v=c.getCenter(),o(r,function(d){a.extend(d[b],{lat:c.getCenter().lat,lng:c.getCenter().lng,zoom:c.getZoom(),autoDiscover:!1})}),o(r,function(a){var b=c.getBounds();a.bounds={northEast:{lat:b._northEast.lat,lng:b._northEast.lng},southWest:{lat:b._southWest.lat,lng:b._southWest.lng}}});else{if(!l(v))return t.error(s+' The "center" property is not defined in the main scope'),void c.setView([d.center.lat,d.center.lng],d.center.zoom);l(v.lat)&&l(v.lng)||l(v.autoDiscover)||a.copy(d.center,v)}var q,w;if("yes"===h.urlHashCenter){var x=function(){var a,b=e.search(),c=h.urlHashParam?h.urlHashParam:"c";if(l(b[c])){var d=b[c].split(":");3===d.length&&(a={lat:parseFloat(d[0]),lng:parseFloat(d[1]),zoom:parseInt(d[2],10)})}return a};q=x(),r.$on("$locationChangeSuccess",function(d){var e=d.currentScope,f=x();l(f)&&!n(f,c)&&a.extend(e[b],{lat:f.lat,lng:f.lng,zoom:f.zoom})})}r.$watch(b,function(b){if(!r.settingCenterFromLeaflet)return l(q)&&(a.copy(q,b),q=void 0),p(b)||b.autoDiscover===!0?b.autoDiscover===!0?(m(b.zoom)||c.setView([d.center.lat,d.center.lng],d.center.zoom),void(m(b.zoom)&&b.zoom>d.center.zoom?c.locate({setView:!0,maxZoom:b.zoom}):l(d.maxZoom)?c.locate({setView:!0,maxZoom:d.maxZoom}):c.locate({setView:!0}))):void(w&&n(b,c)||(r.settingCenterFromScope=!0,c.setView([b.lat,b.lng],b.zoom),j.notifyCenterChangedToBounds(r,c),f(function(){r.settingCenterFromScope=!1}))):void t.warn(s+" invalid 'center'")},!0),c.whenReady(function(){w=!0}),c.on("moveend",function(){k.resolve(),j.notifyCenterUrlHashChanged(r,c,h,e.search()),n(v,c)||r.settingCenterFromScope||(r.settingCenterFromLeaflet=!0,o(r,function(d){r.settingCenterFromScope||a.extend(d[b],{lat:c.getCenter().lat,lng:c.getCenter().lng,zoom:c.getZoom(),autoDiscover:!1}),j.notifyCenterChangedToBounds(r,c),f(function(){r.settingCenterFromLeaflet=!1})}))}),v.autoDiscover===!0&&c.on("locationerror",function(){t.warn(s+" The Geolocation API is unauthorized on this page."),p(v)?(c.setView([v.lat,v.lng],v.zoom),j.notifyCenterChangedToBounds(r,c)):(c.setView([d.center.lat,d.center.lng],d.center.zoom),j.notifyCenterChangedToBounds(r,c))})})}}}]}),b.forEach(function(b){a.module("ui-leaflet").directive(b,c[b])}),a.module("ui-leaflet").directive("controls",["leafletLogger","leafletHelpers","leafletControlHelpers",function(a,b,c){var d=a;return{restrict:"A",scope:!1,replace:!1,require:"?^leaflet",link:function(a,e,f,g){if(g){var h=c.createControl,i=c.isValidControlType,j=g.getLeafletScope(),k=b.isDefined,l=b.isArray,m={},n=b.errorHeader+" [Controls] ";a.$on("$destroy",function(){c.destroyMapLayersControl(a.mapId)}),g.getMap().then(function(a){j.$watchCollection("controls",function(b){for(var c in m)k(b[c])||(a.hasControl(m[c])&&a.removeControl(m[c]),delete m[c]);for(var e in b){var f,g=k(b[e].type)?b[e].type:e;if(!i(g))return void d.error(n+" Invalid control type: "+g+".");if("custom"!==g)f=h(g,b[e]),a.addControl(f),m[e]=f;else{var j=b[e];if(l(j))for(var o=0;o<j.length;o++){var p=j[o];a.addControl(p),m[e]=k(m[e])?m[e].concat([p]):[p]}else a.addControl(j),m[e]=j}}})})}}}}]),a.module("ui-leaflet").directive("decorations",["leafletLogger","leafletHelpers",function(b,c){var d=b;return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(b,e,f,g){function h(a){return l(a)&&l(a.coordinates)&&(k.isLoaded()||d.error("[AngularJS - Leaflet] The PolylineDecorator Plugin is not loaded.")),L.polylineDecorator(a.coordinates)}function i(a,b){if(l(a)&&l(b)&&l(b.coordinates)&&l(b.patterns))return a.setPaths(b.coordinates),a.setPatterns(b.patterns),a}var j=g.getLeafletScope(),k=c.PolylineDecoratorPlugin,l=c.isDefined,m={};g.getMap().then(function(b){j.$watch("decorations",function(c){for(var d in m)l(c[d])&&a.equals(c[d],m)||(b.removeLayer(m[d]),delete m[d]);for(var e in c){var f=c[e],g=h(f);l(g)&&(m[e]=g,b.addLayer(g),i(g,f))}},!0)})}}}]),a.module("ui-leaflet").directive("eventBroadcast",["leafletLogger","$rootScope","leafletHelpers","leafletMapEvents","leafletIterators",function(a,b,c,d,e){var f=a;return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(a,b,g,h){var i=c.isObject,j=c.isDefined,k=h.getLeafletScope(),l=k.eventBroadcast,m=d.getAvailableMapEvents(),n=d.addEvents;h.getMap().then(function(a){var b=[],c="broadcast";j(l.map)?i(l.map)?("emit"!==l.map.logic&&"broadcast"!==l.map.logic?f.warn("[AngularJS - Leaflet] Available event propagation logic are: 'emit' or 'broadcast'."):c=l.map.logic,i(l.map.enable)&&l.map.enable.length>=0?e.each(l.map.enable,function(a){b.indexOf(a)===-1&&m.indexOf(a)!==-1&&b.push(a)}):f.warn("[AngularJS - Leaflet] event-broadcast.map.enable must be an object check your model.")):f.warn("[AngularJS - Leaflet] event-broadcast.map must be an object check your model."):b=m,n(a,g.id,b,"eventName",k,c)})}}}]),a.module("ui-leaflet").directive("geojson",["$timeout","leafletLogger","leafletData","leafletHelpers","leafletWatchHelpers","leafletDirectiveControlsHelpers","leafletIterators","leafletGeoJsonEvents",function(b,c,d,e,f,g,h,i){var j=f.maybeWatch,k=e.watchOptions,l=g.extend,m=e,n=h,o={changeFromDirective:!1};return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(b,c,f,g){var h=e.isDefined,p=g.getLeafletScope(),q={},r=!1;g.getMap().then(function(b){var c;c=p.watchOptions&&p.watchOptions.geojson?p.watchOptions.geojson:k;var g=function(b,c){var d;return d=a.isFunction(b.onEachFeature)?b.onEachFeature:function(a,d){e.LabelPlugin.isLoaded()&&h(a.properties.description)&&d.bindLabel(a.properties.description),i.bindEvents(f.id,d,null,a,p,c,{resetStyleOnMouseout:b.resetStyleOnMouseout,mapId:f.id})}},s=m.isDefined(f.geojsonNested)&&m.isTruthy(f.geojsonNested),t=function(){if(q){var a=function(a){h(a)&&b.hasLayer(a)&&b.removeLayer(a)};return s?void n.each(q,function(b){a(b)}):void a(q)}},u=function(a,c){if(h(a)&&h(a.data)){var e=g(a,c);h(a.options)||m.modelChangeInDirective(o,"changeFromDirective",function(){a.options={style:a.style,filter:a.filter,onEachFeature:e,pointToLayer:a.pointToLayer}});var i=L.geoJson(a.data,a.options);c&&m.isString(c)?q[c]=i:q=i,i.addTo(b),r||(r=!0,d.setGeoJSON(q,f.id))}},v=function(a){if(t(),s){if(!a||!Object.keys(a).length)return;return void n.each(a,function(a,b){u(a,b)})}u(a)};l(f.id,"geojson",v,t),j(p,"geojson",c,function(a){o.changeFromDirective||v(a)})})}}}]),a.module("ui-leaflet").directive("layercontrol",["$filter","leafletLogger","leafletData","leafletHelpers",function(b,c,d,e){var f=c;return{restrict:"E",scope:{icons:"=?",autoHideOpacity:"=?",showGroups:"=?",title:"@",baseTitle:"@",overlaysTitle:"@"},replace:!0,transclude:!1,require:"^leaflet",controller:["$scope","$element","$sce",function(b,c,g){f.debug("[Angular Directive - Layers] layers",b,c);var h=e.safeApply,i=e.isDefined;a.extend(b,{baselayer:"",oldGroup:"",layerProperties:{},groupProperties:{},rangeIsSupported:e.rangeIsSupported(),changeBaseLayer:function(a,c){e.safeApply(b,function(c){c.baselayer=a,d.getMap().then(function(e){d.getLayers().then(function(d){if(!e.hasLayer(d.baselayers[a])){for(var f in c.layers.baselayers)c.layers.baselayers[f].icon=c.icons.unradio,e.hasLayer(d.baselayers[f])&&e.removeLayer(d.baselayers[f]);e.addLayer(d.baselayers[a]),c.layers.baselayers[a].icon=b.icons.radio}})})}),c.preventDefault()},moveLayer:function(a,c,d){var e=Object.keys(b.layers.baselayers).length;if(c>=1+e&&c<=b.overlaysArray.length+e){var f;for(var g in b.layers.overlays)if(b.layers.overlays[g].index===c){f=b.layers.overlays[g];break}f&&h(b,function(){f.index=a.index,a.index=c})}d.stopPropagation(),d.preventDefault()},initIndex:function(a,c){var d=Object.keys(b.layers.baselayers).length;a.index=i(a.index)?a.index:c+d+1},initGroup:function(a){b.groupProperties[a]=b.groupProperties[a]?b.groupProperties[a]:{}},toggleOpacity:function(a,c){if(c.visible){if(b.autoHideOpacity&&!b.layerProperties[c.name].opacityControl)for(var d in b.layerProperties)b.layerProperties[d].opacityControl=!1;b.layerProperties[c.name].opacityControl=!b.layerProperties[c.name].opacityControl}a.stopPropagation(),a.preventDefault()},toggleLegend:function(a){b.layerProperties[a.name].showLegend=!b.layerProperties[a.name].showLegend},showLegend:function(a){return a.legend&&b.layerProperties[a.name].showLegend},unsafeHTML:function(a){return g.trustAsHtml(a)},getOpacityIcon:function(a){return a.visible&&b.layerProperties[a.name].opacityControl?b.icons.close:b.icons.open},getGroupIcon:function(a){return a.visible?b.icons.check:b.icons.uncheck},changeGroupVisibility:function(a){if(i(b.groupProperties[a])){var c=b.groupProperties[a].visible;for(var d in b.layers.overlays){var e=b.layers.overlays[d];e.group===a&&(e.visible=c)}}}});var j=c.get(0);L.Browser.touch?L.DomEvent.on(j,"click",L.DomEvent.stopPropagation):(L.DomEvent.disableClickPropagation(j),L.DomEvent.on(j,"mousewheel",L.DomEvent.stopPropagation))}],template:'<div class="angular-leaflet-control-layers" ng-show="overlaysArray.length"><h4 ng-if="title">{{ title }}</h4><div class="lf-baselayers"><h5 class="lf-title" ng-if="baseTitle">{{ baseTitle }}</h5><div class="lf-row" ng-repeat="(key, layer) in baselayersArray"><label class="lf-icon-bl" ng-click="changeBaseLayer(key, $event)"><input class="leaflet-control-layers-selector" type="radio" name="lf-radio" ng-show="false" ng-checked="baselayer === key" ng-value="key" /> <i class="lf-icon lf-icon-radio" ng-class="layer.icon"></i><div class="lf-text">{{layer.name}}</div></label></div></div><div class="lf-overlays"><h5 class="lf-title" ng-if="overlaysTitle">{{ overlaysTitle }}</h5><div class="lf-container"><div class="lf-row" ng-repeat="layer in (o = (overlaysArray | orderBy:\'index\':order))" ng-init="initIndex(layer, $index)"><label class="lf-icon-ol-group" ng-if="showGroups &amp;&amp; layer.group &amp;&amp; layer.group != o[$index-1].group"><input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-change="changeGroupVisibility(layer.group)" ng-model="groupProperties[layer.group].visible"/> <i class="lf-icon lf-icon-check" ng-class="getGroupIcon(groupProperties[layer.group])"></i><div class="lf-text">{{ layer.group }}</div></label><label class="lf-icon-ol"><input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-model="layer.visible"/> <i class="lf-icon lf-icon-check" ng-class="layer.icon"></i><div class="lf-text">{{layer.name}}</div></label><div class="lf-icons"><i class="lf-icon lf-up" ng-class="icons.up" ng-click="moveLayer(layer, layer.index - orderNumber, $event)"></i> <i class="lf-icon lf-down" ng-class="icons.down" ng-click="moveLayer(layer, layer.index + orderNumber, $event)"></i> <i class="lf-icon lf-toggle-legend" ng-class="icons.toggleLegend" ng-if="layer.legend" ng-click="toggleLegend(layer)"></i> <i class="lf-icon lf-open" ng-class="getOpacityIcon(layer)" ng-click="toggleOpacity($event, layer)"></i></div><div class="lf-legend" ng-if="showLegend(layer)" ng-bind-html="unsafeHTML(layer.legend)"></div><div class="lf-opacity clearfix" ng-if="layer.visible &amp;&amp; layerProperties[layer.name].opacityControl"><label ng-if="rangeIsSupported" class="pull-left" style="width: 50%">0</label><label ng-if="rangeIsSupported" class="pull-left text-right" style="width: 50%">100</label><input ng-if="rangeIsSupported" class="clearfix" type="range" min="0" max="1" step="0.05" class="lf-opacity-control" ng-model="layerProperties[layer.name].layerOptions.opacity"/><h6 ng-if="!rangeIsSupported">Range is not supported in this browser</h6></div></div></div></div></div>',link:function(b,c,f,g){var h=e.isDefined,i=g.getLeafletScope(),j=i.layers;b.$watch("icons",function(){var c={uncheck:"fa fa-square-o",check:"fa fa-check-square-o",radio:"fa fa-dot-circle-o",unradio:"fa fa-circle-o",up:"fa fa-angle-up",down:"fa fa-angle-down",open:"fa fa-angle-double-down",close:"fa fa-angle-double-up",toggleLegend:"fa fa-pencil-square-o"};h(b.icons)?(a.extend(c,b.icons),a.extend(b.icons,c)):b.icons=c}),f.order=!h(f.order)||"normal"!==f.order&&"reverse"!==f.order?"normal":f.order,b.order="normal"===f.order,b.orderNumber="normal"===f.order?-1:1,b.layers=j,g.getMap().then(function(a){i.$watch("layers.baselayers",function(c){var e={};d.getLayers().then(function(d){var f;for(f in c){var g=c[f];g.icon=b.icons[a.hasLayer(d.baselayers[f])?"radio":"unradio"],e[f]=g}b.baselayersArray=e})}),i.$watch("layers.overlays",function(a){var c=[],e={};d.getLayers().then(function(){var d;for(d in a){var f=a[d];f.icon=b.icons[f.visible?"check":"uncheck"],c.push(f),h(b.layerProperties[f.name])||(h(f.layerOptions.opacity)&&(f.layerOptions.opacity=1),b.layerProperties[f.name]={opacityControl:!1,showLegend:!0,layerOptions:f.layerOptions}),h(f.group)&&(h(b.groupProperties[f.group])||(b.groupProperties[f.group]={visible:!1}),e[f.group]=h(e[f.group])?e[f.group]:{count:0,visibles:0},e[f.group].count++,f.visible&&e[f.group].visibles++)}for(d in e)b.groupProperties[d].visible=e[d].visibles===e[d].count;b.overlaysArray=c})},!0)})}}}]),a.module("ui-leaflet").directive("layers",["leafletLogger","$q","leafletData","leafletHelpers","leafletLayerHelpers","leafletControlHelpers",function(b,c,d,e,f,g){return{restrict:"A",scope:!1,replace:!1,require:"leaflet",controller:["$scope",function(a){a._leafletLayers=c.defer(),this.getLayers=function(){return a._leafletLayers.promise}}],link:function(b,c,h,i){var j=e.isDefined,k={},l=i.getLeafletScope(),m=l.layers,n=f.createLayer,o=f.safeAddLayer,p=f.safeRemoveLayer,q=f.changeOpacityListener,r=g.updateLayersControl,s=!1;b.$on("$destroy",function(){g.destroyMapLayersControl(b.mapId)}),i.getMap().then(function(c){b._leafletLayers.resolve(k),d.setLayers(k,h.id),k.baselayers={},k.overlays={};var e=h.id,f=!1;for(var g in m.baselayers){var i=n(m.baselayers[g]);j(i)?(k.baselayers[g]=i,m.baselayers[g].top===!0&&(o(c,k.baselayers[g]),f=!0)):delete m.baselayers[g]}!f&&Object.keys(k.baselayers).length>0&&o(c,k.baselayers[Object.keys(m.baselayers)[0]]);for(g in m.overlays){"cartodb"===m.overlays[g].type;var t=n(m.overlays[g]);j(t)?(k.overlays[g]=t,m.overlays[g].visible===!0&&o(c,k.overlays[g])):delete m.overlays[g]}l.$watch("layers.baselayers",function(b,d){if(a.equals(b,d))return s=r(c,e,s,b,m.overlays,k),!0;for(var f in k.baselayers)j(b[f])&&!b[f].doRefresh||(c.hasLayer(k.baselayers[f])&&c.removeLayer(k.baselayers[f]),delete k.baselayers[f],b[f]&&b[f].doRefresh&&(b[f].doRefresh=!1));for(var g in b)if(j(k.baselayers[g]))b[g].top!==!0||c.hasLayer(k.baselayers[g])?b[g].top===!1&&c.hasLayer(k.baselayers[g])&&c.removeLayer(k.baselayers[g]):o(c,k.baselayers[g]);else{var h=n(b[g]);j(h)&&(k.baselayers[g]=h,b[g].top===!0&&o(c,k.baselayers[g]))}var i=!1;for(var l in k.baselayers)if(c.hasLayer(k.baselayers[l])){i=!0;break}!i&&Object.keys(k.baselayers).length>0&&o(c,k.baselayers[Object.keys(k.baselayers)[0]]),s=r(c,e,s,b,m.overlays,k)},!0),l.$watch("layers.overlays",function(b,d){if(a.equals(b,d))return s=r(c,e,s,m.baselayers,b,k),!0;for(var f in k.overlays)if(!j(b[f])||b[f].doRefresh){if(c.hasLayer(k.overlays[f])){var g=j(b[f])?b[f].layerOptions:null;p(c,k.overlays[f],g)}delete k.overlays[f],b[f]&&b[f].doRefresh&&(b[f].doRefresh=!1)}for(var h in b){if(j(k.overlays[h])){b[h].visible&&!c.hasLayer(k.overlays[h])?o(c,k.overlays[h]):b[h].visible===!1&&c.hasLayer(k.overlays[h])&&p(c,k.overlays[h],b[h].layerOptions);var i=k.overlays[h];c.hasLayer(k.overlays[h])&&(b[h].layerOptions.opacity!==d[h].layerOptions.opacity&&(j(i.setOpacity)&&i.setOpacity(b[h].layerOptions.opacity),j(i.getLayers)&&j(i.eachLayer)&&i.eachLayer(q(b[h].layerOptions.opacity))),j(b[h].index)&&i.setZIndex&&b[h].index!==d[h].index&&i.setZIndex(b[h].index))}else{var l=n(b[h]);if(!j(l))continue;k.overlays[h]=l,b[h].visible===!0&&o(c,k.overlays[h]),j(b[h].index)&&k.overlays[h].setZIndex&&k.overlays[h].setZIndex(b[h].index)}b[h].visible&&c._loaded&&b[h].data&&"heatmap"===b[h].type&&(k.overlays[h].setData(b[h].data),k.overlays[h].update())}s=r(c,e,s,m.baselayers,b,k)},!0)})}}}]),a.module("ui-leaflet").directive("legend",["leafletLogger","$http","$timeout","leafletHelpers","leafletLegendHelpers",function(a,b,c,d,e){var f=a,g=d.errorHeader+" [Legend] ";return{restrict:"A",scope:!1,replace:!1,require:"leaflet",transclude:!1,link:function(a,b,c,h){var i,j,k,l,m=d.isArray,n=d.isString,o=d.isDefined,p=d.isFunction,q=h.getLeafletScope(),r=q.legend;q.$watch("legend",function(a){o(a)&&(i=a.legendClass?a.legendClass:"legend",j=a.position||"bottomright",l=a.type||"arcgis")},!0);var s=function(a,b,c){b&&b.layers&&b.layers.length>0&&(o(k)?e.updateLegend(k.getContainer(),b,l,c):(k=L.control({position:j}),k.onAdd=e.getOnAddLegend(b,i,l,c),k.addTo(a)),o(r.loadedData)&&p(r.loadedData)&&r.loadedData())};h.getMap().then(function(a){q.$watch("legend",function(b){return o(b)?o(b.url)||"arcgis"!==l||m(b.colors)&&m(b.labels)&&b.colors.length===b.labels.length?o(b.url)?void f.info(g+" loading legend service."):(o(k)&&(k.removeFrom(a),k=null),k=L.control({position:j}),"arcgis"===l&&(k.onAdd=e.getOnAddArrayLegend(b,i)),void k.addTo(a)):void f.warn(g+" legend.colors and legend.labels must be set."):void(o(k)&&(k.removeFrom(a),k=null))}),q.$watch("legend.url",function(b){if(o(b)){if(!m(b)&&!n(b))return void f.warn(g+" legend.url must be an array or string.");for(var d,h=n(b)?[b]:b,i=function(c,e){return function(i){o(i.data.error)?f.warn(g+"Error loadin legend from: "+e,i.data.error.message):d&&d.layers&&d.layers.length>0?d.layers=d.layers.concat(i.data.layers):d=i.data,c===h.length-1&&s(a,d,b)}},j=function(a){f.warn(g+" legend.url not loaded.",a)},k=0;k<h.length;k++)e.addLegendURL(c.id,{url:h[k],method:"GET"}).then(i(k)).catch(j)}}),q.$watch("legend.legendData",function(b){f.debug("legendData",b),!o(q.legend.url)&&o(b)&&s(a,b)},!0)})}}}]),a.module("ui-leaflet").directive("markers",["leafletLogger","$rootScope","$q","leafletData","leafletHelpers","leafletMapDefaults","leafletMarkersHelpers","leafletMarkerEvents","leafletIterators","leafletWatchHelpers","leafletDirectiveControlsHelpers",function(b,c,d,e,f,g,h,i,j,k,l){var m=f.isDefined,n=f.errorHeader,o=f,p=f.isString,q=h.addMarkerWatcher,r=h.updateMarker,s=h.listenMarkerEvents,t=h.addMarkerToGroup,u=h.createMarker,v=h.deleteMarker,w=h.getModelFromModels,x=h.getLayerModels,y=h.resetUnusedMarkerGroups,z=j,A=f.watchOptions,B=k.maybeWatch,C=l.extend,D=b,E={changeFromDirective:!1},F=function(a,b,c){if(Object.keys(a).length){if(c&&p(c)){if(!a[c]||!Object.keys(a[c]).length)return;return a[c][b]}return a[b]}},G=function(a,b,c,d){return d&&p(d)?(m(b[d])||(b[d]={}),b[d][c]=a):b[c]=a,a},H=function(a,b,c,d,e,f){if(!p(a))return D.error(n+" A layername must be a string"),!1;if(!m(b))return D.error(n+" You must add layers to the directive if the markers are going to use this functionality."),!1;if(!m(b.overlays)||!m(b.overlays[a]))return D.error(n+' A marker can only be added to a layer of type "group"'),!1;var g=b.overlays[a];return g instanceof L.LayerGroup||g instanceof L.FeatureGroup?(g.addLayer(d),null===e&&f.hasLayer(d)&&c.focus===!0&&d.openPopup(),!0):(D.error(n+' Adding a marker to an overlay needs a overlay of the type "group" or "featureGroup"'),!1)},I=function(a,b,c,d,e,f,g,h,j,k){z.each(b,function(b,l){if(!k[l]){if(l.search("-")!==-1)return void D.error('The marker can\'t use a "-" on his key name: "'+l+'".');var p=o.getObjectDotPath(j?[j,l]:[l]),v=F(f,l,j);o.modelChangeInDirective(E,"changeFromDirective",function(){if(m(v)){var k=w(c,l,j);r(b,k,v,p,g,e,d)}else{var x=u(b),y=(b?b.layer:void 0)||j;if(!m(x))return void D.error(n+" Received invalid data on the marker "+l+".");if(G(x,f,l,j),
+m(b.message)&&x.bindPopup(b.message,b.popupOptions),m(b.group)){var z=m(b.groupOption)?b.groupOption:null;t(x,b.group,z,d)}if(o.LabelPlugin.isLoaded()&&m(b.label)&&m(b.label.message)&&x.bindLabel(b.label.message,b.label.options),m(b)&&(m(b.layer)||m(j))){var A=H(y,e,b,x,h.individual.type,d);if(!A)return}else m(b.group)||(d.addLayer(x),null===h.individual.type&&b.focus===!0&&x.openPopup());null!==h.individual.type&&q(x,p,g,e,d,h.individual),s(x,b,g,h.individual.type,d),i.bindEvents(a,x,p,b,g,y)}})}})},J=function(b,c,d,e,f){var g,h,i=!1,j=!1,k=m(c);for(var l in d)i||(D.debug(n+"[markers] destroy: "),i=!0),k&&(h=b[l],g=c[l],j=e&&a.equals(h,g)),m(b)&&Object.keys(b).length&&m(b[l])&&Object.keys(b[l]).length&&!j||f&&o.isFunction(f)&&f(h,g,l)},K=function(a,b,c,d,e){J(a,b,c,!1,function(a,b,f){D.debug(n+"[marker] is deleting marker: "+f),v(c[f],d,e),delete c[f]})},M=function(a,b,c){var d={};return J(a,b,c,!0,function(a,b,c){D.debug(n+"[marker] is already rendered, marker: "+c),d[c]=a}),d};return{restrict:"A",scope:!1,replace:!1,require:["leaflet","?layers"],link:function(a,b,c,f){var g=f[0],h=g.getLeafletScope();g.getMap().then(function(b){var g,i={};g=m(f[1])?f[1].getLayers:function(){var a=d.defer();return a.resolve(),a.promise};var j;j=h.watchOptions&&h.watchOptions.markers?h.watchOptions.markers:A;var k=m(c.markersNested)&&o.isTruthy(c.markersNested);g().then(function(d){var f=function(a,c){return y(),k?void z.each(a,function(a,e){var f=x(c,e);K(a,f,i[e],b,d)}):void K(a,c,i,b,d)},g=function(a,e){f(a,e);var g=null;return k?void z.each(a,function(f,k){var l=x(e,k),m=x(a,k);g=M(m,l,i[k]),I(c.id,f,e,b,d,i,h,j,k,g)}):(g=M(a,e,i),void I(c.id,a,e,b,d,i,h,j,void 0,g))};C(c.id,"markers",g,f),e.setMarkers(i,c.id),B(h,"markers",j,function(a,b){E.changeFromDirective||g(a,b)}),a.$on("$destroy",function(){K(h.markers,{},i,b,d)})})})}}}]),a.module("ui-leaflet").directive("maxbounds",["leafletLogger","leafletMapDefaults","leafletBoundsHelpers","leafletHelpers",function(a,b,c,d){return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(a,b,e,f){var g=f.getLeafletScope(),h=c.isValidBounds,i=d.isNumber;f.getMap().then(function(a){g.$watch("maxbounds",function(b){if(!h(b))return void a.setMaxBounds();var d=c.createLeafletBounds(b);i(b.pad)&&(d=d.pad(b.pad)),a.setMaxBounds(d),e.center||e.lfCenter||a.fitBounds(d)})})}}}]),a.module("ui-leaflet").directive("paths",["leafletLogger","$q","leafletData","leafletMapDefaults","leafletHelpers","leafletPathsHelpers","leafletPathEvents","leafletWatchHelpers",function(a,b,c,d,e,f,g,h){var i=a;return{restrict:"A",scope:!1,replace:!1,require:["leaflet","?layers"],link:function(a,j,k,l){var m=l[0],n=e.isDefined,o=e.isString,p=m.getLeafletScope(),q=p.paths,r=f.createPath,s=g.bindPathEvents,t=f.setPathOptions,u=h.maybeWatch;m.getMap().then(function(a){var f,g=d.getDefaults(k.id);if(f=n(l[1])?l[1].getLayers:function(){var a=b.defer();return a.resolve(),a.promise},n(q)){var h,j={type:"watchCollection",individual:{type:"watchDeep"}};h=p.watchOptions&&p.watchOptions.paths?p.watchOptions.paths:j,f().then(function(b){var d={};c.setPaths(d,k.id);var f=function(c,d,e){var f='paths["'+d+'"]';u(p,f,e,function(d,e,f){if(!n(d)){if(n(e.layer))for(var g in b.overlays){var h=b.overlays[g];h.removeLayer(c)}return a.removeLayer(c),void f()}t(c,d.type,d)})},j=function(b){for(var c in d)n(b[c])||(a.removeLayer(d[c]),delete d[c])},l=function(c){j(c);for(var l in c)if(0!==l.search("\\$"))if(l.search("-")===-1){if(!n(d[l])){var m=c[l],q=r(l,c[l],g);if(n(q)&&n(m.message)&&q.bindPopup(m.message,m.popupOptions),e.LabelPlugin.isLoaded()&&n(m.label)&&n(m.label.message)&&q.bindLabel(m.label.message,m.label.options),n(m)&&n(m.layer)){if(!o(m.layer)){i.error("[AngularJS - Leaflet] A layername must be a string");continue}if(!n(b)){i.error("[AngularJS - Leaflet] You must add layers to the directive if the markers are going to use this functionality.");continue}if(!n(b.overlays)||!n(b.overlays[m.layer])){i.error('[AngularJS - Leaflet] A path can only be added to a layer of type "group"');continue}var u=b.overlays[m.layer];if(!(u instanceof L.LayerGroup||u instanceof L.FeatureGroup)){i.error('[AngularJS - Leaflet] Adding a path to an overlay needs a overlay of the type "group" or "featureGroup"');continue}d[l]=q,u.addLayer(q),null!==h.individual.type?f(q,l,h.individual):t(q,m.type,m)}else n(q)&&(d[l]=q,a.addLayer(q),null!==h.individual.type?f(q,l,h.individual):t(q,m.type,m));s(k.id,q,l,m,p)}}else i.error('[AngularJS - Leaflet] The path name "'+l+'" is not valid. It must not include "-" and a number.')};u(p,"paths",h,function(a){l(a)})})}})}}}]),a.module("ui-leaflet").directive("tiles",["leafletLogger","leafletData","leafletMapDefaults","leafletHelpers",function(b,c,d,e){var f=b;return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(b,g,h,i){var j=e.isDefined,k=i.getLeafletScope(),l=k.tiles;return j(l)&&j(l.url)?void i.getMap().then(function(b){var e,f=d.getDefaults(h.id);k.$watch("tiles",function(d){var g=f.tileLayerOptions,i=f.tileLayer;return!j(d.url)&&j(e)?void b.removeLayer(e):j(e)?j(d.url)&&j(d.options)&&!a.equals(d.options,g)?(b.removeLayer(e),g=f.tileLayerOptions,a.copy(d.options,g),i=d.url,e=L.tileLayer(i,g),e.addTo(b),void c.setTiles(e,h.id)):void(j(d.url)&&e.setUrl(d.url)):(j(d.options)&&a.copy(d.options,g),j(d.url)&&(i=d.url),e=L.tileLayer(i,g),e.addTo(b),void c.setTiles(e,h.id))},!0)}):void f.warn("[AngularJS - Leaflet] The 'tiles' definition doesn't have the 'url' property.")}}}]),a.module("ui-leaflet").directive("watchOptions",["$log","$rootScope","$q","leafletData","leafletHelpers",function(b,c,d,e,f){var g=f.isDefined,h=f.errorHeader,i=f.isObject,j=b;return{restrict:"A",scope:!1,replace:!1,require:["leaflet"],link:function(b,c,d,e){var f=e[0],k=f.getLeafletScope(),l=function(a){return"watch"===a||"watchCollection"===a||"watchDeep"===a||null===a};g(k.watchOptions)&&i(k.watchOptions)&&a.forEach(["markers","geojson","paths"],function(a){g(k.watchOptions[a])&&(l(k.watchOptions[a].type)||j.error(h+" watchOptions."+a+".type is not a valid type."),g(k.watchOptions[a].individual)?l(k.watchOptions[a].individual.type)||j.error(h+" watchOptions."+a+".individual.type is not a valid type."):j.error(h+" watchOptions."+a+".type.individual must be defined."))})}}}]),a.module("ui-leaflet").factory("leafletEventsHelpersFactory",["$rootScope","$q","leafletLogger","leafletHelpers",function(b,c,d,e){var f=e.safeApply,g=e.isDefined,h=e.isObject,i=e.isArray,j=e.errorHeader,k=d,l=function(a,b){this.rootBroadcastName=a,k.debug("leafletEventsHelpersFactory: lObjectType: "+b+"rootBroadcastName: "+a),this.lObjectType=b};return l.prototype.getAvailableEvents=function(){return[]},l.prototype.genDispatchEvent=function(a,b,c,d,e,f,g,h,i){var j=this;return a=a||"",a&&(a="."+a),function(l){var m=j.rootBroadcastName+a+"."+b;k.debug(m),j.fire(d,m,c,l,l.target||e,g,f,h,i)}},l.prototype.fire=function(c,d,e,h,i,j,k,l,m){f(c,function(){var f={leafletEvent:h,leafletObject:i,modelName:k,model:j};g(l)&&a.extend(f,{layerName:l}),"emit"===e?c.$emit(d,f):b.$broadcast(d,f)})},l.prototype.bindEvents=function(a,b,c,d,e,f,l){var m=[],n="emit",o=this;if(g(e.eventBroadcast))if(h(e.eventBroadcast))if(g(e.eventBroadcast[o.lObjectType]))if(h(e.eventBroadcast[o.lObjectType])){g(e.eventBroadcast[this.lObjectType].logic)&&"emit"!==e.eventBroadcast[o.lObjectType].logic&&"broadcast"!==e.eventBroadcast[o.lObjectType].logic&&k.warn(j+"Available event propagation logic are: 'emit' or 'broadcast'.");var p=!1,q=!1;g(e.eventBroadcast[o.lObjectType].enable)&&i(e.eventBroadcast[o.lObjectType].enable)&&(p=!0),g(e.eventBroadcast[o.lObjectType].disable)&&i(e.eventBroadcast[o.lObjectType].disable)&&(q=!0),p&&q?k.warn(j+"can not enable and disable events at the same time"):p||q?p?e.eventBroadcast[this.lObjectType].enable.forEach(function(a){m.indexOf(a)!==-1?k.warn(j+"This event "+a+" is already enabled"):o.getAvailableEvents().indexOf(a)===-1?k.warn(j+"This event "+a+" does not exist"):m.push(a)}):(m=this.getAvailableEvents(),e.eventBroadcast[o.lObjectType].disable.forEach(function(a){var b=m.indexOf(a);b===-1?k.warn(j+"This event "+a+" does not exist or has been already disabled"):m.splice(b,1)})):k.warn(j+"must enable or disable events")}else k.warn(j+"event-broadcast."+[o.lObjectType]+" must be an object check your model.");else m=this.getAvailableEvents();else k.error(j+"event-broadcast must be an object check your model.");else m=this.getAvailableEvents();return m.forEach(function(g){b.on(g,o.genDispatchEvent(a,g,n,e,b,c,d,f,l))}),n},l}]).service("leafletEventsHelpers",["leafletEventsHelpersFactory",function(a){return new a}]),a.module("ui-leaflet").factory("leafletGeoJsonEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpersFactory","leafletData",function(a,b,c,d,e,f){var g=d.safeApply,h=e,i=function(){h.call(this,"leafletDirectiveGeoJson","geojson")};return i.prototype=new h,i.prototype.genDispatchEvent=function(b,c,d,e,i,j,k,l,m){var n=h.prototype.genDispatchEvent.call(this,b,c,d,e,i,j,k,l),o=this;return function(b){"mouseout"===c&&(m.resetStyleOnMouseout&&f.getGeoJSON(m.mapId).then(function(a){var c=l?a[l]:a;c.resetStyle(b.target)}),g(e,function(){a.$broadcast(o.rootBroadcastName+".mouseout",b)})),n(b)}},i.prototype.getAvailableEvents=function(){return["click","dblclick","mouseover","mouseout"]},new i}]),a.module("ui-leaflet").factory("leafletLabelEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpersFactory",function(a,b,c,d,e){var f=d,g=e,h=function(){g.call(this,"leafletDirectiveLabel","markers")};return h.prototype=new g,h.prototype.genDispatchEvent=function(a,b,c,d,e,f,h,i){var j=f.replace("markers.","");return g.prototype.genDispatchEvent.call(this,a,b,c,d,e,j,h,i)},h.prototype.getAvailableEvents=function(){return["click","dblclick","mousedown","mouseover","mouseout","contextmenu"]},h.prototype.genEvents=function(a,b,c,d,e,g,h,i){var j=this,k=this.getAvailableEvents(),l=f.getObjectArrayPath("markers."+g);k.forEach(function(b){e.label.on(b,j.genDispatchEvent(a,b,c,d,e.label,l,h,i))})},h.prototype.bindEvents=function(a,b,c,d,e,f){},new h}]),a.module("ui-leaflet").factory("leafletMapEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpers","leafletIterators",function(a,b,c,d,e,f){var g=d.isDefined,h=e.fire,i=function(){return["click","dblclick","mousedown","mouseup","mouseover","mouseout","mousemove","contextmenu","focus","blur","preclick","load","unload","viewreset","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoomanim","zoomend","zoomlevelschange","resize","autopanstart","layeradd","layerremove","baselayerchange","overlayadd","overlayremove","locationfound","locationerror","popupopen","popupclose","draw:created","draw:edited","draw:deleted","draw:drawstart","draw:drawstop","draw:editstart","draw:editstop","draw:deletestart","draw:deletestop"]},j=function(a,b,d,e){return e&&(e+="."),function(f){var g="leafletDirectiveMap."+e+b;c.debug(g),h(a,g,d,f,f.target,a)}},k=function(a){a.$broadcast("boundsChanged")},l=function(a,b,c,d){if(g(c.urlHashCenter)){var e=b.getCenter(),f=e.lat.toFixed(4)+":"+e.lng.toFixed(4)+":"+b.getZoom();g(d.c)&&d.c===f||a.$emit("centerUrlHash",f)}},m=function(a,b,c,d,e,g){f.each(c,function(c){var f={};f[d]=c,b||(b=a._container.id||""),a.on(c,j(e,c,g,b),f)})};return{getAvailableMapEvents:i,genDispatchMapEvent:j,notifyCenterChangedToBounds:k,notifyCenterUrlHashChanged:l,addEvents:m}}]),a.module("ui-leaflet").factory("leafletMarkerEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpersFactory","leafletLabelEvents",function(a,b,c,d,e,f){var g=d.safeApply,h=d.isDefined,i=d,j=f,k=e,l=function(){k.call(this,"leafletDirectiveMarker","markers")};return l.prototype=new k,l.prototype.genDispatchEvent=function(b,c,d,e,f,h,i,j){var l=k.prototype.genDispatchEvent.call(this,b,c,d,e,f,h,i,j);return function(b){"click"===c?g(e,function(){a.$broadcast("leafletDirectiveMarkersClick",h)}):"dragend"===c&&(g(e,function(){i.lat=f.getLatLng().lat,i.lng=f.getLatLng().lng}),i.message&&i.focus===!0&&f.openPopup()),l(b)}},l.prototype.getAvailableEvents=function(){return["click","dblclick","mousedown","mouseover","mouseout","contextmenu","dragstart","drag","dragend","move","remove","popupopen","popupclose","touchend","touchstart","touchmove","touchcancel","touchleave"]},l.prototype.bindEvents=function(a,b,c,d,e,f){var g=k.prototype.bindEvents.call(this,a,b,c,d,e,f);i.LabelPlugin.isLoaded()&&h(b.label)&&j.genEvents(a,c,g,e,b,d,f)},new l}]);var d="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol?"symbol":typeof a};a.module("ui-leaflet").factory("leafletPathEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletLabelEvents","leafletEventsHelpers",function(a,b,c,e,f,g){var h=e.isDefined,i=e.isObject,j=e,k=e.errorHeader,l=f,m=g.fire,n=c,o=function(a,b,c,d,e,f,g,h){return a=a||"",a&&(a="."+a),function(i){var j="leafletDirectivePath"+a+"."+b;n.debug(j),m(d,j,c,i,i.target||e,g,f,h)}},p=function(a,b,c,e,f){var g,m,p=[],r="broadcast";if(h(f.eventBroadcast))if(i(f.eventBroadcast))if(h(f.eventBroadcast.path))if(i(f.eventBroadcast.paths))n.warn(k+"event-broadcast.path must be an object check your model.");else{void 0!==f.eventBroadcast.path.logic&&null!==f.eventBroadcast.path.logic&&("emit"!==f.eventBroadcast.path.logic&&"broadcast"!==f.eventBroadcast.path.logic?n.warn(k+"Available event propagation logic are: 'emit' or 'broadcast'."):"emit"===f.eventBroadcast.path.logic&&(r="emit"));var s=!1,t=!1;if(void 0!==f.eventBroadcast.path.enable&&null!==f.eventBroadcast.path.enable&&"object"===d(f.eventBroadcast.path.enable)&&(s=!0),void 0!==f.eventBroadcast.path.disable&&null!==f.eventBroadcast.path.disable&&"object"===d(f.eventBroadcast.path.disable)&&(t=!0),s&&t)n.warn(k+"can not enable and disable events at the same time");else if(s||t)if(s)for(g=0;g<f.eventBroadcast.path.enable.length;g++)m=f.eventBroadcast.path.enable[g],p.indexOf(m)!==-1?n.warn(k+"This event "+m+" is already enabled"):q().indexOf(m)===-1?n.warn(k+"This event "+m+" does not exist"):p.push(m);else for(p=q(),g=0;g<f.eventBroadcast.path.disable.length;g++){m=f.eventBroadcast.path.disable[g];var u=p.indexOf(m);u===-1?n.warn(k+"This event "+m+" does not exist or has been already disabled"):p.splice(u,1)}else n.warn(k+"must enable or disable events")}else p=q();else n.error(k+"event-broadcast must be an object check your model.");else p=q();for(g=0;g<p.length;g++)m=p[g],b.on(m,o(a,m,r,f,p,c));j.LabelPlugin.isLoaded()&&h(b.label)&&l.genEvents(a,c,r,f,b,e)},q=function(){return["click","dblclick","mousedown","mouseover","mouseout","contextmenu","add","remove","popupopen","popupclose"]};return{getAvailablePathEvents:q,bindPathEvents:p}}])}(angular);
\ No newline at end of file
Index: bower_components/ui-leaflet/grunt/babel.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/babel.js	(revision )
+++ bower_components/ui-leaflet/grunt/babel.js	(revision )
@@ -0,0 +1,20 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        options: {
+            sourceMap: false,
+            compact: false,
+            presets: ['es2015']
+        },
+        dist: {
+            files: [{
+                expand: true,
+                cwd: 'src',
+                src: ['**/*.js'],
+                dest: 'dist/src',
+                ext: '.js'
+            }]
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/conventionalChangelog.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/conventionalChangelog.js	(revision )
+++ bower_components/ui-leaflet/grunt/conventionalChangelog.js	(revision )
@@ -0,0 +1,33 @@
+'use strict';
+var _pkg = require('../package.json');
+var argv = require('yargs').argv;
+
+/*
+ _pkg.nextVersion only works for patch updates
+
+ Using changelog in the workflow is not really recommended right now as changelog is not really able to be modified until
+ a new tag is released.
+
+ Using Yargs as a workaround which grunt should be used in this way:
+
+ `grunt changelog --ui_leaflet_ver SOME_TAG_NUMBER`
+ */
+
+module.exports = function (grunt, options) {
+    console.log('version:', argv.ui_leaflet_ver || _pkg.version);
+    return {
+        options: {
+            changelogOpts: {
+                // conventional-changelog options go here
+                preset: 'angular',
+                releaseCount: 0
+            },
+            context: {
+                currentTag: 'v' + (argv.ui_leaflet_ver || _pkg.version)
+            }
+        },
+        release: {
+            src: 'CHANGELOG.md'
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/bower.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/bower.js	(revision )
+++ bower_components/ui-leaflet/grunt/bower.js	(revision )
@@ -0,0 +1,12 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        install: {
+            //  options: {
+            //      targetDir: './bower_components',
+            //      cleanup: true
+            //  }
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/connect.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/connect.js	(revision )
+++ bower_components/ui-leaflet/grunt/connect.js	(revision )
@@ -0,0 +1,35 @@
+'use strict';
+var getAvailPort = require('./utils/getAvailPort');
+var port = getAvailPort(8888);
+
+module.exports = function (grunt, options) {
+    return {
+        options: {
+            base: ''
+        },
+        webserver: {
+            options: {
+                port: port,
+                keepalive: true
+            }
+        },
+        devserver: {
+            options: {
+                port: 8888
+            }
+        },
+        testserver: {
+            options: {
+                port: 9999
+            }
+        },
+        coverage: {
+            options: {
+                base: 'coverage/',
+                directory: 'coverage/',
+                port: 5555,
+                keepalive: true
+            }
+        }
+    };
+};
Index: home/partial/dataMap/dataMap.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- home/partial/dataMap/dataMap.html	(revision 25eea5333ab01c6d75fbbdd60df446ad600e0d90)
+++ home/partial/dataMap/dataMap.html	(revision )
@@ -4,14 +4,14 @@
     </div>
     <br>
     <ul class="nav nav-tabs">
-        <li class="active"><a data-toggle="tab" href="#charging_stations">Charging Stations</a></li>
+        <li id="CS"class="active"><a data-toggle="tab" href="#charging_stations">Charging Stations</a></li>
         <li><a data-toggle="tab" href="#realtime_demand">Realtime Demand</a></li>
         <li><a data-toggle="tab" href="#emissions_utilities">Emissions and Utilities</a></li>
     </ul>
 
     <div class="tab-content">
         <div id="charging_stations" class="tab-pane fade in active">
-            <div class="col-md-8">
+            <div class="col-md-8 hidden">
                 <div class="col-md-3">
                     <input type="checkbox" ng-click="changeDataPointModel('commute_routes')" ng-model="mapCheckBoxes.commute_routes">&nbsp;Commute Routes
                 </div>
@@ -37,12 +37,12 @@
                     <input type="checkbox" ng-click="changeDataPointModel('sugg_char_station_location')" ng-model="mapCheckBoxes.sugg_char_station_location">&nbsp; Suggested Charging Station Locations
                 </div>
             </div>
-            <div class="col-md-4">
+            <div class="col-md-4 hidden">
                 <ul class="nav nav-tabs" role="tablist">
                     <li role="presentation"><a href="#realtime" aria-controls="#realtime" role="tab" data-toggle="tab">Realtime</a></li>
                     <li role="presentation"><a href="#future" aria-controls="#future" role="tab" data-toggle="tab">Future</a></li>
                 </ul>
-                <div class="tab-content">
+                <div class="tab-content ">
                     <div role="tabpanel" class="tab-pane fade in active" id="realtime">
                         <div class="col-md-5">
                             <input type="radio" value=""> &nbsp; Work Week
@@ -84,11 +84,16 @@
                     </div>
                 </div>
             </div>
-            <div class="col-md-12" style="margin-top: 10px;">
+            <div id="map_container" class="col-md-12" style="margin-top: 10px;">
                 <div id="mapid" style="height: 500px;"></div>
-                <!--<leaflet id="map-marker" markers="markers" center="osloCenter"></leaflet>-->
-
-                <!--<img src="../../../assets/images/u2.jpg" width="100%">-->
+            </div>
+            <div class="row">
+                <ul class="legend">
+                    <li><span class="gas_station_locations"></span> Gas Station Locations</li>
+                    <li><span class="awesome"></span> EV Station Locations</li>
+                    <!--<li><span class="kindaawesome"></span> Kinda Awesome</li>-->
+                    <!--<li><span class="notawesome"></span> Not Awesome</li>-->
+                </ul>
             </div>
         </div>
         <div id="realtime_demand" class="tab-pane fade">
Index: bower_components/ui-leaflet/grunt/watch.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/watch.js	(revision )
+++ bower_components/ui-leaflet/grunt/watch.js	(revision )
@@ -0,0 +1,50 @@
+'use strict';
+var getAvailPort = require('./utils/getAvailPort');
+var port = getAvailPort(7777);
+
+var _files = ['src/**/*.js'];
+var _testFiles = ['test/unit/**.js', 'test/unit/**.coffee',
+    'test/e2e/**.js', 'test/unit/**/**.js', 'test/unit/**/**.coffee', 'test/e2e/**/**.js'];
+
+module.exports = function (grunt, options) {
+    return {
+        // NOT WORTH THE PINTA when having multiple watches
+        // options: {
+        //     livereload: port
+        // },
+        fast: {
+            files: _files,
+            tasks: [
+                'fastbuild',
+                'uglify',
+                'concat:license'
+            ]
+        },
+        source: {
+            files: _files,
+            tasks: [
+                'fastbuild',
+                'uglify',
+                'testunit',
+                'concat:license'
+            ]
+        },
+        unit: {
+            files: _testFiles,
+            tasks: [
+                'fastbuild',
+                'karma'
+            ]
+        },
+        examples: {
+            files: ['examples/*.html'],
+            tasks: [
+                'examples'
+            ]
+        },
+        website: {
+            files: ['website/src/js/app.js', 'website/src/js/**/*.js'],
+            tasks: ['jshint', 'concat:website', 'uglify'] //'ngmin'
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/utils/banner.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/utils/banner.js	(revision )
+++ bower_components/ui-leaflet/grunt/utils/banner.js	(revision )
@@ -0,0 +1,6 @@
+module.exports =
+    '/*!\n' +
+    '*  <%= pkg.name %> <%= pkgFunction().version %> <%= grunt.template.today(\"yyyy-mm-dd\") %>\n' +
+    '*  <%= pkg.description %>\n' +
+    '*  <%= pkg.repository.type %>: <%= pkg.repository.url %>\n' +
+    '*/\n'
Index: bower_components/ui-leaflet/grunt/bump.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/bump.js	(revision )
+++ bower_components/ui-leaflet/grunt/bump.js	(revision )
@@ -0,0 +1,30 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        options: {
+            files: ['package.json', 'bower.json'],
+            updateConfigs: [],
+            commit: true,
+            commitMessage: 'Release v%VERSION%',
+            commitFiles: [
+                'CHANGELOG.md',
+                'package.json',
+                'bower.json',
+                'dist/<%= pkg.name %>.js',
+                'dist/<%= pkg.name %>.min.js',
+                'dist/<%= pkg.name %>.min.no-header.js',
+                'dist/<%= pkg.name %>.js',
+                'dist/<%= pkg.name %>_dev_mapped.js',
+                'dist/<%= pkg.name %>_dev_mapped.js.map',
+                'dist/architecture/**/*'
+            ],
+            createTag: true,
+            tagName: 'v%VERSION%',
+            tagMessage: 'Version %VERSION%',
+            push: false,
+            pushTo: 'origin',
+            gitDescribeOptions: '--tags --always --abbrev=1 --dirty=-d'
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/angular_architecture_graph.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/angular_architecture_graph.js	(revision )
+++ bower_components/ui-leaflet/grunt/angular_architecture_graph.js	(revision )
@@ -0,0 +1,11 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        diagram: {
+            files: {
+                "dist/architecture": ["dist/<%= pkg.name %>.js"]
+            }
+        }
+    };
+};
Index: bower_components/ui-leaflet/index.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/index.html	(revision )
+++ bower_components/ui-leaflet/index.html	(revision )
@@ -0,0 +1,66 @@
+<!DOCTYPE html>
+<html ng-app="mainPage" lang="en">
+<head>
+    <meta charset="UTF-8">
+    <!--<meta name="fragment" content="!">-->
+    <meta name="keywords" content="angularjs,leaflet,openstreetmap,javascript,directive,plugin,google maps">
+    <meta name="description" content="Leaflet directive for AngularJS">
+    <title>Leaflet directive for AngularJS</title>
+    <link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css">
+    <link rel="stylesheet" href="bower_components/leaflet/dist/leaflet.css" />
+    <link rel="stylesheet" href="bower_components/highlightjs/styles/github.css" />
+    <link rel="stylesheet" type="text/css" href="http://cloud.github.com/downloads/lafeber/world-flags-sprite/flags32.css" />
+    <link rel="stylesheet" href="website/css/style.css" />
+</head>
+
+<body ng-cloak ng-controller="MainController">
+    <div class="container" ng-controller="HeaderController">
+        <header class="navbar navbar-default" role="navigation">
+            <div class="navbar-header">
+                <a href="#!/" class="navbar-brand">ui-leaflet</a>
+            </div>
+            <ul class="nav navbar-nav navbar-right">
+                <li ng-class="{ active: activeTab == 'getting-started' || activeTab == '' }"><a href="#!/getting-started">Getting started</a></li>
+                <li ng-class="{ active: activeTab == 'examples' }"><a ng-href="#!/examples/simple-map">Examples</a></li>
+                <li ng-class="{ active: activeTab == 'howto-extend' }"><a ng-href="#!/howto-extend">How to extend</a></li>
+                <li><a href="http://github.com/angular-ui/ui-leaflet">Github repository</a></li>
+            </ul>
+        </header>
+        <div class="banner">
+            <a class="forkme" href="https://github.com/angular-ui/ui-leaflet" rel="external">
+                <img src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub">
+            </a>
+            <leaflet center="center" defaults="defaults" events="events" id="header"></leaflet>
+        </div>
+        <div class="bottom-banner">
+            <div class="container">
+                Simple to use directive for easy embedding and interacting with a map managed with the <a href="http://leafletjs.com/">leaflet map library</a> on an <a href="http://angularjs.org">AngularJS</a> application.
+            </div>
+        </div>
+    </div>
+
+    <div class="container content">
+        <ng-view></ng-view>
+    </div>
+
+    <div class="container footer">
+        <footer role="contentinfo">
+            <p class="pull-right">Page built with <a href="http://leafletjs.com">LeafletJS</a>, <a href="http://angularjs.org/">AngularJS</a> and <a href="http://getbootstrap.com/">Bootstrap</a></p>
+        </footer>
+    </div>
+
+    <script src="https://maps.googleapis.com/maps/api/js?libraries=geometry&sensor=false"></script>
+    <script src="bower_components/jquery/dist/jquery.min.js"></script>
+    <script src="bower_components/leaflet/dist/leaflet.js"></script>
+    <script src="bower_components/leaflet-plugins/layer/tile/Google.js"></script>
+    <script src="bower_components/highlightjs/highlight.pack.js"></script>
+    <script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
+    <script src="bower_components/angular/angular.js"></script>
+    <script src="bower_components/angular-route/angular-route.min.js"></script>
+    <script src="bower_components/angular-highlightjs/angular-highlightjs.min.js"></script>
+    <script src="bower_components/angular-simple-logger/dist/angular-simple-logger.js"></script>
+    <script src="dist/ui-leaflet.js"></script>
+    <script src="website/dist/js/ui-leaflet-webpage.js"></script>
+</body>
+
+</html>
Index: bower_components/ui-leaflet/dist/ui-leaflet.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/dist/ui-leaflet.js	(revision )
+++ bower_components/ui-leaflet/dist/ui-leaflet.js	(revision )
@@ -0,0 +1,5189 @@
+/*!
+*  ui-leaflet 2.0.0 2016-10-04
+*  ui-leaflet - An AngularJS directive to easily interact with Leaflet maps
+*  git: https://github.com/angular-ui/ui-leaflet
+*/
+(function(angular){
+'use strict';
+'use strict';
+
+angular.module('ui-leaflet', ['nemLogging']).directive('leaflet', ["$q", "leafletData", "leafletMapDefaults", "leafletHelpers", "leafletMapEvents", function ($q, leafletData, leafletMapDefaults, leafletHelpers, leafletMapEvents) {
+    return {
+        restrict: "EA",
+        replace: true,
+        scope: {
+            center: '=',
+            lfCenter: '=',
+            defaults: '=',
+            maxbounds: '=',
+            bounds: '=',
+            markers: '=',
+            legend: '=',
+            geojson: '=',
+            paths: '=',
+            tiles: '=',
+            layers: '=',
+            controls: '=',
+            decorations: '=',
+            eventBroadcast: '=',
+            watchOptions: '=',
+            id: '@'
+        },
+        transclude: true,
+        template: '<div class="angular-leaflet-map"><div ng-transclude></div></div>',
+        controller: ["$scope", function controller($scope) {
+            this._leafletMap = $q.defer();
+            this.getMap = function () {
+                return this._leafletMap.promise;
+            };
+
+            this.getLeafletScope = function () {
+                return $scope;
+            };
+        }],
+
+        link: function link(scope, element, attrs, ctrl) {
+            var isDefined = leafletHelpers.isDefined,
+                defaults = leafletMapDefaults.setDefaults(scope.defaults, attrs.id),
+                mapEvents = leafletMapEvents.getAvailableMapEvents(),
+                addEvents = leafletMapEvents.addEvents;
+
+            scope.mapId = attrs.id;
+            leafletData.setDirectiveControls({}, attrs.id);
+
+            // Set width and height utility functions
+            function updateWidth() {
+                if (isNaN(attrs.width)) {
+                    element.css('width', attrs.width);
+                } else {
+                    element.css('width', attrs.width + 'px');
+                }
+            }
+
+            function updateHeight() {
+                if (isNaN(attrs.height)) {
+                    element.css('height', attrs.height);
+                } else {
+                    element.css('height', attrs.height + 'px');
+                }
+            }
+
+            // Create the Leaflet Map Object with the options
+            var map = new L.Map(element[0], leafletMapDefaults.getMapCreationDefaults(attrs.id));
+            ctrl._leafletMap.resolve(map);
+
+            // If the width attribute defined update css
+            // Then watch if bound property changes and update css
+            if (isDefined(attrs.width)) {
+                updateWidth();
+
+                scope.$watch(function () {
+                    return element[0].getAttribute('width');
+                }, function () {
+                    updateWidth();
+                    map.invalidateSize();
+                });
+            }
+
+            // If the height attribute defined update css
+            // Then watch if bound property changes and update css
+            if (isDefined(attrs.height)) {
+                updateHeight();
+
+                scope.$watch(function () {
+                    return element[0].getAttribute('height');
+                }, function () {
+                    updateHeight();
+                    map.invalidateSize();
+                });
+            }
+
+            if (!isDefined(attrs.center) && !isDefined(attrs.lfCenter)) {
+                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+            }
+
+            // If no layers nor tiles defined, set the default tileLayer
+            if (!isDefined(attrs.tiles) && !isDefined(attrs.layers)) {
+                var tileLayerObj = L.tileLayer(defaults.tileLayer, defaults.tileLayerOptions);
+                tileLayerObj.addTo(map);
+                leafletData.setTiles(tileLayerObj, attrs.id);
+            }
+
+            // Set zoom control configuration
+            if (isDefined(map.zoomControl) && isDefined(defaults.zoomControlPosition)) {
+                map.zoomControl.setPosition(defaults.zoomControlPosition);
+            }
+
+            if (isDefined(map.zoomControl) && defaults.zoomControl === false) {
+                map.zoomControl.removeFrom(map);
+            }
+
+            if (isDefined(map.zoomsliderControl) && isDefined(defaults.zoomsliderControl) && defaults.zoomsliderControl === false) {
+                map.zoomsliderControl.removeFrom(map);
+            }
+
+            // if no event-broadcast attribute, all events are broadcasted
+            if (!isDefined(attrs.eventBroadcast)) {
+                var logic = "broadcast";
+                addEvents(map, attrs.id, mapEvents, "eventName", scope, logic);
+            }
+
+            // Resolve the map object to the promises
+            map.whenReady(function () {
+                leafletData.setMap(map, attrs.id);
+            });
+
+            scope.$on('$destroy', function () {
+                leafletMapDefaults.reset();
+                map.remove();
+                leafletData.unresolveMap(attrs.id);
+            });
+
+            //Handle request to invalidate the map size
+            //Up scope using $scope.$emit('invalidateSize')
+            //Down scope using $scope.$broadcast('invalidateSize')
+            scope.$on('invalidateSize', function () {
+                map.invalidateSize();
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+(function () {
+    angular.module('ui-leaflet').factory('eventManager', [function () {
+        var EventManager = function EventManager() {
+            this.listeners = {};
+        };
+
+        EventManager.prototype = {
+            addEventListener: function addEventListener(type, callback, scope) {
+                var args = [];
+                var numOfArgs = arguments.length;
+                for (var i = 0; i < numOfArgs; i++) {
+                    args.push(arguments[i]);
+                }
+                args = args.length > 3 ? args.splice(3, args.length - 1) : [];
+                if (typeof this.listeners[type] !== "undefined") {
+                    this.listeners[type].push({ scope: scope, callback: callback, args: args });
+                } else {
+                    this.listeners[type] = [{ scope: scope, callback: callback, args: args }];
+                }
+            },
+            removeEventListener: function removeEventListener(type, callback, scope) {
+                if (typeof this.listeners[type] !== "undefined") {
+                    var numOfCallbacks = this.listeners[type].length;
+                    var newArray = [];
+                    for (var i = 0; i < numOfCallbacks; i++) {
+                        var listener = this.listeners[type][i];
+                        if (listener.scope === scope && listener.callback === callback) {} else {
+                            newArray.push(listener);
+                        }
+                    }
+                    this.listeners[type] = newArray;
+                }
+            },
+            hasEventListener: function hasEventListener(type, callback, scope) {
+                if (typeof this.listeners[type] !== "undefined") {
+                    var numOfCallbacks = this.listeners[type].length;
+                    if (callback === undefined && scope === undefined) {
+                        return numOfCallbacks > 0;
+                    }
+                    for (var i = 0; i < numOfCallbacks; i++) {
+                        var listener = this.listeners[type][i];
+                        if ((scope ? listener.scope === scope : true) && listener.callback === callback) {
+                            return true;
+                        }
+                    }
+                }
+                return false;
+            },
+            dispatch: function dispatch(type, target) {
+                var numOfListeners = 0;
+                var event = {
+                    type: type,
+                    target: target
+                };
+                var args = [];
+                var numOfArgs = arguments.length;
+                for (var i = 0; i < numOfArgs; i++) {
+                    args.push(arguments[i]);
+                }
+                args = args.length > 2 ? args.splice(2, args.length - 1) : [];
+                args = [event].concat(args);
+                if (typeof this.listeners[type] !== "undefined") {
+                    var numOfCallbacks = this.listeners[type].length;
+                    for (var x = 0; x < numOfCallbacks; x++) {
+                        var listener = this.listeners[type][x];
+                        if (listener && listener.callback) {
+                            var concatArgs = args.concat(listener.args);
+                            listener.callback.apply(listener.scope, concatArgs);
+                            numOfListeners += 1;
+                        }
+                    }
+                }
+            },
+            getEvents: function getEvents() {
+                var str = "";
+                for (var type in this.listeners) {
+                    var numOfCallbacks = this.listeners[type].length;
+                    for (var i = 0; i < numOfCallbacks; i++) {
+                        var listener = this.listeners[type][i];
+                        str += listener.scope && listener.scope.className ? listener.scope.className : "anonymous";
+                        str += " listen for '" + type + "'\n";
+                    }
+                }
+                return str;
+            }
+        };
+        return EventManager;
+    }]).service('eventManager', ["EventManager", function (EventManager) {
+        return new EventManager();
+    }]);
+})();
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletBoundsHelpers', ["leafletLogger", "leafletHelpers", function (leafletLogger, leafletHelpers) {
+
+    var isArray = leafletHelpers.isArray,
+        isNumber = leafletHelpers.isNumber,
+        isFunction = leafletHelpers.isFunction,
+        isDefined = leafletHelpers.isDefined,
+        $log = leafletLogger;
+
+    function _isValidBounds(bounds) {
+        return angular.isDefined(bounds) && angular.isDefined(bounds.southWest) && angular.isDefined(bounds.northEast) && angular.isNumber(bounds.southWest.lat) && angular.isNumber(bounds.southWest.lng) && angular.isNumber(bounds.northEast.lat) && angular.isNumber(bounds.northEast.lng);
+    }
+
+    return {
+        createLeafletBounds: function createLeafletBounds(bounds) {
+            if (_isValidBounds(bounds)) {
+                return L.latLngBounds([bounds.southWest.lat, bounds.southWest.lng], [bounds.northEast.lat, bounds.northEast.lng]);
+            }
+        },
+
+        isValidBounds: _isValidBounds,
+
+        createBoundsFromArray: function createBoundsFromArray(boundsArray) {
+            if (!(isArray(boundsArray) && boundsArray.length === 2 && isArray(boundsArray[0]) && isArray(boundsArray[1]) && boundsArray[0].length === 2 && boundsArray[1].length === 2 && isNumber(boundsArray[0][0]) && isNumber(boundsArray[0][1]) && isNumber(boundsArray[1][0]) && isNumber(boundsArray[1][1]))) {
+                $log.error("[AngularJS - Leaflet] The bounds array is not valid.");
+                return;
+            }
+
+            return {
+                northEast: {
+                    lat: boundsArray[0][0],
+                    lng: boundsArray[0][1]
+                },
+                southWest: {
+                    lat: boundsArray[1][0],
+                    lng: boundsArray[1][1]
+                }
+            };
+        },
+
+        createBoundsFromLeaflet: function createBoundsFromLeaflet(lfBounds) {
+            if (!(isDefined(lfBounds) && isFunction(lfBounds.getNorthEast) && isFunction(lfBounds.getSouthWest))) {
+                $log.error("[AngularJS - Leaflet] The leaflet bounds is not valid object.");
+                return;
+            }
+
+            var northEast = lfBounds.getNorthEast(),
+                southWest = lfBounds.getSouthWest();
+
+            return {
+                northEast: {
+                    lat: northEast.lat,
+                    lng: northEast.lng
+                },
+                southWest: {
+                    lat: southWest.lat,
+                    lng: southWest.lng
+                }
+            };
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletControlHelpers', ["$rootScope", "leafletLogger", "leafletHelpers", "leafletLayerHelpers", "leafletMapDefaults", function ($rootScope, leafletLogger, leafletHelpers, leafletLayerHelpers, leafletMapDefaults) {
+    var isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        createLayer = leafletLayerHelpers.createLayer,
+        _controls = {},
+        errorHeader = leafletHelpers.errorHeader + ' [Controls] ',
+        $log = leafletLogger;
+
+    var _controlLayersMustBeVisible = function _controlLayersMustBeVisible(baselayers, overlays, mapId) {
+        var defaults = leafletMapDefaults.getDefaults(mapId);
+        if (!defaults.controls.layers.visible) {
+            return false;
+        }
+
+        var atLeastOneControlItemMustBeShown = false;
+
+        if (isObject(baselayers)) {
+            Object.keys(baselayers).forEach(function (key) {
+                var layer = baselayers[key];
+                if (!isDefined(layer.layerOptions) || layer.layerOptions.showOnSelector !== false) {
+                    atLeastOneControlItemMustBeShown = true;
+                }
+            });
+        }
+
+        if (isObject(overlays)) {
+            Object.keys(overlays).forEach(function (key) {
+                var layer = overlays[key];
+                if (!isDefined(layer.layerParams) || layer.layerParams.showOnSelector !== false) {
+                    atLeastOneControlItemMustBeShown = true;
+                }
+            });
+        }
+
+        return atLeastOneControlItemMustBeShown;
+    };
+
+    var _createLayersControl = function _createLayersControl(mapId) {
+        var defaults = leafletMapDefaults.getDefaults(mapId);
+        var controlOptions = {
+            collapsed: defaults.controls.layers.collapsed,
+            position: defaults.controls.layers.position,
+            autoZIndex: false
+        };
+
+        angular.extend(controlOptions, defaults.controls.layers.options);
+
+        var control;
+        if (defaults.controls.layers && isDefined(defaults.controls.layers.control)) {
+            control = defaults.controls.layers.control.apply(this, [[], [], controlOptions]);
+        } else {
+            control = new L.control.layers([], [], controlOptions);
+        }
+
+        return control;
+    };
+
+    var controlTypes = {
+        draw: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.Draw)) {
+                    $log.error(errorHeader + ' Draw plugin is not loaded.');
+                    return false;
+                }
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.Control.Draw(params);
+            }
+        },
+        scale: {
+            isPluginLoaded: function isPluginLoaded() {
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.control.scale(params);
+            }
+        },
+        fullscreen: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.Fullscreen)) {
+                    $log.error(errorHeader + ' Fullscreen plugin is not loaded.');
+                    return false;
+                }
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.Control.Fullscreen(params);
+            }
+        },
+        search: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.Search)) {
+                    $log.error(errorHeader + ' Search plugin is not loaded.');
+                    return false;
+                }
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.Control.Search(params);
+            }
+        },
+        custom: {},
+        minimap: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.MiniMap)) {
+                    $log.error(errorHeader + ' Minimap plugin is not loaded.');
+                    return false;
+                }
+
+                return true;
+            },
+            checkValidParams: function checkValidParams(params) {
+                if (!isDefined(params.layer)) {
+                    $log.warn(errorHeader + ' minimap "layer" option should be defined.');
+                    return false;
+                }
+                return true;
+            },
+            createControl: function createControl(params) {
+                var layer = createLayer(params.layer);
+
+                if (!isDefined(layer)) {
+                    $log.warn(errorHeader + ' minimap control "layer" could not be created.');
+                    return;
+                }
+
+                return new L.Control.MiniMap(layer, params);
+            }
+        }
+    };
+
+    return {
+        layersControlMustBeVisible: _controlLayersMustBeVisible,
+
+        isValidControlType: function isValidControlType(type) {
+            return Object.keys(controlTypes).indexOf(type) !== -1;
+        },
+
+        createControl: function createControl(type, params) {
+            if (!controlTypes[type].checkValidParams(params)) {
+                return;
+            }
+
+            return controlTypes[type].createControl(params);
+        },
+
+        updateLayersControl: function updateLayersControl(map, mapId, loaded, baselayers, overlays, leafletLayers) {
+            var i;
+            var _layersControl = _controls[mapId];
+            var mustBeLoaded = _controlLayersMustBeVisible(baselayers, overlays, mapId);
+
+            if (isDefined(_layersControl) && loaded) {
+                for (i in leafletLayers.baselayers) {
+                    _layersControl.removeLayer(leafletLayers.baselayers[i]);
+                }
+                for (i in leafletLayers.overlays) {
+                    _layersControl.removeLayer(leafletLayers.overlays[i]);
+                }
+                map.removeControl(_layersControl);
+                delete _controls[mapId];
+            }
+
+            if (mustBeLoaded) {
+                _layersControl = _createLayersControl(mapId);
+                _controls[mapId] = _layersControl;
+                for (i in baselayers) {
+                    var hideOnSelector = isDefined(baselayers[i].layerOptions) && baselayers[i].layerOptions.showOnSelector === false;
+                    if (!hideOnSelector && isDefined(leafletLayers.baselayers[i])) {
+                        _layersControl.addBaseLayer(leafletLayers.baselayers[i], baselayers[i].name);
+                    }
+                }
+                for (i in overlays) {
+                    var hideOverlayOnSelector = isDefined(overlays[i].layerParams) && overlays[i].layerParams.showOnSelector === false;
+                    if (!hideOverlayOnSelector && isDefined(leafletLayers.overlays[i])) {
+                        _layersControl.addOverlay(leafletLayers.overlays[i], overlays[i].name);
+                    }
+                }
+
+                map.addControl(_layersControl);
+            }
+            return mustBeLoaded;
+        },
+
+        destroyMapLayersControl: function destroyMapLayersControl(mapId) {
+            delete _controls[mapId];
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletData', ["leafletLogger", "$q", "leafletHelpers", function (leafletLogger, $q, leafletHelpers) {
+    var getDefer = leafletHelpers.getDefer,
+        getUnresolvedDefer = leafletHelpers.getUnresolvedDefer,
+        setResolvedDefer = leafletHelpers.setResolvedDefer;
+    // $log = leafletLogger;
+
+    var _private = {};
+    var self = this;
+
+    var upperFirst = function upperFirst(string) {
+        return string.charAt(0).toUpperCase() + string.slice(1);
+    };
+
+    var _privateItems = ['map', 'tiles', 'layers', 'paths', 'markers', 'geoJSON', 'UTFGrid', //odd ball on naming convention keeping to not break
+    'decorations', 'directiveControls'];
+
+    //init
+    _privateItems.forEach(function (itemName) {
+        _private[itemName] = {};
+    });
+
+    this.unresolveMap = function (scopeId) {
+        var id = leafletHelpers.obtainEffectiveMapId(_private.map, scopeId);
+        _privateItems.forEach(function (itemName) {
+            _private[itemName][id] = undefined;
+        });
+    };
+
+    //int repetitive stuff (get and sets)
+    _privateItems.forEach(function (itemName) {
+        var name = upperFirst(itemName);
+        self['set' + name] = function (lObject, scopeId) {
+            var defer = getUnresolvedDefer(_private[itemName], scopeId);
+            defer.resolve(lObject);
+            setResolvedDefer(_private[itemName], scopeId);
+        };
+
+        self['get' + name] = function (scopeId) {
+            var defer = getDefer(_private[itemName], scopeId);
+            return defer.promise;
+        };
+    });
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletDirectiveControlsHelpers', ["leafletLogger", "leafletData", "leafletHelpers", function (leafletLogger, leafletData, leafletHelpers) {
+    var _isDefined = leafletHelpers.isDefined,
+        _isString = leafletHelpers.isString,
+        _isObject = leafletHelpers.isObject,
+        _mainErrorHeader = leafletHelpers.errorHeader,
+        $log = leafletLogger;
+
+    var _errorHeader = _mainErrorHeader + '[leafletDirectiveControlsHelpers';
+
+    var _extend = function _extend(id, thingToAddName, createFn, cleanFn) {
+        var _fnHeader = _errorHeader + '.extend] ';
+        var extender = {};
+        if (!_isDefined(thingToAddName)) {
+            $log.error(_fnHeader + 'thingToAddName cannot be undefined');
+            return;
+        }
+
+        if (_isString(thingToAddName) && _isDefined(createFn) && _isDefined(cleanFn)) {
+            extender[thingToAddName] = {
+                create: createFn,
+                clean: cleanFn
+            };
+        } else if (_isObject(thingToAddName) && !_isDefined(createFn) && !_isDefined(cleanFn)) {
+            extender = thingToAddName;
+        } else {
+            $log.error(_fnHeader + 'incorrect arguments');
+            return;
+        }
+
+        //add external control to create / destroy markers without a watch
+        leafletData.getDirectiveControls().then(function (controls) {
+            angular.extend(controls, extender);
+            leafletData.setDirectiveControls(controls, id);
+        });
+    };
+
+    return {
+        extend: _extend
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletGeoJsonHelpers', ["leafletHelpers", "leafletIterators", function (leafletHelpers, leafletIterators) {
+    var lHlp = leafletHelpers,
+        lIt = leafletIterators;
+    var Point = function Point(lat, lng) {
+        this.lat = lat;
+        this.lng = lng;
+        return this;
+    };
+
+    var _getLat = function _getLat(value) {
+        if (Array.isArray(value) && value.length === 2) {
+            return value[1];
+        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {
+            return +value.coordinates[1];
+        } else {
+            return +value.lat;
+        }
+    };
+
+    var _getLng = function _getLng(value) {
+        if (Array.isArray(value) && value.length === 2) {
+            return value[0];
+        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {
+            return +value.coordinates[0];
+        } else {
+            return +value.lng;
+        }
+    };
+
+    var _validateCoords = function _validateCoords(coords) {
+        if (lHlp.isUndefined(coords)) {
+            return false;
+        }
+        if (lHlp.isArray(coords)) {
+            if (coords.length === 2 && lHlp.isNumber(coords[0]) && lHlp.isNumber(coords[1])) {
+                return true;
+            }
+        } else if (lHlp.isDefined(coords.type)) {
+            if (coords.type === 'Point' && lHlp.isArray(coords.coordinates) && coords.coordinates.length === 2 && lHlp.isNumber(coords.coordinates[0]) && lHlp.isNumber(coords.coordinates[1])) {
+                return true;
+            }
+        }
+
+        var ret = lIt.all(['lat', 'lng'], function (pos) {
+            return lHlp.isDefined(coords[pos]) && lHlp.isNumber(coords[pos]);
+        });
+        return ret;
+    };
+
+    var _getCoords = function _getCoords(value) {
+        if (!value || !_validateCoords(value)) {
+            return;
+        }
+        var p = null;
+        if (Array.isArray(value) && value.length === 2) {
+            p = new Point(value[1], value[0]);
+        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {
+            p = new Point(value.coordinates[1], value.coordinates[0]);
+        } else {
+            return value;
+        }
+        //note angular.merge is avail in angular 1.4.X we might want to fill it here
+        return angular.extend(value, p); //tap on lat, lng if it doesnt exist
+    };
+
+    return {
+        getLat: _getLat,
+        getLng: _getLng,
+        validateCoords: _validateCoords,
+        getCoords: _getCoords
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletHelpers', ["$q", "$log", "$timeout", function ($q, $log, $timeout) {
+    var _errorHeader = '[ui-leaflet] ';
+    var _copy = angular.copy;
+    var _clone = _copy;
+    /*
+    For parsing paths to a field in an object
+     Example:
+    var obj = {
+        bike:{
+         1: 'hi'
+         2: 'foo'
+        }
+    };
+    _getObjectValue(obj,"bike.1") returns 'hi'
+    this is getPath in ui-gmap
+     */
+    var _getObjectValue = function _getObjectValue(object, pathStr) {
+        var obj;
+        if (!object || !angular.isObject(object)) return;
+        //if the key is not a sting then we already have the value
+        if (pathStr === null || !angular.isString(pathStr)) {
+            return pathStr;
+        }
+        obj = object;
+        pathStr.split('.').forEach(function (value) {
+            if (obj) {
+                obj = obj[value];
+            }
+        });
+        return obj;
+    };
+
+    /*
+     Object Array Notation
+     _getObjectArrayPath("bike.one.two")
+     returns:
+     'bike["one"]["two"]'
+     */
+    var _getObjectArrayPath = function _getObjectArrayPath(pathStr) {
+        return pathStr.split('.').reduce(function (previous, current) {
+            return previous + '["' + current + '"]';
+        });
+    };
+
+    /* Object Dot Notation
+     _getObjectPath(["bike","one","two"])
+     returns:
+     "bike.one.two"
+     */
+    var _getObjectDotPath = function _getObjectDotPath(arrayOfStrings) {
+        return arrayOfStrings.reduce(function (previous, current) {
+            return previous + '.' + current;
+        });
+    };
+
+    function _obtainEffectiveMapId(d, mapId) {
+        var id, i;
+        if (!angular.isDefined(mapId)) {
+            if (Object.keys(d).length === 0) {
+                id = "main";
+            } else if (Object.keys(d).length >= 1) {
+                for (i in d) {
+                    if (d.hasOwnProperty(i)) {
+                        id = i;
+                    }
+                }
+            } else {
+                $log.error(_errorHeader + "- You have more than 1 map on the DOM, you must provide the map ID to the leafletData.getXXX call");
+            }
+        } else {
+            id = mapId;
+        }
+
+        return id;
+    }
+
+    function _getUnresolvedDefer(d, mapId) {
+        var id = _obtainEffectiveMapId(d, mapId),
+            defer;
+
+        if (!angular.isDefined(d[id]) || d[id].resolvedDefer === true) {
+            defer = $q.defer();
+            d[id] = {
+                defer: defer,
+                resolvedDefer: false
+            };
+        } else {
+            defer = d[id].defer;
+        }
+
+        return defer;
+    }
+
+    var _isDefined = function _isDefined(value) {
+        return angular.isDefined(value) && value !== null;
+    };
+    var _isUndefined = function _isUndefined(value) {
+        return !_isDefined(value);
+    };
+
+    // BEGIN DIRECT PORT FROM AngularJS code base
+
+    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
+
+    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
+
+    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
+
+    /**
+    Converts snake_case to camelCase.
+    Also there is special case for Moz prefix starting with upper case letter.
+    @param name Name to normalize
+     */
+
+    var camelCase = function camelCase(name) {
+        return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
+            if (offset) {
+                return letter.toUpperCase();
+            } else {
+                return letter;
+            }
+        }).replace(MOZ_HACK_REGEXP, "Moz$1");
+    };
+
+    /**
+        Converts all accepted directives format into proper directive name.
+        @param name Name to normalize
+    */
+
+    var directiveNormalize = function directiveNormalize(name) {
+        return camelCase(name.replace(PREFIX_REGEXP, ""));
+    };
+    // END AngularJS port
+
+    var _watchTrapDelayMilliSec = 10;
+
+    var _modelChangeInDirective = function _modelChangeInDirective(trapObj, trapField, cbToExec) {
+        if (!trapObj) throw new Error(_errorHeader + 'trapObj is undefined');
+        if (!trapField) throw new Error(_errorHeader + 'trapField is undefined');
+
+        trapObj[trapField] = true;
+        var ret = cbToExec();
+        $timeout(function () {
+            trapObj[trapField] = false;
+        }, _watchTrapDelayMilliSec);
+        return ret;
+    };
+
+    return {
+        watchTrapDelayMilliSec: _watchTrapDelayMilliSec,
+        modelChangeInDirective: _modelChangeInDirective,
+        camelCase: camelCase,
+        directiveNormalize: directiveNormalize,
+        copy: _copy,
+        clone: _clone,
+        errorHeader: _errorHeader,
+        getObjectValue: _getObjectValue,
+        getObjectArrayPath: _getObjectArrayPath,
+        getObjectDotPath: _getObjectDotPath,
+        defaultTo: function defaultTo(val, _default) {
+            return _isDefined(val) ? val : _default;
+        },
+        //mainly for checking attributes of directives lets keep this minimal (on what we accept)
+        isTruthy: function isTruthy(val) {
+            return val === 'true' || val === true;
+        },
+        //Determine if a reference is {}
+        isEmpty: function isEmpty(value) {
+            return Object.keys(value).length === 0;
+        },
+
+        //Determine if a reference is undefined or {}
+        isUndefinedOrEmpty: function isUndefinedOrEmpty(value) {
+            return angular.isUndefined(value) || value === null || Object.keys(value).length === 0;
+        },
+
+        // Determine if a reference is defined
+        isDefined: _isDefined,
+        isUndefined: _isUndefined,
+        isNumber: angular.isNumber,
+        isString: angular.isString,
+        isArray: angular.isArray,
+        isObject: angular.isObject,
+        isFunction: angular.isFunction,
+        equals: angular.equals,
+
+        isValidCenter: function isValidCenter(center) {
+            return angular.isDefined(center) && angular.isNumber(center.lat) && angular.isNumber(center.lng) && angular.isNumber(center.zoom);
+        },
+
+        isValidPoint: function isValidPoint(point) {
+            if (!angular.isDefined(point)) {
+                return false;
+            }
+            if (angular.isArray(point)) {
+                return point.length === 2 && angular.isNumber(point[0]) && angular.isNumber(point[1]);
+            }
+            return angular.isNumber(point.lat) && angular.isNumber(point.lng);
+        },
+
+        isSameCenterOnMap: function isSameCenterOnMap(centerModel, map) {
+            var mapCenter = map.getCenter();
+            var zoom = map.getZoom();
+            if (centerModel.lat && centerModel.lng && mapCenter.lat.toFixed(4) === centerModel.lat.toFixed(4) && mapCenter.lng.toFixed(4) === centerModel.lng.toFixed(4) && zoom === centerModel.zoom) {
+                return true;
+            }
+            return false;
+        },
+
+        safeApply: function safeApply($scope, fn) {
+            var phase = $scope.$root.$$phase;
+            if (phase === '$apply' || phase === '$digest') {
+                $scope.$eval(fn);
+            } else {
+                $scope.$evalAsync(fn);
+            }
+        },
+
+        obtainEffectiveMapId: _obtainEffectiveMapId,
+
+        getDefer: function getDefer(d, mapId) {
+            var id = _obtainEffectiveMapId(d, mapId),
+                defer;
+            if (!angular.isDefined(d[id]) || d[id].resolvedDefer === false) {
+                defer = _getUnresolvedDefer(d, mapId);
+            } else {
+                defer = d[id].defer;
+            }
+            return defer;
+        },
+
+        getUnresolvedDefer: _getUnresolvedDefer,
+
+        setResolvedDefer: function setResolvedDefer(d, mapId) {
+            var id = _obtainEffectiveMapId(d, mapId);
+            d[id].resolvedDefer = true;
+        },
+
+        rangeIsSupported: function rangeIsSupported() {
+            var testrange = document.createElement('input');
+            testrange.setAttribute('type', 'range');
+            return testrange.type === 'range';
+        },
+
+        FullScreenControlPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.Control.Fullscreen);
+            }
+        },
+
+        MiniMapControlPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.Control.MiniMap);
+            }
+        },
+
+        AwesomeMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.AwesomeMarkers) && angular.isDefined(L.AwesomeMarkers.Icon);
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.AwesomeMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        VectorMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.VectorMarkers) && angular.isDefined(L.VectorMarkers.Icon);
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.VectorMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        DomMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.DomMarkers) && angular.isDefined(L.DomMarkers.Icon)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.DomMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        PolylineDecoratorPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.PolylineDecorator)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(decoration) {
+                if (this.isLoaded()) {
+                    return decoration instanceof L.PolylineDecorator;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(decorationA, decorationB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(decorationA)) {
+                    return angular.equals(decorationA, decorationB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        MakiMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.MakiMarkers) && angular.isDefined(L.MakiMarkers.Icon)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.MakiMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+        ExtraMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.ExtraMarkers) && angular.isDefined(L.ExtraMarkers.Icon)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.ExtraMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+        LabelPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.Label);
+            },
+            is: function is(layer) {
+                if (this.isLoaded()) {
+                    return layer instanceof L.MarkerClusterGroup;
+                } else {
+                    return false;
+                }
+            }
+        },
+        MarkerClusterPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.MarkerClusterGroup);
+            },
+            is: function is(layer) {
+                if (this.isLoaded()) {
+                    return layer instanceof L.MarkerClusterGroup;
+                } else {
+                    return false;
+                }
+            }
+        },
+        GeoJSONPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.TileLayer.GeoJSON);
+            },
+            is: function is(layer) {
+                if (this.isLoaded()) {
+                    return layer instanceof L.TileLayer.GeoJSON;
+                } else {
+                    return false;
+                }
+            }
+        },
+        CartoDB: {
+            isLoaded: function isLoaded() {
+                return cartodb;
+            },
+            is: function is() /*layer*/{
+                return true;
+                /*
+                if (this.isLoaded()) {
+                    return layer instanceof L.TileLayer.GeoJSON;
+                } else {
+                    return false;
+                }*/
+            }
+        },
+        Leaflet: {
+            DivIcon: {
+                is: function is(icon) {
+                    return icon instanceof L.DivIcon;
+                },
+                equal: function equal(iconA, iconB) {
+                    if (this.is(iconA)) {
+                        return angular.equals(iconA, iconB);
+                    } else {
+                        return false;
+                    }
+                }
+            },
+            Icon: {
+                is: function is(icon) {
+                    return icon instanceof L.Icon;
+                },
+                equal: function equal(iconA, iconB) {
+                    if (this.is(iconA)) {
+                        return angular.equals(iconA, iconB);
+                    } else {
+                        return false;
+                    }
+                }
+            }
+        },
+        /*
+         watchOptions - object to set deep nested watches and turn off watches all together
+         (rely on control / functional updates)
+         watchOptions - Object
+             type: string. //One of ['watch', 'watchCollection', 'watchDeep', null]
+             individual
+                 type: string
+         */
+        //legacy defaults
+        watchOptions: {
+            type: 'watchDeep',
+            individual: {
+                type: 'watchDeep'
+            }
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletIterators', ["leafletLogger", "leafletHelpers", function (leafletLogger, leafletHelpers) {
+
+  var lHlp = leafletHelpers,
+      errorHeader = leafletHelpers.errorHeader + 'leafletIterators: ';
+
+  //BEGIN COPY from underscore
+  var _keys = Object.keys;
+  var _isFunction = lHlp.isFunction;
+  var _isObject = lHlp.isObject;
+  var $log = leafletLogger;
+
+  // Helper for collection methods to determine whether a collection
+  // should be iterated as an array or as an object
+  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
+  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
+
+  var _isArrayLike = function _isArrayLike(collection) {
+    var length = collection !== null && collection.length;
+    return lHlp.isNumber(length) && length >= 0 && length <= MAX_ARRAY_INDEX;
+  };
+
+  // Keep the identity function around for default iteratees.
+  var _identity = function _identity(value) {
+    return value;
+  };
+
+  var _property = function _property(key) {
+    return function (obj) {
+      return obj === null ? void 0 : obj[key];
+    };
+  };
+
+  // Internal function that returns an efficient (for current engines) version
+  // of the passed-in callback, to be repeatedly applied in other Underscore
+  // functions.
+  var optimizeCb = function optimizeCb(func, context, argCount) {
+    if (context === void 0) return func;
+    switch (argCount === null ? 3 : argCount) {
+      case 1:
+        return function (value) {
+          return func.call(context, value);
+        };
+      case 2:
+        return function (value, other) {
+          return func.call(context, value, other);
+        };
+      case 3:
+        return function (value, index, collection) {
+          return func.call(context, value, index, collection);
+        };
+      case 4:
+        return function (accumulator, value, index, collection) {
+          return func.call(context, accumulator, value, index, collection);
+        };
+    }
+    return function () {
+      return func.apply(context, arguments);
+    };
+  };
+
+  // An internal function for creating assigner functions.
+  var createAssigner = function createAssigner(keysFunc, undefinedOnly) {
+    return function (obj) {
+      var length = arguments.length;
+      if (length < 2 || obj === null) return obj;
+      for (var index = 1; index < length; index++) {
+        var source = arguments[index],
+            keys = keysFunc(source),
+            l = keys.length;
+        for (var i = 0; i < l; i++) {
+          var key = keys[i];
+          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
+        }
+      }
+      return obj;
+    };
+  };
+
+  // Assigns a given object with all the own properties in the passed-in object(s)
+  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
+  var _extendOwn,
+      _assign = null;
+  _extendOwn = _assign = createAssigner(_keys);
+
+  // Returns whether an object has a given set of `key:value` pairs.
+  var _isMatch = function _isMatch(object, attrs) {
+    var keys = _keys(attrs),
+        length = keys.length;
+    if (object === null) return !length;
+    var obj = Object(object);
+    for (var i = 0; i < length; i++) {
+      var key = keys[i];
+      if (attrs[key] !== obj[key] || !(key in obj)) return false;
+    }
+    return true;
+  };
+
+  // Returns a predicate for checking whether an object has a given set of
+  // `key:value` pairs.
+  var _matcher,
+      _matches = null;
+  _matcher = _matches = function _matches(attrs) {
+    attrs = _extendOwn({}, attrs);
+    return function (obj) {
+      return _isMatch(obj, attrs);
+    };
+  };
+
+  // A mostly-internal function to generate callbacks that can be applied
+  // to each element in a collection, returning the desired result  either
+  // identity, an arbitrary callback, a property matcher, or a property accessor.
+  var cb = function cb(value, context, argCount) {
+    if (value === null) return _identity;
+    if (_isFunction(value)) return optimizeCb(value, context, argCount);
+    if (_isObject(value)) return _matcher(value);
+    return _property(value);
+  };
+
+  var _every,
+      _all = null;
+  _every = _all = function _all(obj, predicate, context) {
+    predicate = cb(predicate, context);
+    var keys = !_isArrayLike(obj) && _keys(obj),
+        length = (keys || obj).length;
+    for (var index = 0; index < length; index++) {
+      var currentKey = keys ? keys[index] : index;
+      if (!predicate(obj[currentKey], currentKey, obj)) return false;
+    }
+    return true;
+  };
+
+  //END COPY fron underscore
+
+  var _hasErrors = function _hasErrors(collection, cb, ignoreCollection, cbName) {
+    if (!ignoreCollection) {
+      if (!lHlp.isDefined(collection) || !lHlp.isDefined(cb)) {
+        return true;
+      }
+    }
+    if (!lHlp.isFunction(cb)) {
+      cbName = lHlp.defaultTo(cb, 'cb');
+      $log.error(errorHeader + cbName + ' is not a function');
+      return true;
+    }
+    return false;
+  };
+
+  var _iterate = function _iterate(collection, externalCb, internalCb) {
+    if (_hasErrors(undefined, internalCb, true, 'internalCb')) {
+      return;
+    }
+    if (!_hasErrors(collection, externalCb)) {
+      for (var key in collection) {
+        if (collection.hasOwnProperty(key)) {
+          internalCb(collection[key], key);
+        }
+      }
+    }
+  };
+
+  //see http://jsperf.com/iterators/3
+  //utilizing for in is way faster
+  var _each = function _each(collection, cb) {
+    _iterate(collection, cb, function (val, key) {
+      cb(val, key);
+    });
+  };
+
+  return {
+    each: _each,
+    forEach: _each,
+    every: _every,
+    all: _all
+  };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletLayerHelpers', ["$rootScope", "$q", "leafletLogger", "leafletHelpers", "leafletIterators", function ($rootScope, $q, leafletLogger, leafletHelpers, leafletIterators) {
+    var Helpers = leafletHelpers;
+    var isString = leafletHelpers.isString;
+    var isObject = leafletHelpers.isObject;
+    var isArray = leafletHelpers.isArray;
+    var isDefined = leafletHelpers.isDefined;
+    var errorHeader = leafletHelpers.errorHeader;
+    var $it = leafletIterators;
+    var $log = leafletLogger;
+
+    var utfGridCreateLayer = function utfGridCreateLayer(params) {
+        if (!Helpers.UTFGridPlugin.isLoaded()) {
+            $log.error('[AngularJS - Leaflet] The UTFGrid plugin is not loaded.');
+            return;
+        }
+        var utfgrid = new L.UtfGrid(params.url, params.pluginOptions);
+
+        var toSend = {
+            model: params.$parent
+        };
+
+        // TODO Use event manager
+        utfgrid.on('mouseover', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseover', toSend);
+        });
+
+        utfgrid.on('mouseout', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseout', toSend);
+        });
+
+        utfgrid.on('click', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridClick', toSend);
+        });
+
+        utfgrid.on('mousemove', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridMousemove', toSend);
+        });
+
+        return utfgrid;
+    };
+
+    var layerTypes = {
+        xyz: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer(params.url, params.options);
+            }
+        },
+        geoJSON: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                if (!Helpers.GeoJSONPlugin.isLoaded()) {
+                    return;
+                }
+                return new L.TileLayer.GeoJSON(params.url, params.pluginOptions, params.options);
+            }
+        },
+        geoJSONShape: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                return new L.GeoJSON(params.data, params.options);
+            }
+        },
+        geoJSONAwesomeMarker: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                return new L.geoJson(params.data, {
+                    pointToLayer: function pointToLayer(feature, latlng) {
+                        return L.marker(latlng, { icon: L.AwesomeMarkers.icon(params.icon) });
+                    }
+                });
+            }
+        },
+        geoJSONVectorMarker: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                return new L.geoJson(params.data, {
+                    pointToLayer: function pointToLayer(feature, latlng) {
+                        return L.marker(latlng, { icon: L.VectorMarkers.icon(params.icon) });
+                    }
+                });
+            }
+        },
+        cartodbTiles: {
+            mustHaveKey: true,
+            createLayer: function createLayer(params) {
+                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';
+                url += '/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';
+                return L.tileLayer(url, params.options);
+            }
+        },
+        cartodbUTFGrid: {
+            mustHaveKey: true,
+            mustHaveLayer: true,
+            createLayer: function createLayer(params) {
+                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';
+                params.url = url + '/api/v1/map/' + params.key + '/' + params.layer + '/{z}/{x}/{y}.grid.json';
+                return utfGridCreateLayer(params);
+            }
+        },
+        cartodbInteractive: {
+            mustHaveKey: true,
+            mustHaveLayer: true,
+            createLayer: function createLayer(params) {
+                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';
+                var tilesURL = url + '/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';
+                var tileLayer = L.tileLayer(tilesURL, params.options);
+                var layers = [tileLayer];
+
+                var addUtfLayer = function addUtfLayer(parent, params, layer) {
+                    var paramsCopy = angular.copy(params);
+                    paramsCopy.url = url + '/api/v1/map/' + paramsCopy.key + '/' + layer + '/{z}/{x}/{y}.grid.json';
+                    parent.push(utfGridCreateLayer(paramsCopy));
+                };
+
+                if (isArray(params.layer)) {
+                    for (var i = 0; i < params.layer.length; i++) {
+                        addUtfLayer(layers, params, params.layer[i]);
+                    }
+                } else {
+                    addUtfLayer(layers, params, params.layer);
+                }
+                return L.layerGroup(layers);
+            }
+        },
+        wms: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer.wms(params.url, params.options);
+            }
+        },
+        wmts: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer.wmts(params.url, params.options);
+            }
+        },
+        group: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                var lyrs = [];
+                $it.each(params.options.layers, function (l) {
+                    lyrs.push(_createLayer(l));
+                });
+                params.options.loadedDefer = function () {
+                    var defers = [];
+                    if (isDefined(params.options.layers)) {
+                        for (var i = 0; i < params.options.layers.length; i++) {
+                            var d = params.options.layers[i].layerOptions.loadedDefer;
+                            if (isDefined(d)) {
+                                defers.push(d);
+                            }
+                        }
+                    }
+                    return defers;
+                };
+                return L.layerGroup(lyrs);
+            }
+        },
+        featureGroup: {
+            mustHaveUrl: false,
+            createLayer: function createLayer() {
+                return L.featureGroup();
+            }
+        },
+        markercluster: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                if (!Helpers.MarkerClusterPlugin.isLoaded()) {
+                    $log.warn(errorHeader + ' The markercluster plugin is not loaded.');
+                    return;
+                }
+                return new L.MarkerClusterGroup(params.options);
+            }
+        },
+        imageOverlay: {
+            mustHaveUrl: true,
+            mustHaveBounds: true,
+            createLayer: function createLayer(params) {
+                return L.imageOverlay(params.url, params.bounds, params.options);
+            }
+        },
+        iip: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer.iip(params.url, params.options);
+            }
+        },
+
+        // This "custom" type is used to accept every layer that user want to define himself.
+        // We can wrap these custom layers like heatmap or yandex, but it means a lot of work/code to wrap the world,
+        // so we let user to define their own layer outside the directive,
+        // and pass it on "createLayer" result for next processes
+        custom: {
+            createLayer: function createLayer(params) {
+                if (params.layer instanceof L.Class) {
+                    return angular.copy(params.layer);
+                } else {
+                    $log.error('[AngularJS - Leaflet] A custom layer must be a leaflet Class');
+                }
+            }
+        },
+        cartodb: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return cartodb.createLayer(params.map, params.url);
+            }
+        }
+    };
+
+    function isValidLayerType(layerDefinition) {
+        // Check if the baselayer has a valid type
+        if (!isString(layerDefinition.type)) {
+            $log.error('[AngularJS - Leaflet] A layer must have a valid type defined.');
+            return false;
+        }
+
+        if (Object.keys(layerTypes).indexOf(layerDefinition.type) === -1) {
+            $log.error('[AngularJS - Leaflet] A layer must have a valid type: ' + Object.keys(layerTypes));
+            return false;
+        }
+
+        // Check if the layer must have an URL
+        if (layerTypes[layerDefinition.type].mustHaveUrl && !isString(layerDefinition.url)) {
+            $log.error('[AngularJS - Leaflet] A base layer must have an url');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveData && !isDefined(layerDefinition.data)) {
+            $log.error('[AngularJS - Leaflet] The base layer must have a "data" array attribute');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveLayer && !isDefined(layerDefinition.layer)) {
+            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have an layer defined');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveBounds && !isDefined(layerDefinition.bounds)) {
+            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have bounds defined');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveKey && !isDefined(layerDefinition.key)) {
+            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have key defined');
+            return false;
+        }
+        return true;
+    }
+
+    function _createLayer(layerDefinition) {
+        if (!isValidLayerType(layerDefinition)) {
+            return;
+        }
+
+        if (!isString(layerDefinition.name)) {
+            $log.error('[AngularJS - Leaflet] A base layer must have a name');
+            return;
+        }
+        if (!isObject(layerDefinition.layerParams)) {
+            layerDefinition.layerParams = {};
+        }
+        if (!isObject(layerDefinition.layerOptions)) {
+            layerDefinition.layerOptions = {};
+        }
+
+        // Mix the layer specific parameters with the general Leaflet options. Although this is an overhead
+        // the definition of a base layers is more 'clean' if the two types of parameters are differentiated
+        for (var attrname in layerDefinition.layerParams) {
+            layerDefinition.layerOptions[attrname] = layerDefinition.layerParams[attrname];
+        }
+
+        var params = {
+            url: layerDefinition.url,
+            data: layerDefinition.data,
+            options: layerDefinition.layerOptions,
+            layer: layerDefinition.layer,
+            icon: layerDefinition.icon,
+            type: layerDefinition.layerType,
+            bounds: layerDefinition.bounds,
+            key: layerDefinition.key,
+            apiKey: layerDefinition.apiKey,
+            pluginOptions: layerDefinition.pluginOptions,
+            user: layerDefinition.user,
+            $parent: layerDefinition
+        };
+
+        //TODO Add $watch to the layer properties
+        return layerTypes[layerDefinition.type].createLayer(params);
+    }
+
+    function safeAddLayer(map, layer) {
+        if (layer && typeof layer.addTo === 'function') {
+            layer.addTo(map);
+        } else {
+            map.addLayer(layer);
+        }
+    }
+
+    function safeRemoveLayer(map, layer, layerOptions) {
+        if (isDefined(layerOptions) && isDefined(layerOptions.loadedDefer)) {
+            if (angular.isFunction(layerOptions.loadedDefer)) {
+                var defers = layerOptions.loadedDefer();
+                $log.debug('Loaded Deferred', defers);
+                var count = defers.length;
+                if (count > 0) {
+                    var resolve = function resolve() {
+                        count--;
+                        if (count === 0) {
+                            map.removeLayer(layer);
+                        }
+                    };
+
+                    for (var i = 0; i < defers.length; i++) {
+                        defers[i].promise.then(resolve);
+                    }
+                } else {
+                    map.removeLayer(layer);
+                }
+            } else {
+                layerOptions.loadedDefer.promise.then(function () {
+                    map.removeLayer(layer);
+                });
+            }
+        } else {
+            map.removeLayer(layer);
+        }
+    }
+
+    var changeOpacityListener = function changeOpacityListener(op) {
+        return function (ly) {
+            if (isDefined(ly.setOpacity)) {
+                ly.setOpacity(op);
+            }
+        };
+    };
+
+    return {
+        createLayer: _createLayer,
+        layerTypes: layerTypes,
+        safeAddLayer: safeAddLayer,
+        safeRemoveLayer: safeRemoveLayer,
+        changeOpacityListener: changeOpacityListener
+    };
+}]);
+
+'use strict';
+
+angular.module("ui-leaflet").factory('leafletLegendHelpers', ["$http", "$q", "$log", "leafletHelpers", function ($http, $q, $log, leafletHelpers) {
+	var requestQueue = {},
+	    isDefined = leafletHelpers.isDefined;
+
+	var _execNext = function _execNext(mapId) {
+		var queue = requestQueue[mapId];
+		var task = queue[0];
+		$http(task.c).then(function (data) {
+			queue.shift();
+			task.d.resolve(data);
+			if (queue.length > 0) {
+				_execNext(mapId);
+			}
+		}, function (err) {
+			queue.shift();
+			task.d.reject(err);
+			if (queue.length > 0) {
+				_execNext(mapId);
+			}
+		});
+	};
+
+	var _updateLegend = function _updateLegend(div, legendData, type, url) {
+		div.innerHTML = '';
+		if (legendData.error) {
+			div.innerHTML += '<div class="info-title alert alert-danger">' + legendData.error.message + '</div>';
+		} else {
+			if (type === 'arcgis') {
+				for (var i = 0; i < legendData.layers.length; i++) {
+					var layer = legendData.layers[i];
+					div.innerHTML += '<div class="info-title" data-layerid="' + layer.layerId + '">' + layer.layerName + '</div>';
+					for (var j = 0; j < layer.legend.length; j++) {
+						var leg = layer.legend[j];
+						div.innerHTML += '<div class="inline" data-layerid="' + layer.layerId + '"><img src="data:' + leg.contentType + ';base64,' + leg.imageData + '" /></div>' + '<div class="info-label" data-layerid="' + layer.layerId + '">' + leg.label + '</div>';
+					}
+				}
+			} else if (type === 'image') {
+				div.innerHTML = '<img src="' + url + '"/>';
+			}
+		}
+	};
+
+	var _getOnAddLegend = function _getOnAddLegend(legendData, legendClass, type, url) {
+		return function () /*map*/{
+			var div = L.DomUtil.create('div', legendClass);
+
+			if (!L.Browser.touch) {
+				L.DomEvent.disableClickPropagation(div);
+				L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
+			} else {
+				L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
+			}
+			_updateLegend(div, legendData, type, url);
+			return div;
+		};
+	};
+
+	var _getOnAddArrayLegend = function _getOnAddArrayLegend(legend, legendClass) {
+		return function () /*map*/{
+			var div = L.DomUtil.create('div', legendClass);
+			for (var i = 0; i < legend.colors.length; i++) {
+				div.innerHTML += '<div class="outline"><i style="background:' + legend.colors[i] + '"></i></div>' + '<div class="info-label">' + legend.labels[i] + '</div>';
+			}
+			if (!L.Browser.touch) {
+				L.DomEvent.disableClickPropagation(div);
+				L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
+			} else {
+				L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
+			}
+			return div;
+		};
+	};
+
+	return {
+		getOnAddLegend: _getOnAddLegend,
+		getOnAddArrayLegend: _getOnAddArrayLegend,
+		updateLegend: _updateLegend,
+		addLegendURL: function addLegendURL(mapId, config) {
+			var d = $q.defer();
+			if (!isDefined(requestQueue[mapId])) {
+				requestQueue[mapId] = [];
+			}
+			requestQueue[mapId].push({ c: config, d: d });
+			if (requestQueue[mapId].length === 1) {
+				_execNext(mapId);
+			}
+			return d.promise;
+		}
+	};
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletMapDefaults', ["$q", "leafletHelpers", function ($q, leafletHelpers) {
+    function _getDefaults() {
+        return {
+            keyboard: true,
+            dragging: true,
+            worldCopyJump: false,
+            doubleClickZoom: true,
+            scrollWheelZoom: true,
+            tap: true,
+            touchZoom: true,
+            zoomControl: true,
+            zoomsliderControl: false,
+            zoomControlPosition: 'topleft',
+            attributionControl: true,
+            controls: {
+                layers: {
+                    visible: true,
+                    position: 'topright',
+                    collapsed: true
+                }
+            },
+            nominatim: {
+                server: ' http://nominatim.openstreetmap.org/search'
+            },
+            crs: L.CRS.EPSG3857,
+            tileLayer: '//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
+            tileLayerOptions: {
+                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
+            },
+            path: {
+                weight: 10,
+                opacity: 1,
+                color: '#0000ff'
+            },
+            center: {
+                lat: 0,
+                lng: 0,
+                zoom: 1
+            },
+            trackResize: true
+        };
+    }
+
+    var isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        obtainEffectiveMapId = leafletHelpers.obtainEffectiveMapId,
+        defaults = {};
+
+    // Get the _defaults dictionary, and override the properties defined by the user
+    return {
+        reset: function reset() {
+            defaults = {};
+        },
+        getDefaults: function getDefaults(scopeId) {
+            var mapId = obtainEffectiveMapId(defaults, scopeId);
+            return defaults[mapId];
+        },
+
+        getMapCreationDefaults: function getMapCreationDefaults(scopeId) {
+            var mapId = obtainEffectiveMapId(defaults, scopeId);
+            var d = defaults[mapId];
+
+            var mapDefaults = {
+                maxZoom: d.maxZoom,
+                keyboard: d.keyboard,
+                dragging: d.dragging,
+                zoomControl: d.zoomControl,
+                doubleClickZoom: d.doubleClickZoom,
+                scrollWheelZoom: d.scrollWheelZoom,
+                tap: d.tap,
+                touchZoom: d.touchZoom,
+                attributionControl: d.attributionControl,
+                worldCopyJump: d.worldCopyJump,
+                crs: d.crs,
+                trackResize: d.trackResize
+            };
+
+            if (isDefined(d.minZoom)) {
+                mapDefaults.minZoom = d.minZoom;
+            }
+
+            if (isDefined(d.zoomAnimation)) {
+                mapDefaults.zoomAnimation = d.zoomAnimation;
+            }
+
+            if (isDefined(d.fadeAnimation)) {
+                mapDefaults.fadeAnimation = d.fadeAnimation;
+            }
+
+            if (isDefined(d.markerZoomAnimation)) {
+                mapDefaults.markerZoomAnimation = d.markerZoomAnimation;
+            }
+
+            if (d.map) {
+                for (var option in d.map) {
+                    mapDefaults[option] = d.map[option];
+                }
+            }
+
+            return mapDefaults;
+        },
+
+        setDefaults: function setDefaults(userDefaults, scopeId) {
+            var newDefaults = _getDefaults();
+
+            if (isDefined(userDefaults)) {
+                newDefaults.doubleClickZoom = isDefined(userDefaults.doubleClickZoom) ? userDefaults.doubleClickZoom : newDefaults.doubleClickZoom;
+                newDefaults.scrollWheelZoom = isDefined(userDefaults.scrollWheelZoom) ? userDefaults.scrollWheelZoom : newDefaults.doubleClickZoom;
+                newDefaults.tap = isDefined(userDefaults.tap) ? userDefaults.tap : newDefaults.tap;
+                newDefaults.touchZoom = isDefined(userDefaults.touchZoom) ? userDefaults.touchZoom : newDefaults.doubleClickZoom;
+                newDefaults.zoomControl = isDefined(userDefaults.zoomControl) ? userDefaults.zoomControl : newDefaults.zoomControl;
+                newDefaults.zoomsliderControl = isDefined(userDefaults.zoomsliderControl) ? userDefaults.zoomsliderControl : newDefaults.zoomsliderControl;
+                newDefaults.attributionControl = isDefined(userDefaults.attributionControl) ? userDefaults.attributionControl : newDefaults.attributionControl;
+                newDefaults.tileLayer = isDefined(userDefaults.tileLayer) ? userDefaults.tileLayer : newDefaults.tileLayer;
+                newDefaults.zoomControlPosition = isDefined(userDefaults.zoomControlPosition) ? userDefaults.zoomControlPosition : newDefaults.zoomControlPosition;
+                newDefaults.keyboard = isDefined(userDefaults.keyboard) ? userDefaults.keyboard : newDefaults.keyboard;
+                newDefaults.dragging = isDefined(userDefaults.dragging) ? userDefaults.dragging : newDefaults.dragging;
+                newDefaults.trackResize = isDefined(userDefaults.trackResize) ? userDefaults.trackResize : newDefaults.trackResize;
+
+                if (isDefined(userDefaults.controls)) {
+                    angular.extend(newDefaults.controls, userDefaults.controls);
+                }
+
+                if (isObject(userDefaults.crs)) {
+                    newDefaults.crs = userDefaults.crs;
+                } else if (isDefined(L.CRS[userDefaults.crs])) {
+                    newDefaults.crs = L.CRS[userDefaults.crs];
+                }
+
+                if (isDefined(userDefaults.center)) {
+                    angular.copy(userDefaults.center, newDefaults.center);
+                }
+
+                if (isDefined(userDefaults.tileLayerOptions)) {
+                    angular.copy(userDefaults.tileLayerOptions, newDefaults.tileLayerOptions);
+                }
+
+                if (isDefined(userDefaults.maxZoom)) {
+                    newDefaults.maxZoom = userDefaults.maxZoom;
+                }
+
+                if (isDefined(userDefaults.minZoom)) {
+                    newDefaults.minZoom = userDefaults.minZoom;
+                }
+
+                if (isDefined(userDefaults.zoomAnimation)) {
+                    newDefaults.zoomAnimation = userDefaults.zoomAnimation;
+                }
+
+                if (isDefined(userDefaults.fadeAnimation)) {
+                    newDefaults.fadeAnimation = userDefaults.fadeAnimation;
+                }
+
+                if (isDefined(userDefaults.markerZoomAnimation)) {
+                    newDefaults.markerZoomAnimation = userDefaults.markerZoomAnimation;
+                }
+
+                if (isDefined(userDefaults.worldCopyJump)) {
+                    newDefaults.worldCopyJump = userDefaults.worldCopyJump;
+                }
+
+                if (isDefined(userDefaults.map)) {
+                    newDefaults.map = userDefaults.map;
+                }
+
+                if (isDefined(userDefaults.path)) {
+                    newDefaults.path = userDefaults.path;
+                }
+            }
+
+            var mapId = obtainEffectiveMapId(defaults, scopeId);
+            defaults[mapId] = newDefaults;
+            return newDefaults;
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletMarkersHelpers', ["$rootScope", "$timeout", "leafletHelpers", "leafletLogger", "$compile", "leafletGeoJsonHelpers", "leafletWatchHelpers", function ($rootScope, $timeout, leafletHelpers, leafletLogger, $compile, leafletGeoJsonHelpers, leafletWatchHelpers) {
+    var isDefined = leafletHelpers.isDefined,
+        defaultTo = leafletHelpers.defaultTo,
+        MarkerClusterPlugin = leafletHelpers.MarkerClusterPlugin,
+        AwesomeMarkersPlugin = leafletHelpers.AwesomeMarkersPlugin,
+        VectorMarkersPlugin = leafletHelpers.VectorMarkersPlugin,
+        MakiMarkersPlugin = leafletHelpers.MakiMarkersPlugin,
+        ExtraMarkersPlugin = leafletHelpers.ExtraMarkersPlugin,
+        DomMarkersPlugin = leafletHelpers.DomMarkersPlugin,
+        safeApply = leafletHelpers.safeApply,
+        Helpers = leafletHelpers,
+        isString = leafletHelpers.isString,
+        isNumber = leafletHelpers.isNumber,
+        isObject = leafletHelpers.isObject,
+        groups = {},
+        geoHlp = leafletGeoJsonHelpers,
+        errorHeader = leafletHelpers.errorHeader,
+        maybeWatch = leafletWatchHelpers.maybeWatch,
+        $log = leafletLogger;
+
+    var _string = function _string(marker) {
+        //this exists since JSON.stringify barfs on cyclic
+        var retStr = '';
+        ['_icon', '_latlng', '_leaflet_id', '_map', '_shadow'].forEach(function (prop) {
+            retStr += prop + ': ' + defaultTo(marker[prop], 'undefined') + ' \n';
+        });
+        return '[leafletMarker] : \n' + retStr;
+    };
+    var _log = function _log(marker, useConsole) {
+        var logger = useConsole ? console : $log;
+        logger.debug(_string(marker));
+    };
+
+    var existDomContainer = function existDomContainer(groupName) {
+        return angular.element(groups[groupName]._map._container).parent().length > 0;
+    };
+
+    var createLeafletIcon = function createLeafletIcon(iconData) {
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'awesomeMarker') {
+            if (!AwesomeMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + ' The AwesomeMarkers Plugin is not loaded.');
+            }
+
+            return new L.AwesomeMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'vectorMarker') {
+            if (!VectorMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + ' The VectorMarkers Plugin is not loaded.');
+            }
+
+            return new L.VectorMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'makiMarker') {
+            if (!MakiMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + 'The MakiMarkers Plugin is not loaded.');
+            }
+
+            return new L.MakiMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'extraMarker') {
+            if (!ExtraMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + 'The ExtraMarkers Plugin is not loaded.');
+            }
+            return new L.ExtraMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'div') {
+            return new L.divIcon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'dom') {
+            if (!DomMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + 'The DomMarkers Plugin is not loaded.');
+            }
+            var markerScope = angular.isFunction(iconData.getMarkerScope) ? iconData.getMarkerScope().$new() : $rootScope,
+                template = $compile(iconData.template)(markerScope),
+                iconDataCopy = angular.copy(iconData);
+            iconDataCopy.ngElement = template;
+            iconDataCopy.element = template[0];
+            if (angular.isFunction(iconData.getMarkerScope)) iconDataCopy.scope = markerScope;
+            return new L.DomMarkers.icon(iconDataCopy);
+        }
+
+        // allow for any custom icon to be used... assumes the icon has already been initialized
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'icon') {
+            return iconData.icon;
+        }
+
+        var base64icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAGmklEQVRYw7VXeUyTZxjvNnfELFuyIzOabermMZEeQC/OclkO49CpOHXOLJl/CAURuYbQi3KLgEhbrhZ1aDwmaoGqKII6odATmH/scDFbdC7LvFqOCc+e95s2VG50X/LLm/f4/Z7neY/ne18aANCmAr5E/xZf1uDOkTcGcWR6hl9247tT5U7Y6SNvWsKT63P58qbfeLJG8M5qcgTknrvvrdDbsT7Ml+tv82X6vVxJE33aRmgSyYtcWVMqX97Yv2JvW39UhRE2HuyBL+t+gK1116ly06EeWFNlAmHxlQE0OMiV6mQCScusKRlhS3QLeVJdl1+23h5dY4FNB3thrbYboqptEFlphTC1hSpJnbRvxP4NWgsE5Jyz86QNNi/5qSUTGuFk1gu54tN9wuK2wc3o+Wc13RCmsoBwEqzGcZsxsvCSy/9wJKf7UWf1mEY8JWfewc67UUoDbDjQC+FqK4QqLVMGGR9d2wurKzqBk3nqIT/9zLxRRjgZ9bqQgub+DdoeCC03Q8j+0QhFhBHR/eP3U/zCln7Uu+hihJ1+bBNffLIvmkyP0gpBZWYXhKussK6mBz5HT6M1Nqpcp+mBCPXosYQfrekGvrjewd59/GvKCE7TbK/04/ZV5QZYVWmDwH1mF3xa2Q3ra3DBC5vBT1oP7PTj4C0+CcL8c7C2CtejqhuCnuIQHaKHzvcRfZpnylFfXsYJx3pNLwhKzRAwAhEqG0SpusBHfAKkxw3w4627MPhoCH798z7s0ZnBJ/MEJbZSbXPhER2ih7p2ok/zSj2cEJDd4CAe+5WYnBCgR2uruyEw6zRoW6/DWJ/OeAP8pd/BGtzOZKpG8oke0SX6GMmRk6GFlyAc59K32OTEinILRJRchah8HQwND8N435Z9Z0FY1EqtxUg+0SO6RJ/mmXz4VuS+DpxXC3gXmZwIL7dBSH4zKE50wESf8qwVgrP1EIlTO5JP9Igu0aexdh28F1lmAEGJGfh7jE6ElyM5Rw/FDcYJjWhbeiBYoYNIpc2FT/SILivp0F1ipDWk4BIEo2VuodEJUifhbiltnNBIXPUFCMpthtAyqws/BPlEF/VbaIxErdxPphsU7rcCp8DohC+GvBIPJS/tW2jtvTmmAeuNO8BNOYQeG8G/2OzCJ3q+soYB5i6NhMaKr17FSal7GIHheuV3uSCY8qYVuEm1cOzqdWr7ku/R0BDoTT+DT+ohCM6/CCvKLKO4RI+dXPeAuaMqksaKrZ7L3FE5FIFbkIceeOZ2OcHO6wIhTkNo0ffgjRGxEqogXHYUPHfWAC/lADpwGcLRY3aeK4/oRGCKYcZXPVoeX/kelVYY8dUGf8V5EBRbgJXT5QIPhP9ePJi428JKOiEYhYXFBqou2Guh+p/mEB1/RfMw6rY7cxcjTrneI1FrDyuzUSRm9miwEJx8E/gUmqlyvHGkneiwErR21F3tNOK5Tf0yXaT+O7DgCvALTUBXdM4YhC/IawPU+2PduqMvuaR6eoxSwUk75ggqsYJ7VicsnwGIkZBSXKOUww73WGXyqP+J2/b9c+gi1YAg/xpwck3gJuucNrh5JvDPvQr0WFXf0piyt8f8/WI0hV4pRxxkQZdJDfDJNOAmM0Ag8jyT6hz0WGXWuP94Yh2jcfjmXAGvHCMslRimDHYuHuDsy2QtHuIavznhbYURq5R57KpzBBRZKPJi8eQg48h4j8SDdowifdIrEVdU+gbO6QNvRRt4ZBthUaZhUnjlYObNagV3keoeru3rU7rcuceqU1mJBxy+BWZYlNEBH+0eH4vRiB+OYybU2hnblYlTvkHinM4m54YnxSyaZYSF6R3jwgP7udKLGIX6r/lbNa9N6y5MFynjWDtrHd75ZvTYAPO/6RgF0k76mQla3FGq7dO+cH8sKn0Vo7nDllwAhqwLPkxrHwWmHJOo+AKJ4rab5OgrM7rVu8eWb2Pu0Dh4eDgXoOfvp7Y7QeqknRmvcTBEyq9m/HQQSCSz6LHq3z0yzsNySRfMS253wl2KyRDbcZPcfJKjZmSEOjcxyi+Y8dUOtsIEH6R2wNykdqrkYJ0RV92H0W58pkfQk7cKevsLK10Py8SdMGfXNXATY+pPbyJR/ET6n9nIfztNtZYRV9XniQu9IA2vOVgy4ir7GCLVmmd+zjkH0eAF9Po6K61pmCXHxU5rHMYd1ftc3owjwRSVRzLjKvqZEty6cRUD7jGqiOdu5HG6MdHjNcNYGqfDm5YRzLBBCCDl/2bk8a8gdbqcfwECu62Fg/HrggAAAABJRU5ErkJggg==";
+        var base64shadow = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=";
+
+        if (!isDefined(iconData) || !isDefined(iconData.iconUrl)) {
+            return new L.Icon.Default({
+                iconUrl: base64icon,
+                shadowUrl: base64shadow,
+                iconSize: [25, 41],
+                iconAnchor: [12, 41],
+                popupAnchor: [1, -34],
+                shadowSize: [41, 41]
+            });
+        }
+
+        return new L.Icon(iconData);
+    };
+
+    var _resetMarkerGroup = function _resetMarkerGroup(groupName) {
+        if (isDefined(groups[groupName])) {
+            delete groups[groupName];
+        }
+    };
+
+    var _resetMarkerGroups = function _resetMarkerGroups() {
+        groups = {};
+    };
+
+    var _resetUnusedMarkerGroups = function _resetUnusedMarkerGroups() {
+        for (var groupName in groups) {
+            if (!existDomContainer(groupName)) {
+                _resetMarkerGroup(groupName);
+            }
+        }
+    };
+
+    var _cleanDomIcon = function _cleanDomIcon(marker) {
+        if (marker.options.icon.options.ngElement) {
+            marker.options.icon.options.ngElement.remove();
+        }
+        if (marker.options.icon.options.scope) {
+            marker.options.icon.options.scope.$destroy();
+        }
+    };
+
+    var _deleteMarker = function _deleteMarker(marker, map, layers) {
+        marker.closePopup();
+
+        // if it's a dom icon, clean it
+        if (marker.options.icon && marker.options.icon.options && marker.options.icon.options.type === 'dom') {
+            _cleanDomIcon(marker);
+        }
+
+        // There is no easy way to know if a marker is added to a layer, so we search for it
+        // if there are overlays
+        if (isDefined(layers) && isDefined(layers.overlays)) {
+            for (var key in layers.overlays) {
+                if (layers.overlays[key] instanceof L.LayerGroup || layers.overlays[key] instanceof L.FeatureGroup) {
+                    if (layers.overlays[key].hasLayer(marker)) {
+                        layers.overlays[key].removeLayer(marker);
+                        return;
+                    }
+                }
+            }
+        }
+
+        if (isDefined(groups)) {
+            for (var groupKey in groups) {
+                if (groups[groupKey].hasLayer(marker)) {
+                    groups[groupKey].removeLayer(marker);
+                }
+            }
+        }
+
+        if (map.hasLayer(marker)) {
+            map.removeLayer(marker);
+        }
+    };
+
+    var adjustPopupPan = function adjustPopupPan(marker, map) {
+        var containerHeight = marker._popup._container.offsetHeight,
+            layerPos = new L.Point(marker._popup._containerLeft, -containerHeight - marker._popup._containerBottom),
+            containerPos = map.layerPointToContainerPoint(layerPos);
+        if (containerPos !== null) {
+            marker._popup._adjustPan();
+        }
+    };
+
+    var compilePopup = function compilePopup(marker, markerScope) {
+        $compile(marker._popup._contentNode)(markerScope);
+    };
+
+    var updatePopup = function updatePopup(marker, markerScope, map) {
+        //The innerText should be more than 1 once angular has compiled.
+        //We need to keep trying until angular has compiled before we _updateLayout and _updatePosition
+        //This should take care of any scenario , eg ngincludes, whatever.
+        //Is there a better way to check for this?
+        var innerText = marker._popup._contentNode.innerText || marker._popup._contentNode.textContent;
+        if (innerText.length < 1) {
+            $timeout(function () {
+                updatePopup(marker, markerScope, map);
+            });
+        }
+
+        //cause a reflow - this is also very important - if we don't do this then the widths are from before $compile
+        var reflow = marker._popup._contentNode.offsetWidth;
+
+        marker._popup._updateLayout();
+        marker._popup._updatePosition();
+
+        if (marker._popup.options.autoPan) {
+            adjustPopupPan(marker, map);
+        }
+
+        //using / returning reflow so jshint doesn't moan
+        return reflow;
+    };
+
+    var _manageOpenPopup = function _manageOpenPopup(marker, markerData, map) {
+        // The marker may provide a scope returning function used to compile the message
+        // default to $rootScope otherwise
+        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,
+            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;
+
+        if (compileMessage) {
+            if (!isDefined(marker._popup) || !isDefined(marker._popup._contentNode)) {
+                $log.error(errorHeader + 'Popup is invalid or does not have any content.');
+                return false;
+            }
+
+            compilePopup(marker, markerScope);
+            updatePopup(marker, markerData, map);
+        }
+    };
+
+    var _manageOpenLabel = function _manageOpenLabel(marker, markerData) {
+        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,
+            labelScope = angular.isFunction(markerData.getLabelScope) ? markerData.getLabelScope() : markerScope,
+            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;
+
+        if (Helpers.LabelPlugin.isLoaded() && isDefined(markerData.label)) {
+            if (isDefined(markerData.label.options) && markerData.label.options.noHide === true) {
+                marker.showLabel();
+            }
+            if (compileMessage && isDefined(marker.label)) {
+                $compile(marker.label._container)(labelScope);
+            }
+        }
+    };
+
+    var _updateMarker = function _updateMarker(markerData, oldMarkerData, marker, name, leafletScope, layers, map) {
+        if (!isDefined(oldMarkerData)) {
+            return;
+        }
+
+        // Update the lat-lng property (always present in marker properties)
+        if (!geoHlp.validateCoords(markerData)) {
+            $log.warn('There are problems with lat-lng data, please verify your marker model');
+            _deleteMarker(marker, map, layers);
+            return;
+        }
+
+        // watch is being initialized if old and new object is the same
+        var isInitializing = markerData === oldMarkerData;
+
+        // Update marker rotation
+        if (isDefined(markerData.iconAngle) && oldMarkerData.iconAngle !== markerData.iconAngle) {
+            marker.setIconAngle(markerData.iconAngle);
+        }
+
+        // It is possible that the layer has been removed or the layer marker does not exist
+        // Update the layer group if present or move it to the map if not
+        if (!isString(markerData.layer)) {
+            // There is no layer information, we move the marker to the map if it was in a layer group
+            if (isString(oldMarkerData.layer)) {
+                // Remove from the layer group that is supposed to be
+                if (isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {
+                    layers.overlays[oldMarkerData.layer].removeLayer(marker);
+                    marker.closePopup();
+                }
+                // Test if it is not on the map and add it
+                if (!map.hasLayer(marker)) {
+                    map.addLayer(marker);
+                }
+            }
+        }
+
+        if ((isNumber(markerData.opacity) || isNumber(parseFloat(markerData.opacity))) && markerData.opacity !== oldMarkerData.opacity) {
+            // There was a different opacity so we update it
+            marker.setOpacity(markerData.opacity);
+        }
+
+        if (isString(markerData.layer) && oldMarkerData.layer !== markerData.layer) {
+            // If it was on a layer group we have to remove it
+            if (isString(oldMarkerData.layer) && isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {
+                layers.overlays[oldMarkerData.layer].removeLayer(marker);
+            }
+            marker.closePopup();
+
+            // Remove it from the map in case the new layer is hidden or there is an error in the new layer
+            if (map.hasLayer(marker)) {
+                map.removeLayer(marker);
+            }
+
+            // The markerData.layer is defined so we add the marker to the layer if it is different from the old data
+            if (!isDefined(layers.overlays[markerData.layer])) {
+                $log.error(errorHeader + 'You must use a name of an existing layer');
+                return;
+            }
+            // Is a group layer?
+            var layerGroup = layers.overlays[markerData.layer];
+            if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {
+                $log.error(errorHeader + 'A marker can only be added to a layer of type "group" or "featureGroup"');
+                return;
+            }
+            // The marker goes to a correct layer group, so first of all we add it
+            layerGroup.addLayer(marker);
+            // The marker is automatically added to the map depending on the visibility
+            // of the layer, so we only have to open the popup if the marker is in the map
+            if (map.hasLayer(marker) && markerData.focus === true) {
+                marker.openPopup();
+            }
+        }
+
+        // Update the draggable property
+        if (markerData.draggable !== true && oldMarkerData.draggable === true && isDefined(marker.dragging)) {
+            marker.dragging.disable();
+        }
+
+        if (markerData.draggable === true && oldMarkerData.draggable !== true) {
+            // The markerData.draggable property must be true so we update if there wasn't a previous value or it wasn't true
+            if (marker.dragging) {
+                marker.dragging.enable();
+            } else {
+                if (L.Handler.MarkerDrag) {
+                    marker.dragging = new L.Handler.MarkerDrag(marker);
+                    marker.options.draggable = true;
+                    marker.dragging.enable();
+                }
+            }
+        }
+
+        // Update the icon property
+        if (!isObject(markerData.icon)) {
+            // If there is no icon property or it's not an object
+            if (isObject(oldMarkerData.icon)) {
+                if (oldMarkerData.icon.type === 'dom') {
+                    // clean previous icon if it's a dom one
+                    _cleanDomIcon(marker);
+                }
+                // If there was an icon before restore to the default
+                marker.setIcon(createLeafletIcon());
+                marker.closePopup();
+                marker.unbindPopup();
+                if (isString(markerData.message)) {
+                    marker.bindPopup(markerData.message, markerData.popupOptions);
+                }
+            }
+        }
+
+        if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {
+            var dragG = false;
+            if (marker.dragging) {
+                dragG = marker.dragging.enabled();
+            }
+            if (oldMarkerData.icon.type === 'dom') {
+                // clean previous icon if it's a dom one
+                _cleanDomIcon(marker);
+            }
+            marker.setIcon(createLeafletIcon(markerData.icon));
+            if (dragG) {
+                marker.dragging.enable();
+            }
+            marker.closePopup();
+            marker.unbindPopup();
+            if (isString(markerData.message)) {
+                marker.bindPopup(markerData.message, markerData.popupOptions);
+                // if marker has been already focused, reopen popup
+                if (map.hasLayer(marker) && markerData.focus === true) {
+                    marker.openPopup();
+                }
+            }
+        }
+
+        // Update the Popup message property
+        if (!isString(markerData.message) && isString(oldMarkerData.message)) {
+            marker.closePopup();
+            marker.unbindPopup();
+        }
+
+        // Update the label content or bind a new label if the old one has been removed.
+        if (Helpers.LabelPlugin.isLoaded()) {
+            if (isDefined(markerData.label) && isDefined(markerData.label.message)) {
+                if ('label' in oldMarkerData && 'message' in oldMarkerData.label && !angular.equals(markerData.label.message, oldMarkerData.label.message)) {
+                    marker.updateLabelContent(markerData.label.message);
+                } else if (!angular.isFunction(marker.getLabel) || angular.isFunction(marker.getLabel) && !isDefined(marker.getLabel())) {
+                    marker.bindLabel(markerData.label.message, markerData.label.options);
+                    _manageOpenLabel(marker, markerData);
+                } else {
+                    _manageOpenLabel(marker, markerData);
+                }
+            } else if (!('label' in markerData && !('message' in markerData.label))) {
+                if (angular.isFunction(marker.unbindLabel)) {
+                    marker.unbindLabel();
+                }
+            }
+        }
+
+        // There is some text in the popup, so we must show the text or update existing
+        if (isString(markerData.message) && !isString(oldMarkerData.message)) {
+            // There was no message before so we create it
+            marker.bindPopup(markerData.message, markerData.popupOptions);
+        }
+
+        if (isString(markerData.message) && isString(oldMarkerData.message) && markerData.message !== oldMarkerData.message) {
+            // There was a different previous message so we update it
+            marker.setPopupContent(markerData.message);
+        }
+
+        // Update the focus property
+        var updatedFocus = false;
+        if (markerData.focus !== true && oldMarkerData.focus === true) {
+            // If there was a focus property and was true we turn it off
+            marker.closePopup();
+            updatedFocus = true;
+        }
+
+        // The markerData.focus property must be true so we update if there wasn't a previous value or it wasn't true
+        if (markerData.focus === true && (!isDefined(oldMarkerData.focus) || oldMarkerData.focus === false) || isInitializing && markerData.focus === true) {
+            // Reopen the popup when focus is still true
+            marker.openPopup();
+            updatedFocus = true;
+        }
+
+        // zIndexOffset adjustment
+        if (oldMarkerData.zIndexOffset !== markerData.zIndexOffset) {
+            marker.setZIndexOffset(markerData.zIndexOffset);
+        }
+
+        var markerLatLng = marker.getLatLng();
+        var isCluster = isString(markerData.layer) && Helpers.MarkerClusterPlugin.is(layers.overlays[markerData.layer]);
+        // If the marker is in a cluster it has to be removed and added to the layer when the location is changed
+        if (isCluster) {
+            // The focus has changed even by a user click or programatically
+            if (updatedFocus) {
+                // We only have to update the location if it was changed programatically, because it was
+                // changed by a user drag the marker data has already been updated by the internal event
+                // listened by the directive
+                if (markerData.lat !== oldMarkerData.lat || markerData.lng !== oldMarkerData.lng) {
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    marker.setLatLng([markerData.lat, markerData.lng]);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                }
+            } else {
+                // The marker has possibly moved. It can be moved by a user drag (marker location and data are equal but old
+                // data is diferent) or programatically (marker location and data are diferent)
+                if (markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng) {
+                    // The marker was moved by a user drag
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    marker.setLatLng([markerData.lat, markerData.lng]);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                } else if (markerData.lat !== oldMarkerData.lat || markerData.lng !== oldMarkerData.lng) {
+                    // The marker was moved programatically
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    marker.setLatLng([markerData.lat, markerData.lng]);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                } else if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                }
+            }
+        } else if (markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng) {
+            marker.setLatLng([markerData.lat, markerData.lng]);
+        }
+    };
+
+    var _getLayerModels = function _getLayerModels(models, layerName) {
+        if (!isDefined(models)) return;
+        if (layerName) return models[layerName];
+        return models;
+    };
+
+    var _getModelFromModels = function _getModelFromModels(models, id, layerName) {
+        if (!isDefined(models)) return;
+        if (!id) {
+            $log.error(errorHeader + 'marker id missing in getMarker');
+            return;
+        }
+        if (layerName) return models[layerName][id];
+
+        return models[id];
+    };
+    return {
+        resetMarkerGroup: _resetMarkerGroup,
+
+        resetMarkerGroups: _resetMarkerGroups,
+
+        resetUnusedMarkerGroups: _resetUnusedMarkerGroups,
+
+        deleteMarker: _deleteMarker,
+
+        manageOpenPopup: _manageOpenPopup,
+
+        manageOpenLabel: _manageOpenLabel,
+
+        createMarker: function createMarker(markerData) {
+            if (!isDefined(markerData) || !geoHlp.validateCoords(markerData)) {
+                $log.error(errorHeader + 'The marker definition is not valid.');
+                return;
+            }
+            var coords = geoHlp.getCoords(markerData);
+
+            if (!isDefined(coords)) {
+                $log.error(errorHeader + 'Unable to get coordinates from markerData.');
+                return;
+            }
+
+            var markerOptions = {
+                icon: createLeafletIcon(markerData.icon),
+                title: isDefined(markerData.title) ? markerData.title : '',
+                draggable: isDefined(markerData.draggable) ? markerData.draggable : false,
+                clickable: isDefined(markerData.clickable) ? markerData.clickable : true,
+                riseOnHover: isDefined(markerData.riseOnHover) ? markerData.riseOnHover : false,
+                zIndexOffset: isDefined(markerData.zIndexOffset) ? markerData.zIndexOffset : 0,
+                iconAngle: isDefined(markerData.iconAngle) ? markerData.iconAngle : 0
+            };
+            // Add any other options not added above to markerOptions
+            for (var markerDatum in markerData) {
+                if (markerData.hasOwnProperty(markerDatum) && !markerOptions.hasOwnProperty(markerDatum)) {
+                    markerOptions[markerDatum] = markerData[markerDatum];
+                }
+            }
+
+            var marker = new L.marker(coords, markerOptions);
+
+            if (!isString(markerData.message)) {
+                marker.unbindPopup();
+            }
+
+            return marker;
+        },
+
+        addMarkerToGroup: function addMarkerToGroup(marker, groupName, groupOptions, map) {
+            if (!isString(groupName)) {
+                $log.error(errorHeader + 'The marker group you have specified is invalid.');
+                return;
+            }
+
+            if (!MarkerClusterPlugin.isLoaded()) {
+                $log.error(errorHeader + "The MarkerCluster plugin is not loaded.");
+                return;
+            }
+            if (!isDefined(groups[groupName])) {
+                groups[groupName] = new L.MarkerClusterGroup(groupOptions);
+                map.addLayer(groups[groupName]);
+            }
+            groups[groupName].addLayer(marker);
+        },
+
+        listenMarkerEvents: function listenMarkerEvents(marker, markerData, leafletScope, watchType, map) {
+            marker.on("popupopen", function () /* event */{
+                safeApply(leafletScope, function () {
+                    if (isDefined(marker._popup) || isDefined(marker._popup._contentNode)) {
+                        markerData.focus = true;
+                        _manageOpenPopup(marker, markerData, map); //needed since markerData is now a copy
+                    }
+                });
+            });
+            marker.on("popupclose", function () /* event */{
+                safeApply(leafletScope, function () {
+                    markerData.focus = false;
+                });
+            });
+            marker.on("add", function () /* event */{
+                safeApply(leafletScope, function () {
+                    if ('label' in markerData) _manageOpenLabel(marker, markerData);
+                });
+            });
+        },
+
+        updateMarker: _updateMarker,
+
+        addMarkerWatcher: function addMarkerWatcher(marker, name, leafletScope, layers, map, watchOptions) {
+            var markerWatchPath = Helpers.getObjectArrayPath("markers." + name);
+
+            maybeWatch(leafletScope, markerWatchPath, watchOptions, function (markerData, oldMarkerData, clearWatch) {
+                if (!isDefined(markerData)) {
+                    _deleteMarker(marker, map, layers);
+                    clearWatch();
+                    return;
+                }
+                _updateMarker(markerData, oldMarkerData, marker, name, leafletScope, layers, map);
+            });
+        },
+        string: _string,
+        log: _log,
+        getModelFromModels: _getModelFromModels,
+        getLayerModels: _getLayerModels
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletPathsHelpers', ["$rootScope", "leafletLogger", "leafletHelpers", function ($rootScope, leafletLogger, leafletHelpers) {
+    var isDefined = leafletHelpers.isDefined,
+        isArray = leafletHelpers.isArray,
+        isNumber = leafletHelpers.isNumber,
+        isValidPoint = leafletHelpers.isValidPoint,
+        $log = leafletLogger;
+
+    var availableOptions = [
+    // Path options
+    'stroke', 'weight', 'color', 'opacity', 'fill', 'fillColor', 'fillOpacity', 'dashArray', 'lineCap', 'lineJoin', 'clickable', 'pointerEvents', 'className',
+
+    // Polyline options
+    'smoothFactor', 'noClip'];
+    function _convertToLeafletLatLngs(latlngs) {
+        return latlngs.filter(function (latlng) {
+            return isValidPoint(latlng);
+        }).map(function (latlng) {
+            return _convertToLeafletLatLng(latlng);
+        });
+    }
+
+    function _convertToLeafletLatLng(latlng) {
+        if (isArray(latlng)) {
+            return new L.LatLng(latlng[0], latlng[1]);
+        } else {
+            return new L.LatLng(latlng.lat, latlng.lng);
+        }
+    }
+
+    function _convertToLeafletMultiLatLngs(paths) {
+        return paths.map(function (latlngs) {
+            return _convertToLeafletLatLngs(latlngs);
+        });
+    }
+
+    function _getOptions(path, defaults) {
+        var options = {};
+        for (var i = 0; i < availableOptions.length; i++) {
+            var optionName = availableOptions[i];
+
+            if (isDefined(path[optionName])) {
+                options[optionName] = path[optionName];
+            } else if (isDefined(defaults.path[optionName])) {
+                options[optionName] = defaults.path[optionName];
+            }
+        }
+
+        return options;
+    }
+
+    var _updatePathOptions = function _updatePathOptions(path, data) {
+        var updatedStyle = {};
+        for (var i = 0; i < availableOptions.length; i++) {
+            var optionName = availableOptions[i];
+            if (isDefined(data[optionName])) {
+                updatedStyle[optionName] = data[optionName];
+            }
+        }
+        path.setStyle(data);
+    };
+
+    var _isValidPolyline = function _isValidPolyline(latlngs) {
+        if (!isArray(latlngs)) {
+            return false;
+        }
+        for (var i = 0; i < latlngs.length; i++) {
+            var point = latlngs[i];
+            if (!isValidPoint(point)) {
+                return false;
+            }
+        }
+        return true;
+    };
+
+    var pathTypes = {
+        polyline: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+                return _isValidPolyline(latlngs);
+            },
+            createPath: function createPath(options) {
+                return new L.Polyline([], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        multiPolyline: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+                if (!isArray(latlngs)) {
+                    return false;
+                }
+
+                for (var i in latlngs) {
+                    var polyline = latlngs[i];
+                    if (!_isValidPolyline(polyline)) {
+                        return false;
+                    }
+                }
+
+                return true;
+            },
+            createPath: function createPath(options) {
+                return new L.multiPolyline([[[0, 0], [1, 1]]], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        polygon: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+                return _isValidPolyline(latlngs);
+            },
+            createPath: function createPath(options) {
+                return new L.Polygon([], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        multiPolygon: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+
+                if (!isArray(latlngs)) {
+                    return false;
+                }
+
+                for (var i in latlngs) {
+                    var polyline = latlngs[i];
+                    if (!_isValidPolyline(polyline)) {
+                        return false;
+                    }
+                }
+
+                return true;
+            },
+            createPath: function createPath(options) {
+                return new L.MultiPolygon([[[0, 0], [1, 1], [0, 1]]], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        rectangle: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+
+                if (!isArray(latlngs) || latlngs.length !== 2) {
+                    return false;
+                }
+
+                for (var i in latlngs) {
+                    var point = latlngs[i];
+                    if (!isValidPoint(point)) {
+                        return false;
+                    }
+                }
+
+                return true;
+            },
+            createPath: function createPath(options) {
+                return new L.Rectangle([[0, 0], [1, 1]], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setBounds(new L.LatLngBounds(_convertToLeafletLatLngs(data.latlngs)));
+                _updatePathOptions(path, data);
+            }
+        },
+        circle: {
+            isValid: function isValid(pathData) {
+                var point = pathData.latlngs;
+                return isValidPoint(point) && isNumber(pathData.radius);
+            },
+            createPath: function createPath(options) {
+                return new L.Circle([0, 0], 1, options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLng(_convertToLeafletLatLng(data.latlngs));
+                if (isDefined(data.radius)) {
+                    path.setRadius(data.radius);
+                }
+                _updatePathOptions(path, data);
+            }
+        },
+        circleMarker: {
+            isValid: function isValid(pathData) {
+                var point = pathData.latlngs;
+                return isValidPoint(point) && isNumber(pathData.radius);
+            },
+            createPath: function createPath(options) {
+                return new L.CircleMarker([0, 0], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLng(_convertToLeafletLatLng(data.latlngs));
+                if (isDefined(data.radius)) {
+                    path.setRadius(data.radius);
+                }
+                _updatePathOptions(path, data);
+            }
+        }
+    };
+
+    var _getPathData = function _getPathData(path) {
+        var pathData = {};
+        if (path.latlngs) {
+            pathData.latlngs = path.latlngs;
+        }
+
+        if (path.radius) {
+            pathData.radius = path.radius;
+        }
+
+        return pathData;
+    };
+
+    return {
+        setPathOptions: function setPathOptions(leafletPath, pathType, data) {
+            if (!isDefined(pathType)) {
+                pathType = "polyline";
+            }
+            pathTypes[pathType].setPath(leafletPath, data);
+        },
+        createPath: function createPath(name, path, defaults) {
+            if (!isDefined(path.type)) {
+                path.type = "polyline";
+            }
+            var options = _getOptions(path, defaults);
+            var pathData = _getPathData(path);
+
+            if (!pathTypes[path.type].isValid(pathData)) {
+                $log.error("[AngularJS - Leaflet] Invalid data passed to the " + path.type + " path");
+                return;
+            }
+
+            return pathTypes[path.type].createPath(options);
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletWatchHelpers', function () {
+
+    var _maybe = function _maybe(scope, watchFunctionName, thingToWatchStr, watchOptions, initCb) {
+        var unWatch = scope[watchFunctionName](thingToWatchStr, function (newValue, oldValue) {
+            //make the unWatch function available to the callback as well.
+            initCb(newValue, oldValue, unWatch);
+            if (watchOptions.type === null) unWatch();
+        }, watchOptions.type === 'watchDeep');
+
+        return unWatch;
+    };
+
+    /*
+    @name: maybeWatch
+    @description: Utility to watch something once or forever.
+    @returns unWatch function
+    @param watchOptions - This object is used to determine the type of
+    watch used.
+    */
+    var _maybeWatch = function _maybeWatch(scope, thingToWatchStr, watchOptions, initCb) {
+        var watchMethod;
+
+        if (watchOptions.type === 'watchCollection') {
+            watchMethod = '$watchCollection';
+        } else {
+            watchMethod = '$watch';
+        }
+
+        return _maybe(scope, watchMethod, thingToWatchStr, watchOptions, initCb);
+    };
+
+    return {
+        maybeWatch: _maybeWatch
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletLogger', ["nemSimpleLogger", function (nemSimpleLogger) {
+  return nemSimpleLogger.spawn();
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('nominatimService', ["$q", "$http", "leafletHelpers", "leafletMapDefaults", function ($q, $http, leafletHelpers, leafletMapDefaults) {
+    var isDefined = leafletHelpers.isDefined;
+
+    return {
+        query: function query(address, mapId) {
+            var defaults = leafletMapDefaults.getDefaults(mapId);
+            var url = defaults.nominatim.server;
+            var df = $q.defer();
+
+            $http.get(url, { params: { format: 'json', limit: 1, q: address } }).success(function (data) {
+                if (data.length > 0 && isDefined(data[0].boundingbox)) {
+                    df.resolve(data[0]);
+                } else {
+                    df.reject('[Nominatim] Invalid address');
+                }
+            });
+
+            return df.promise;
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('bounds', ["leafletLogger", "$timeout", "$http", "leafletHelpers", "nominatimService", "leafletBoundsHelpers", function (leafletLogger, $timeout, $http, leafletHelpers, nominatimService, leafletBoundsHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet'],
+
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined;
+            var createLeafletBounds = leafletBoundsHelpers.createLeafletBounds;
+            var leafletScope = controller[0].getLeafletScope();
+            var mapController = controller[0];
+            var errorHeader = leafletHelpers.errorHeader + ' [Bounds] ';
+
+            var emptyBounds = function emptyBounds(bounds) {
+                return bounds._southWest.lat === 0 && bounds._southWest.lng === 0 && bounds._northEast.lat === 0 && bounds._northEast.lng === 0;
+            };
+
+            mapController.getMap().then(function (map) {
+                leafletScope.$on('boundsChanged', function (event) {
+                    var scope = event.currentScope;
+                    var bounds = map.getBounds();
+
+                    if (emptyBounds(bounds) || scope.settingBoundsFromScope) {
+                        return;
+                    }
+                    scope.settingBoundsFromLeaflet = true;
+                    var newScopeBounds = {
+                        northEast: {
+                            lat: bounds._northEast.lat,
+                            lng: bounds._northEast.lng
+                        },
+                        southWest: {
+                            lat: bounds._southWest.lat,
+                            lng: bounds._southWest.lng
+                        },
+                        options: bounds.options
+                    };
+                    if (!angular.equals(scope.bounds, newScopeBounds)) {
+                        scope.bounds = newScopeBounds;
+                    }
+                    $timeout(function () {
+                        scope.settingBoundsFromLeaflet = false;
+                    });
+                });
+
+                var lastNominatimQuery;
+                leafletScope.$watch('bounds', function (bounds) {
+                    if (scope.settingBoundsFromLeaflet) return;
+                    if (isDefined(bounds.address) && bounds.address !== lastNominatimQuery) {
+                        scope.settingBoundsFromScope = true;
+                        nominatimService.query(bounds.address, attrs.id).then(function (data) {
+                            var b = data.boundingbox;
+                            var newBounds = [[b[0], b[2]], [b[1], b[3]]];
+                            map.fitBounds(newBounds);
+                        }, function (errMsg) {
+                            $log.error(errorHeader + ' ' + errMsg + '.');
+                        });
+                        lastNominatimQuery = bounds.address;
+                        $timeout(function () {
+                            scope.settingBoundsFromScope = false;
+                        });
+                        return;
+                    }
+
+                    var leafletBounds = createLeafletBounds(bounds);
+                    if (leafletBounds && !map.getBounds().equals(leafletBounds)) {
+                        scope.settingBoundsFromScope = true;
+                        map.fitBounds(leafletBounds, bounds.options);
+                        $timeout(function () {
+                            scope.settingBoundsFromScope = false;
+                        });
+                    }
+                }, true);
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+var centerDirectiveTypes = ['center', 'lfCenter'],
+    centerDirectives = {};
+
+centerDirectiveTypes.forEach(function (directiveName) {
+    centerDirectives[directiveName] = ['leafletLogger', '$q', '$location', '$timeout', 'leafletMapDefaults', 'leafletHelpers', 'leafletBoundsHelpers', 'leafletMapEvents', function (leafletLogger, $q, $location, $timeout, leafletMapDefaults, leafletHelpers, leafletBoundsHelpers, leafletMapEvents) {
+
+        var isDefined = leafletHelpers.isDefined,
+            isNumber = leafletHelpers.isNumber,
+            isSameCenterOnMap = leafletHelpers.isSameCenterOnMap,
+            safeApply = leafletHelpers.safeApply,
+            isValidCenter = leafletHelpers.isValidCenter,
+            isValidBounds = leafletBoundsHelpers.isValidBounds,
+            isUndefinedOrEmpty = leafletHelpers.isUndefinedOrEmpty,
+            errorHeader = leafletHelpers.errorHeader,
+            $log = leafletLogger;
+
+        var shouldInitializeMapWithBounds = function shouldInitializeMapWithBounds(bounds, center) {
+            return isDefined(bounds) && isValidBounds(bounds) && isUndefinedOrEmpty(center);
+        };
+
+        var _leafletCenter;
+        return {
+            restrict: "A",
+            scope: false,
+            replace: false,
+            require: 'leaflet',
+            controller: function controller() {
+                _leafletCenter = $q.defer();
+                this.getCenter = function () {
+                    return _leafletCenter.promise;
+                };
+            },
+            link: function link(scope, element, attrs, controller) {
+                var leafletScope = controller.getLeafletScope(),
+                    centerModel = leafletScope[directiveName];
+
+                controller.getMap().then(function (map) {
+                    var defaults = leafletMapDefaults.getDefaults(attrs.id);
+
+                    if (attrs[directiveName].search("-") !== -1) {
+                        $log.error(errorHeader + ' The "center" variable can\'t use a "-" on its key name: "' + attrs[directiveName] + '".');
+                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                        return;
+                    } else if (shouldInitializeMapWithBounds(leafletScope.bounds, centerModel)) {
+                        map.fitBounds(leafletBoundsHelpers.createLeafletBounds(leafletScope.bounds), leafletScope.bounds.options);
+                        centerModel = map.getCenter();
+                        safeApply(leafletScope, function (scope) {
+                            angular.extend(scope[directiveName], {
+                                lat: map.getCenter().lat,
+                                lng: map.getCenter().lng,
+                                zoom: map.getZoom(),
+                                autoDiscover: false
+                            });
+                        });
+                        safeApply(leafletScope, function (scope) {
+                            var mapBounds = map.getBounds();
+                            scope.bounds = {
+                                northEast: {
+                                    lat: mapBounds._northEast.lat,
+                                    lng: mapBounds._northEast.lng
+                                },
+                                southWest: {
+                                    lat: mapBounds._southWest.lat,
+                                    lng: mapBounds._southWest.lng
+                                }
+                            };
+                        });
+                    } else if (!isDefined(centerModel)) {
+                        $log.error(errorHeader + ' The "center" property is not defined in the main scope');
+                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                        return;
+                    } else if (!(isDefined(centerModel.lat) && isDefined(centerModel.lng)) && !isDefined(centerModel.autoDiscover)) {
+                        angular.copy(defaults.center, centerModel);
+                    }
+
+                    var urlCenterHash, mapReady;
+                    if (attrs.urlHashCenter === "yes") {
+                        var extractCenterFromUrl = function extractCenterFromUrl() {
+                            var search = $location.search();
+                            var centerParam;
+                            var centerKey = attrs.urlHashParam ? attrs.urlHashParam : 'c';
+                            if (isDefined(search[centerKey])) {
+                                var cParam = search[centerKey].split(":");
+                                if (cParam.length === 3) {
+                                    centerParam = {
+                                        lat: parseFloat(cParam[0]),
+                                        lng: parseFloat(cParam[1]),
+                                        zoom: parseInt(cParam[2], 10)
+                                    };
+                                }
+                            }
+                            return centerParam;
+                        };
+                        urlCenterHash = extractCenterFromUrl();
+
+                        leafletScope.$on('$locationChangeSuccess', function (event) {
+                            var scope = event.currentScope;
+                            //$log.debug("updated location...");
+                            var urlCenter = extractCenterFromUrl();
+                            if (isDefined(urlCenter) && !isSameCenterOnMap(urlCenter, map)) {
+                                //$log.debug("updating center model...", urlCenter);
+                                angular.extend(scope[directiveName], {
+                                    lat: urlCenter.lat,
+                                    lng: urlCenter.lng,
+                                    zoom: urlCenter.zoom
+                                });
+                            }
+                        });
+                    }
+
+                    leafletScope.$watch(directiveName, function (center) {
+                        if (leafletScope.settingCenterFromLeaflet) return;
+                        //$log.debug("updated center model...");
+                        // The center from the URL has priority
+                        if (isDefined(urlCenterHash)) {
+                            angular.copy(urlCenterHash, center);
+                            urlCenterHash = undefined;
+                        }
+
+                        if (!isValidCenter(center) && center.autoDiscover !== true) {
+                            $log.warn(errorHeader + " invalid 'center'");
+                            //map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                            return;
+                        }
+
+                        if (center.autoDiscover === true) {
+                            if (!isNumber(center.zoom)) {
+                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                            }
+                            if (isNumber(center.zoom) && center.zoom > defaults.center.zoom) {
+                                map.locate({
+                                    setView: true,
+                                    maxZoom: center.zoom
+                                });
+                            } else if (isDefined(defaults.maxZoom)) {
+                                map.locate({
+                                    setView: true,
+                                    maxZoom: defaults.maxZoom
+                                });
+                            } else {
+                                map.locate({
+                                    setView: true
+                                });
+                            }
+                            return;
+                        }
+
+                        if (mapReady && isSameCenterOnMap(center, map)) {
+                            //$log.debug("no need to update map again.");
+                            return;
+                        }
+
+                        //$log.debug("updating map center...", center);
+                        leafletScope.settingCenterFromScope = true;
+                        map.setView([center.lat, center.lng], center.zoom);
+                        leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                        $timeout(function () {
+                            leafletScope.settingCenterFromScope = false;
+                            //$log.debug("allow center scope updates");
+                        });
+                    }, true);
+
+                    map.whenReady(function () {
+                        mapReady = true;
+                    });
+
+                    map.on('moveend', function () /* event */{
+                        // Resolve the center after the first map position
+                        _leafletCenter.resolve();
+                        leafletMapEvents.notifyCenterUrlHashChanged(leafletScope, map, attrs, $location.search());
+                        //$log.debug("updated center on map...");
+                        if (isSameCenterOnMap(centerModel, map) || leafletScope.settingCenterFromScope) {
+                            //$log.debug("same center in model, no need to update again.");
+                            return;
+                        }
+                        leafletScope.settingCenterFromLeaflet = true;
+                        safeApply(leafletScope, function (scope) {
+                            if (!leafletScope.settingCenterFromScope) {
+                                //$log.debug("updating center model...", map.getCenter(), map.getZoom());
+                                angular.extend(scope[directiveName], {
+                                    lat: map.getCenter().lat,
+                                    lng: map.getCenter().lng,
+                                    zoom: map.getZoom(),
+                                    autoDiscover: false
+                                });
+                            }
+                            leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                            $timeout(function () {
+                                leafletScope.settingCenterFromLeaflet = false;
+                            });
+                        });
+                    });
+
+                    if (centerModel.autoDiscover === true) {
+                        map.on('locationerror', function () {
+                            $log.warn(errorHeader + " The Geolocation API is unauthorized on this page.");
+                            if (isValidCenter(centerModel)) {
+                                map.setView([centerModel.lat, centerModel.lng], centerModel.zoom);
+                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                            } else {
+                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                            }
+                        });
+                    }
+                });
+            }
+        };
+    }];
+});
+
+centerDirectiveTypes.forEach(function (dirType) {
+    angular.module('ui-leaflet').directive(dirType, centerDirectives[dirType]);
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('controls', ["leafletLogger", "leafletHelpers", "leafletControlHelpers", function (leafletLogger, leafletHelpers, leafletControlHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: '?^leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            if (!controller) {
+                return;
+            }
+
+            var createControl = leafletControlHelpers.createControl;
+            var isValidControlType = leafletControlHelpers.isValidControlType;
+            var leafletScope = controller.getLeafletScope();
+            var isDefined = leafletHelpers.isDefined;
+            var isArray = leafletHelpers.isArray;
+            var leafletControls = {};
+            var errorHeader = leafletHelpers.errorHeader + ' [Controls] ';
+
+            scope.$on('$destroy', function () {
+                leafletControlHelpers.destroyMapLayersControl(scope.mapId);
+            });
+
+            controller.getMap().then(function (map) {
+
+                leafletScope.$watchCollection('controls', function (newControls) {
+
+                    // Delete controls from the array
+                    for (var name in leafletControls) {
+                        if (!isDefined(newControls[name])) {
+                            if (map.hasControl(leafletControls[name])) {
+                                map.removeControl(leafletControls[name]);
+                            }
+                            delete leafletControls[name];
+                        }
+                    }
+
+                    for (var newName in newControls) {
+                        var control;
+
+                        var controlType = isDefined(newControls[newName].type) ? newControls[newName].type : newName;
+
+                        if (!isValidControlType(controlType)) {
+                            $log.error(errorHeader + ' Invalid control type: ' + controlType + '.');
+                            return;
+                        }
+
+                        if (controlType !== 'custom') {
+                            control = createControl(controlType, newControls[newName]);
+                            map.addControl(control);
+                            leafletControls[newName] = control;
+                        } else {
+                            var customControlValue = newControls[newName];
+                            if (isArray(customControlValue)) {
+                                for (var i = 0; i < customControlValue.length; i++) {
+                                    var customControl = customControlValue[i];
+                                    map.addControl(customControl);
+                                    leafletControls[newName] = !isDefined(leafletControls[newName]) ? [customControl] : leafletControls[newName].concat([customControl]);
+                                }
+                            } else {
+                                map.addControl(customControlValue);
+                                leafletControls[newName] = customControlValue;
+                            }
+                        }
+                    }
+                });
+            });
+        }
+    };
+}]);
+
+"use strict";
+
+angular.module('ui-leaflet').directive("decorations", ["leafletLogger", "leafletHelpers", function (leafletLogger, leafletHelpers) {
+	var $log = leafletLogger;
+	return {
+		restrict: "A",
+		scope: false,
+		replace: false,
+		require: 'leaflet',
+
+		link: function link(scope, element, attrs, controller) {
+			var leafletScope = controller.getLeafletScope(),
+			    PolylineDecoratorPlugin = leafletHelpers.PolylineDecoratorPlugin,
+			    isDefined = leafletHelpers.isDefined,
+			    leafletDecorations = {};
+
+			/* Creates an "empty" decoration with a set of coordinates, but no pattern. */
+			function createDecoration(options) {
+				if (isDefined(options) && isDefined(options.coordinates)) {
+					if (!PolylineDecoratorPlugin.isLoaded()) {
+						$log.error('[AngularJS - Leaflet] The PolylineDecorator Plugin is not loaded.');
+					}
+				}
+
+				return L.polylineDecorator(options.coordinates);
+			}
+
+			/* Updates the path and the patterns for the provided decoration, and returns the decoration. */
+			function setDecorationOptions(decoration, options) {
+				if (isDefined(decoration) && isDefined(options)) {
+					if (isDefined(options.coordinates) && isDefined(options.patterns)) {
+						decoration.setPaths(options.coordinates);
+						decoration.setPatterns(options.patterns);
+						return decoration;
+					}
+				}
+			}
+
+			controller.getMap().then(function (map) {
+				leafletScope.$watch("decorations", function (newDecorations) {
+					for (var name in leafletDecorations) {
+						if (!isDefined(newDecorations[name]) || !angular.equals(newDecorations[name], leafletDecorations)) {
+							map.removeLayer(leafletDecorations[name]);
+							delete leafletDecorations[name];
+						}
+					}
+
+					for (var newName in newDecorations) {
+						var decorationData = newDecorations[newName],
+						    newDecoration = createDecoration(decorationData);
+
+						if (isDefined(newDecoration)) {
+							leafletDecorations[newName] = newDecoration;
+							map.addLayer(newDecoration);
+							setDecorationOptions(newDecoration, decorationData);
+						}
+					}
+				}, true);
+			});
+		}
+	};
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('eventBroadcast', ["leafletLogger", "$rootScope", "leafletHelpers", "leafletMapEvents", "leafletIterators", function (leafletLogger, $rootScope, leafletHelpers, leafletMapEvents, leafletIterators) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var isObject = leafletHelpers.isObject,
+                isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                eventBroadcast = leafletScope.eventBroadcast,
+                availableMapEvents = leafletMapEvents.getAvailableMapEvents(),
+                addEvents = leafletMapEvents.addEvents;
+
+            controller.getMap().then(function (map) {
+
+                var mapEvents = [],
+                    logic = "broadcast";
+
+                // We have a possible valid object
+                if (!isDefined(eventBroadcast.map)) {
+                    // We do not have events enable/disable do we do nothing (all enabled by default)
+                    mapEvents = availableMapEvents;
+                } else if (!isObject(eventBroadcast.map)) {
+                    // Not a valid object
+                    $log.warn("[AngularJS - Leaflet] event-broadcast.map must be an object check your model.");
+                } else {
+                    // We have a possible valid map object
+                    // Event propadation logic
+                    if (eventBroadcast.map.logic !== "emit" && eventBroadcast.map.logic !== "broadcast") {
+                        // This is an error
+                        $log.warn("[AngularJS - Leaflet] Available event propagation logic are: 'emit' or 'broadcast'.");
+                    } else {
+                        logic = eventBroadcast.map.logic;
+                    }
+
+                    if (!(isObject(eventBroadcast.map.enable) && eventBroadcast.map.enable.length >= 0)) {
+                        $log.warn("[AngularJS - Leaflet] event-broadcast.map.enable must be an object check your model.");
+                    } else {
+                        // Enable events
+                        leafletIterators.each(eventBroadcast.map.enable, function (eventName) {
+                            // Do we have already the event enabled?
+                            if (mapEvents.indexOf(eventName) === -1 && availableMapEvents.indexOf(eventName) !== -1) {
+                                mapEvents.push(eventName);
+                            }
+                        });
+                    }
+                }
+                // as long as the map is removed in the root leaflet directive we
+                // do not need ot clean up the events as leaflet does it itself
+                addEvents(map, attrs.id, mapEvents, "eventName", leafletScope, logic);
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('geojson', ["$timeout", "leafletLogger", "leafletData", "leafletHelpers", "leafletWatchHelpers", "leafletDirectiveControlsHelpers", "leafletIterators", "leafletGeoJsonEvents", function ($timeout, leafletLogger, leafletData, leafletHelpers, leafletWatchHelpers, leafletDirectiveControlsHelpers, leafletIterators, leafletGeoJsonEvents) {
+    var _maybeWatch = leafletWatchHelpers.maybeWatch,
+        _defaultWatchOptions = leafletHelpers.watchOptions,
+        _extendDirectiveControls = leafletDirectiveControlsHelpers.extend,
+        hlp = leafletHelpers,
+        $it = leafletIterators,
+        watchTrap = { changeFromDirective: false };
+    // $log = leafletLogger;
+
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                leafletGeoJSON = {},
+                _hasSetLeafletData = false;
+
+            controller.getMap().then(function (map) {
+                var watchOptions;
+                if (leafletScope.watchOptions && leafletScope.watchOptions.geojson) {
+                    watchOptions = leafletScope.watchOptions.geojson;
+                } else {
+                    watchOptions = _defaultWatchOptions;
+                }
+
+                var _hookUpEvents = function _hookUpEvents(geojson, maybeName) {
+                    var onEachFeature;
+
+                    if (angular.isFunction(geojson.onEachFeature)) {
+                        onEachFeature = geojson.onEachFeature;
+                    } else {
+                        onEachFeature = function onEachFeature(feature, layer) {
+                            if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(feature.properties.description)) {
+                                layer.bindLabel(feature.properties.description);
+                            }
+
+                            leafletGeoJsonEvents.bindEvents(attrs.id, layer, null, feature, leafletScope, maybeName, { resetStyleOnMouseout: geojson.resetStyleOnMouseout,
+                                mapId: attrs.id });
+                        };
+                    }
+                    return onEachFeature;
+                };
+
+                var isNested = hlp.isDefined(attrs.geojsonNested) && hlp.isTruthy(attrs.geojsonNested);
+
+                var _clean = function _clean() {
+                    if (!leafletGeoJSON) return;
+                    var _remove = function _remove(lObject) {
+                        if (isDefined(lObject) && map.hasLayer(lObject)) {
+                            map.removeLayer(lObject);
+                        }
+                    };
+                    if (isNested) {
+                        $it.each(leafletGeoJSON, function (lObject) {
+                            _remove(lObject);
+                        });
+                        return;
+                    }
+                    _remove(leafletGeoJSON);
+                };
+
+                var _addGeojson = function _addGeojson(geojson, maybeName) {
+
+                    if (!(isDefined(geojson) && isDefined(geojson.data))) {
+                        return;
+                    }
+                    var onEachFeature = _hookUpEvents(geojson, maybeName);
+
+                    if (!isDefined(geojson.options)) {
+                        hlp.modelChangeInDirective(watchTrap, "changeFromDirective", function () {
+                            geojson.options = {
+                                style: geojson.style,
+                                filter: geojson.filter,
+                                onEachFeature: onEachFeature,
+                                pointToLayer: geojson.pointToLayer
+                            };
+                        });
+                    }
+
+                    var lObject = L.geoJson(geojson.data, geojson.options);
+
+                    if (maybeName && hlp.isString(maybeName)) {
+                        leafletGeoJSON[maybeName] = lObject;
+                    } else {
+                        leafletGeoJSON = lObject;
+                    }
+
+                    lObject.addTo(map);
+
+                    if (!_hasSetLeafletData) {
+                        //only do this once and play with the same ref forever
+                        _hasSetLeafletData = true;
+                        leafletData.setGeoJSON(leafletGeoJSON, attrs.id);
+                    }
+                };
+
+                var _create = function _create(model) {
+                    _clean();
+                    if (isNested) {
+                        if (!model || !Object.keys(model).length) return;
+                        $it.each(model, function (m, name) {
+                            //name could be layerName and or groupName
+                            //for now it is not tied to a layer
+                            _addGeojson(m, name);
+                        });
+                        return;
+                    }
+                    _addGeojson(model);
+                };
+
+                _extendDirectiveControls(attrs.id, 'geojson', _create, _clean);
+
+                _maybeWatch(leafletScope, 'geojson', watchOptions, function (geojson) {
+                    if (watchTrap.changeFromDirective) return;
+                    _create(geojson);
+                });
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('layercontrol', ["$filter", "leafletLogger", "leafletData", "leafletHelpers", function ($filter, leafletLogger, leafletData, leafletHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "E",
+        scope: {
+            icons: '=?',
+            autoHideOpacity: '=?', // Hide other opacity controls when one is activated.
+            showGroups: '=?', // Hide other opacity controls when one is activated.
+            title: '@',
+            baseTitle: '@',
+            overlaysTitle: '@'
+        },
+        replace: true,
+        transclude: false,
+        require: '^leaflet',
+        controller: ["$scope", "$element", "$sce", function controller($scope, $element, $sce) {
+            $log.debug('[Angular Directive - Layers] layers', $scope, $element);
+            var safeApply = leafletHelpers.safeApply,
+                isDefined = leafletHelpers.isDefined;
+            angular.extend($scope, {
+                baselayer: '',
+                oldGroup: '',
+                layerProperties: {},
+                groupProperties: {},
+                rangeIsSupported: leafletHelpers.rangeIsSupported(),
+                changeBaseLayer: function changeBaseLayer(key, e) {
+                    leafletHelpers.safeApply($scope, function (scp) {
+                        scp.baselayer = key;
+                        leafletData.getMap().then(function (map) {
+                            leafletData.getLayers().then(function (leafletLayers) {
+                                if (map.hasLayer(leafletLayers.baselayers[key])) {
+                                    return;
+                                }
+                                for (var i in scp.layers.baselayers) {
+                                    scp.layers.baselayers[i].icon = scp.icons.unradio;
+                                    if (map.hasLayer(leafletLayers.baselayers[i])) {
+                                        map.removeLayer(leafletLayers.baselayers[i]);
+                                    }
+                                }
+                                map.addLayer(leafletLayers.baselayers[key]);
+                                scp.layers.baselayers[key].icon = $scope.icons.radio;
+                            });
+                        });
+                    });
+                    e.preventDefault();
+                },
+                moveLayer: function moveLayer(ly, newIndex, e) {
+                    var delta = Object.keys($scope.layers.baselayers).length;
+                    if (newIndex >= 1 + delta && newIndex <= $scope.overlaysArray.length + delta) {
+                        var oldLy;
+                        for (var key in $scope.layers.overlays) {
+                            if ($scope.layers.overlays[key].index === newIndex) {
+                                oldLy = $scope.layers.overlays[key];
+                                break;
+                            }
+                        }
+                        if (oldLy) {
+                            safeApply($scope, function () {
+                                oldLy.index = ly.index;
+                                ly.index = newIndex;
+                            });
+                        }
+                    }
+                    e.stopPropagation();
+                    e.preventDefault();
+                },
+                initIndex: function initIndex(layer, idx) {
+                    var delta = Object.keys($scope.layers.baselayers).length;
+                    layer.index = isDefined(layer.index) ? layer.index : idx + delta + 1;
+                },
+                initGroup: function initGroup(groupName) {
+                    $scope.groupProperties[groupName] = $scope.groupProperties[groupName] ? $scope.groupProperties[groupName] : {};
+                },
+                toggleOpacity: function toggleOpacity(e, layer) {
+                    if (layer.visible) {
+                        if ($scope.autoHideOpacity && !$scope.layerProperties[layer.name].opacityControl) {
+                            for (var k in $scope.layerProperties) {
+                                $scope.layerProperties[k].opacityControl = false;
+                            }
+                        }
+                        $scope.layerProperties[layer.name].opacityControl = !$scope.layerProperties[layer.name].opacityControl;
+                    }
+                    e.stopPropagation();
+                    e.preventDefault();
+                },
+                toggleLegend: function toggleLegend(layer) {
+                    $scope.layerProperties[layer.name].showLegend = !$scope.layerProperties[layer.name].showLegend;
+                },
+                showLegend: function showLegend(layer) {
+                    return layer.legend && $scope.layerProperties[layer.name].showLegend;
+                },
+                unsafeHTML: function unsafeHTML(html) {
+                    return $sce.trustAsHtml(html);
+                },
+                getOpacityIcon: function getOpacityIcon(layer) {
+                    return layer.visible && $scope.layerProperties[layer.name].opacityControl ? $scope.icons.close : $scope.icons.open;
+                },
+                getGroupIcon: function getGroupIcon(group) {
+                    return group.visible ? $scope.icons.check : $scope.icons.uncheck;
+                },
+                changeGroupVisibility: function changeGroupVisibility(groupName) {
+                    if (!isDefined($scope.groupProperties[groupName])) {
+                        return;
+                    }
+                    var visible = $scope.groupProperties[groupName].visible;
+                    for (var k in $scope.layers.overlays) {
+                        var layer = $scope.layers.overlays[k];
+                        if (layer.group === groupName) {
+                            layer.visible = visible;
+                        }
+                    }
+                }
+            });
+
+            var div = $element.get(0);
+            if (!L.Browser.touch) {
+                L.DomEvent.disableClickPropagation(div);
+                L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
+            } else {
+                L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
+            }
+        }],
+        template: '<div class="angular-leaflet-control-layers" ng-show="overlaysArray.length">' + '<h4 ng-if="title">{{ title }}</h4>' + '<div class="lf-baselayers">' + '<h5 class="lf-title" ng-if="baseTitle">{{ baseTitle }}</h5>' + '<div class="lf-row" ng-repeat="(key, layer) in baselayersArray">' + '<label class="lf-icon-bl" ng-click="changeBaseLayer(key, $event)">' + '<input class="leaflet-control-layers-selector" type="radio" name="lf-radio" ' + 'ng-show="false" ng-checked="baselayer === key" ng-value="key" /> ' + '<i class="lf-icon lf-icon-radio" ng-class="layer.icon"></i>' + '<div class="lf-text">{{layer.name}}</div>' + '</label>' + '</div>' + '</div>' + '<div class="lf-overlays">' + '<h5 class="lf-title" ng-if="overlaysTitle">{{ overlaysTitle }}</h5>' + '<div class="lf-container">' + '<div class="lf-row" ng-repeat="layer in (o = (overlaysArray | orderBy:\'index\':order))" ng-init="initIndex(layer, $index)">' + '<label class="lf-icon-ol-group" ng-if="showGroups &amp;&amp; layer.group &amp;&amp; layer.group != o[$index-1].group">' + '<input class="lf-control-layers-selector" type="checkbox" ng-show="false" ' + 'ng-change="changeGroupVisibility(layer.group)" ng-model="groupProperties[layer.group].visible"/> ' + '<i class="lf-icon lf-icon-check" ng-class="getGroupIcon(groupProperties[layer.group])"></i>' + '<div class="lf-text">{{ layer.group }}</div>' + '</label>' + '<label class="lf-icon-ol">' + '<input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-model="layer.visible"/> ' + '<i class="lf-icon lf-icon-check" ng-class="layer.icon"></i>' + '<div class="lf-text">{{layer.name}}</div>' + '</label>' + '<div class="lf-icons">' + '<i class="lf-icon lf-up" ng-class="icons.up" ng-click="moveLayer(layer, layer.index - orderNumber, $event)"></i> ' + '<i class="lf-icon lf-down" ng-class="icons.down" ng-click="moveLayer(layer, layer.index + orderNumber, $event)"></i> ' + '<i class="lf-icon lf-toggle-legend" ng-class="icons.toggleLegend" ng-if="layer.legend" ng-click="toggleLegend(layer)"></i> ' + '<i class="lf-icon lf-open" ng-class="getOpacityIcon(layer)" ng-click="toggleOpacity($event, layer)"></i>' + '</div>' + '<div class="lf-legend" ng-if="showLegend(layer)" ng-bind-html="unsafeHTML(layer.legend)"></div>' + '<div class="lf-opacity clearfix" ng-if="layer.visible &amp;&amp; layerProperties[layer.name].opacityControl">' + '<label ng-if="rangeIsSupported" class="pull-left" style="width: 50%">0</label>' + '<label ng-if="rangeIsSupported" class="pull-left text-right" style="width: 50%">100</label>' + '<input ng-if="rangeIsSupported" class="clearfix" type="range" min="0" max="1" step="0.05" ' + 'class="lf-opacity-control" ng-model="layerProperties[layer.name].layerOptions.opacity"/>' + '<h6 ng-if="!rangeIsSupported">Range is not supported in this browser</h6>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>',
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                layers = leafletScope.layers;
+
+            scope.$watch('icons', function () {
+                var defaultIcons = {
+                    uncheck: 'fa fa-square-o',
+                    check: 'fa fa-check-square-o',
+                    radio: 'fa fa-dot-circle-o',
+                    unradio: 'fa fa-circle-o',
+                    up: 'fa fa-angle-up',
+                    down: 'fa fa-angle-down',
+                    open: 'fa fa-angle-double-down',
+                    close: 'fa fa-angle-double-up',
+                    toggleLegend: 'fa fa-pencil-square-o'
+                };
+                if (isDefined(scope.icons)) {
+                    angular.extend(defaultIcons, scope.icons);
+                    angular.extend(scope.icons, defaultIcons);
+                } else {
+                    scope.icons = defaultIcons;
+                }
+            });
+
+            // Setting layer stack order.
+            attrs.order = isDefined(attrs.order) && (attrs.order === 'normal' || attrs.order === 'reverse') ? attrs.order : 'normal';
+            scope.order = attrs.order === 'normal';
+            scope.orderNumber = attrs.order === 'normal' ? -1 : 1;
+
+            scope.layers = layers;
+            controller.getMap().then(function (map) {
+                leafletScope.$watch('layers.baselayers', function (newBaseLayers) {
+                    var baselayersArray = {};
+                    leafletData.getLayers().then(function (leafletLayers) {
+                        var key;
+                        for (key in newBaseLayers) {
+                            var layer = newBaseLayers[key];
+                            layer.icon = scope.icons[map.hasLayer(leafletLayers.baselayers[key]) ? 'radio' : 'unradio'];
+                            baselayersArray[key] = layer;
+                        }
+                        scope.baselayersArray = baselayersArray;
+                    });
+                });
+
+                leafletScope.$watch('layers.overlays', function (newOverlayLayers) {
+                    var overlaysArray = [];
+                    var groupVisibleCount = {};
+                    leafletData.getLayers().then(function () {
+                        var key;
+                        for (key in newOverlayLayers) {
+                            var layer = newOverlayLayers[key];
+                            layer.icon = scope.icons[layer.visible ? 'check' : 'uncheck'];
+                            overlaysArray.push(layer);
+
+                            if (!isDefined(scope.layerProperties[layer.name])) {
+                                if (isDefined(layer.layerOptions.opacity)) {
+                                    layer.layerOptions.opacity = 1;
+                                }
+                                scope.layerProperties[layer.name] = {
+                                    opacityControl: false,
+                                    showLegend: true,
+                                    layerOptions: layer.layerOptions
+                                };
+                            }
+                            if (isDefined(layer.group)) {
+                                if (!isDefined(scope.groupProperties[layer.group])) {
+                                    scope.groupProperties[layer.group] = {
+                                        visible: false
+                                    };
+                                }
+                                groupVisibleCount[layer.group] = isDefined(groupVisibleCount[layer.group]) ? groupVisibleCount[layer.group] : {
+                                    count: 0,
+                                    visibles: 0
+                                };
+                                groupVisibleCount[layer.group].count++;
+                                if (layer.visible) {
+                                    groupVisibleCount[layer.group].visibles++;
+                                }
+                            }
+                            /*
+                            if(isDefined(layer.index) && leafletLayers.overlays[key].setZIndex) {
+                                leafletLayers.overlays[key].setZIndex(newOverlayLayers[key].index);
+                            }
+                            */
+                        }
+
+                        for (key in groupVisibleCount) {
+                            scope.groupProperties[key].visible = groupVisibleCount[key].visibles === groupVisibleCount[key].count;
+                        }
+                        scope.overlaysArray = overlaysArray;
+                    });
+                }, true);
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('layers', ["leafletLogger", "$q", "leafletData", "leafletHelpers", "leafletLayerHelpers", "leafletControlHelpers", function (leafletLogger, $q, leafletData, leafletHelpers, leafletLayerHelpers, leafletControlHelpers) {
+    // var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+        controller: ["$scope", function controller($scope) {
+            $scope._leafletLayers = $q.defer();
+            this.getLayers = function () {
+                return $scope._leafletLayers.promise;
+            };
+        }],
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletLayers = {},
+                leafletScope = controller.getLeafletScope(),
+                layers = leafletScope.layers,
+                createLayer = leafletLayerHelpers.createLayer,
+                safeAddLayer = leafletLayerHelpers.safeAddLayer,
+                safeRemoveLayer = leafletLayerHelpers.safeRemoveLayer,
+                changeOpacityListener = leafletLayerHelpers.changeOpacityListener,
+                updateLayersControl = leafletControlHelpers.updateLayersControl,
+                isLayersControlVisible = false;
+
+            scope.$on('$destroy', function () {
+                leafletControlHelpers.destroyMapLayersControl(scope.mapId);
+            });
+
+            controller.getMap().then(function (map) {
+
+                // We have baselayers to add to the map
+                scope._leafletLayers.resolve(leafletLayers);
+                leafletData.setLayers(leafletLayers, attrs.id);
+
+                leafletLayers.baselayers = {};
+                leafletLayers.overlays = {};
+
+                var mapId = attrs.id;
+
+                // Setup all baselayers definitions
+                var oneVisibleLayer = false;
+                for (var layerName in layers.baselayers) {
+                    var newBaseLayer = createLayer(layers.baselayers[layerName]);
+                    if (!isDefined(newBaseLayer)) {
+                        delete layers.baselayers[layerName];
+                        continue;
+                    }
+                    leafletLayers.baselayers[layerName] = newBaseLayer;
+                    // Only add the visible layer to the map, layer control manages the addition to the map
+                    // of layers in its control
+                    if (layers.baselayers[layerName].top === true) {
+                        safeAddLayer(map, leafletLayers.baselayers[layerName]);
+                        oneVisibleLayer = true;
+                    }
+                }
+
+                // If there is no visible layer add first to the map
+                if (!oneVisibleLayer && Object.keys(leafletLayers.baselayers).length > 0) {
+                    safeAddLayer(map, leafletLayers.baselayers[Object.keys(layers.baselayers)[0]]);
+                }
+
+                // Setup the Overlays
+                for (layerName in layers.overlays) {
+                    if (layers.overlays[layerName].type === 'cartodb') {}
+                    var newOverlayLayer = createLayer(layers.overlays[layerName]);
+                    if (!isDefined(newOverlayLayer)) {
+                        delete layers.overlays[layerName];
+                        continue;
+                    }
+                    leafletLayers.overlays[layerName] = newOverlayLayer;
+                    // Only add the visible overlays to the map
+                    if (layers.overlays[layerName].visible === true) {
+                        safeAddLayer(map, leafletLayers.overlays[layerName]);
+                    }
+                }
+
+                // Watch for the base layers
+                leafletScope.$watch('layers.baselayers', function (newBaseLayers, oldBaseLayers) {
+                    if (angular.equals(newBaseLayers, oldBaseLayers)) {
+                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);
+                        return true;
+                    }
+                    // Delete layers from the array
+                    for (var name in leafletLayers.baselayers) {
+                        if (!isDefined(newBaseLayers[name]) || newBaseLayers[name].doRefresh) {
+                            // Remove from the map if it's on it
+                            if (map.hasLayer(leafletLayers.baselayers[name])) {
+                                map.removeLayer(leafletLayers.baselayers[name]);
+                            }
+                            delete leafletLayers.baselayers[name];
+
+                            if (newBaseLayers[name] && newBaseLayers[name].doRefresh) {
+                                newBaseLayers[name].doRefresh = false;
+                            }
+                        }
+                    }
+                    // add new layers
+                    for (var newName in newBaseLayers) {
+                        if (!isDefined(leafletLayers.baselayers[newName])) {
+                            var testBaseLayer = createLayer(newBaseLayers[newName]);
+                            if (isDefined(testBaseLayer)) {
+                                leafletLayers.baselayers[newName] = testBaseLayer;
+                                // Only add the visible layer to the map
+                                if (newBaseLayers[newName].top === true) {
+                                    safeAddLayer(map, leafletLayers.baselayers[newName]);
+                                }
+                            }
+                        } else {
+                            if (newBaseLayers[newName].top === true && !map.hasLayer(leafletLayers.baselayers[newName])) {
+                                safeAddLayer(map, leafletLayers.baselayers[newName]);
+                            } else if (newBaseLayers[newName].top === false && map.hasLayer(leafletLayers.baselayers[newName])) {
+                                map.removeLayer(leafletLayers.baselayers[newName]);
+                            }
+                        }
+                    }
+
+                    //we have layers, so we need to make, at least, one active
+                    var found = false;
+                    // search for an active layer
+                    for (var key in leafletLayers.baselayers) {
+                        if (map.hasLayer(leafletLayers.baselayers[key])) {
+                            found = true;
+                            break;
+                        }
+                    }
+                    // If there is no active layer make one active
+                    if (!found && Object.keys(leafletLayers.baselayers).length > 0) {
+                        safeAddLayer(map, leafletLayers.baselayers[Object.keys(leafletLayers.baselayers)[0]]);
+                    }
+
+                    // Only show the layers switch selector control if we have more than one baselayer + overlay
+                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);
+                }, true);
+
+                // Watch for the overlay layers
+                leafletScope.$watch('layers.overlays', function (newOverlayLayers, oldOverlayLayers) {
+                    if (angular.equals(newOverlayLayers, oldOverlayLayers)) {
+                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);
+                        return true;
+                    }
+
+                    // Delete layers from the array
+                    for (var name in leafletLayers.overlays) {
+                        if (!isDefined(newOverlayLayers[name]) || newOverlayLayers[name].doRefresh) {
+                            // Remove from the map if it's on it
+                            if (map.hasLayer(leafletLayers.overlays[name])) {
+                                // Safe remove when ArcGIS layers is loading.
+                                var options = isDefined(newOverlayLayers[name]) ? newOverlayLayers[name].layerOptions : null;
+                                safeRemoveLayer(map, leafletLayers.overlays[name], options);
+                            }
+                            // TODO: Depending on the layer type we will have to delete what's included on it
+                            delete leafletLayers.overlays[name];
+
+                            if (newOverlayLayers[name] && newOverlayLayers[name].doRefresh) {
+                                newOverlayLayers[name].doRefresh = false;
+                            }
+                        }
+                    }
+
+                    // add new overlays
+                    for (var newName in newOverlayLayers) {
+                        if (!isDefined(leafletLayers.overlays[newName])) {
+                            var testOverlayLayer = createLayer(newOverlayLayers[newName]);
+                            if (!isDefined(testOverlayLayer)) {
+                                // If the layer creation fails, continue to the next overlay
+                                continue;
+                            }
+                            leafletLayers.overlays[newName] = testOverlayLayer;
+                            if (newOverlayLayers[newName].visible === true) {
+                                safeAddLayer(map, leafletLayers.overlays[newName]);
+                            }
+
+                            if (isDefined(newOverlayLayers[newName].index) && leafletLayers.overlays[newName].setZIndex) {
+                                leafletLayers.overlays[newName].setZIndex(newOverlayLayers[newName].index);
+                            }
+                        } else {
+                            // check for the .visible property to hide/show overLayers
+                            if (newOverlayLayers[newName].visible && !map.hasLayer(leafletLayers.overlays[newName])) {
+                                safeAddLayer(map, leafletLayers.overlays[newName]);
+                            } else if (newOverlayLayers[newName].visible === false && map.hasLayer(leafletLayers.overlays[newName])) {
+                                // Safe remove when ArcGIS layers is loading.
+                                safeRemoveLayer(map, leafletLayers.overlays[newName], newOverlayLayers[newName].layerOptions);
+                            }
+
+                            // check for the .layerOptions.opacity property has changed.
+                            var ly = leafletLayers.overlays[newName];
+                            if (map.hasLayer(leafletLayers.overlays[newName])) {
+                                if (newOverlayLayers[newName].layerOptions.opacity !== oldOverlayLayers[newName].layerOptions.opacity) {
+
+                                    if (isDefined(ly.setOpacity)) {
+                                        ly.setOpacity(newOverlayLayers[newName].layerOptions.opacity);
+                                    }
+                                    if (isDefined(ly.getLayers) && isDefined(ly.eachLayer)) {
+                                        ly.eachLayer(changeOpacityListener(newOverlayLayers[newName].layerOptions.opacity));
+                                    }
+                                }
+
+                                if (isDefined(newOverlayLayers[newName].index) && ly.setZIndex && newOverlayLayers[newName].index !== oldOverlayLayers[newName].index) {
+                                    ly.setZIndex(newOverlayLayers[newName].index);
+                                }
+                            }
+                        }
+
+                        //refresh heatmap data if present
+                        if (newOverlayLayers[newName].visible && map._loaded && newOverlayLayers[newName].data && newOverlayLayers[newName].type === "heatmap") {
+                            leafletLayers.overlays[newName].setData(newOverlayLayers[newName].data);
+                            leafletLayers.overlays[newName].update();
+                        }
+                    }
+
+                    // Only add the layers switch selector control if we have more than one baselayer + overlay
+                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);
+                }, true);
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module("ui-leaflet").directive('legend', ["leafletLogger", "$http", "$timeout", "leafletHelpers", "leafletLegendHelpers", function (leafletLogger, $http, $timeout, leafletHelpers, leafletLegendHelpers) {
+    var $log = leafletLogger,
+        errorHeader = leafletHelpers.errorHeader + ' [Legend] ';
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+        transclude: false,
+
+        link: function link(scope, element, attrs, controller) {
+
+            var isArray = leafletHelpers.isArray,
+                isString = leafletHelpers.isString,
+                isDefined = leafletHelpers.isDefined,
+                isFunction = leafletHelpers.isFunction,
+                leafletScope = controller.getLeafletScope(),
+                legend = leafletScope.legend;
+
+            var legendClass;
+            var position;
+            var leafletLegend;
+            var type;
+
+            leafletScope.$watch('legend', function (newLegend) {
+
+                if (isDefined(newLegend)) {
+                    legendClass = newLegend.legendClass ? newLegend.legendClass : "legend";
+                    position = newLegend.position || 'bottomright';
+                    // default to arcgis
+                    type = newLegend.type || 'arcgis';
+                }
+            }, true);
+
+            var createLegend = function createLegend(map, legendData, newURL) {
+                if (legendData && legendData.layers && legendData.layers.length > 0) {
+                    if (isDefined(leafletLegend)) {
+                        leafletLegendHelpers.updateLegend(leafletLegend.getContainer(), legendData, type, newURL);
+                    } else {
+                        leafletLegend = L.control({
+                            position: position
+                        });
+                        leafletLegend.onAdd = leafletLegendHelpers.getOnAddLegend(legendData, legendClass, type, newURL);
+                        leafletLegend.addTo(map);
+                    }
+
+                    if (isDefined(legend.loadedData) && isFunction(legend.loadedData)) {
+                        legend.loadedData();
+                    }
+                }
+            };
+
+            controller.getMap().then(function (map) {
+                leafletScope.$watch('legend', function (newLegend) {
+                    if (!isDefined(newLegend)) {
+                        if (isDefined(leafletLegend)) {
+                            leafletLegend.removeFrom(map);
+                            leafletLegend = null;
+                        }
+
+                        return;
+                    }
+
+                    if (!isDefined(newLegend.url) && type === 'arcgis' && (!isArray(newLegend.colors) || !isArray(newLegend.labels) || newLegend.colors.length !== newLegend.labels.length)) {
+                        $log.warn(errorHeader + " legend.colors and legend.labels must be set.");
+                        return;
+                    }
+
+                    if (isDefined(newLegend.url)) {
+                        $log.info(errorHeader + " loading legend service.");
+                        return;
+                    }
+
+                    if (isDefined(leafletLegend)) {
+                        leafletLegend.removeFrom(map);
+                        leafletLegend = null;
+                    }
+
+                    leafletLegend = L.control({
+                        position: position
+                    });
+
+                    if (type === 'arcgis') {
+                        leafletLegend.onAdd = leafletLegendHelpers.getOnAddArrayLegend(newLegend, legendClass);
+                    }
+                    leafletLegend.addTo(map);
+                });
+
+                leafletScope.$watch('legend.url', function (newURL) {
+                    if (!isDefined(newURL)) {
+                        return;
+                    }
+
+                    if (!isArray(newURL) && !isString(newURL)) {
+                        $log.warn(errorHeader + " legend.url must be an array or string.");
+                        return;
+                    }
+
+                    var urls = isString(newURL) ? [newURL] : newURL;
+
+                    var legendData;
+                    var onResult = function onResult(idx, url) {
+                        return function (ld) {
+                            if (isDefined(ld.data.error)) {
+                                $log.warn(errorHeader + 'Error loadin legend from: ' + url, ld.data.error.message);
+                            } else {
+                                if (legendData && legendData.layers && legendData.layers.length > 0) {
+                                    legendData.layers = legendData.layers.concat(ld.data.layers);
+                                } else {
+                                    legendData = ld.data;
+                                }
+                            }
+
+                            if (idx === urls.length - 1) {
+                                createLegend(map, legendData, newURL);
+                            }
+                        };
+                    };
+                    var onError = function onError(err) {
+                        $log.warn(errorHeader + ' legend.url not loaded.', err);
+                    };
+
+                    for (var i = 0; i < urls.length; i++) {
+                        leafletLegendHelpers.addLegendURL(attrs.id, {
+                            url: urls[i],
+                            method: 'GET'
+                        }).then(onResult(i)).catch(onError);
+                    }
+                });
+
+                leafletScope.$watch('legend.legendData', function (legendData) {
+                    $log.debug('legendData', legendData);
+                    if (isDefined(leafletScope.legend.url) || !isDefined(legendData)) {
+                        return;
+                    }
+
+                    createLegend(map, legendData);
+                }, true);
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('markers', ["leafletLogger", "$rootScope", "$q", "leafletData", "leafletHelpers", "leafletMapDefaults", "leafletMarkersHelpers", "leafletMarkerEvents", "leafletIterators", "leafletWatchHelpers", "leafletDirectiveControlsHelpers", function (leafletLogger, $rootScope, $q, leafletData, leafletHelpers, leafletMapDefaults, leafletMarkersHelpers, leafletMarkerEvents, leafletIterators, leafletWatchHelpers, leafletDirectiveControlsHelpers) {
+    //less terse vars to helpers
+    var isDefined = leafletHelpers.isDefined,
+        errorHeader = leafletHelpers.errorHeader,
+        Helpers = leafletHelpers,
+        isString = leafletHelpers.isString,
+        addMarkerWatcher = leafletMarkersHelpers.addMarkerWatcher,
+        updateMarker = leafletMarkersHelpers.updateMarker,
+        listenMarkerEvents = leafletMarkersHelpers.listenMarkerEvents,
+        addMarkerToGroup = leafletMarkersHelpers.addMarkerToGroup,
+        createMarker = leafletMarkersHelpers.createMarker,
+        deleteMarker = leafletMarkersHelpers.deleteMarker,
+        getModelFromModels = leafletMarkersHelpers.getModelFromModels,
+        getLayerModels = leafletMarkersHelpers.getLayerModels,
+        resetUnusedMarkerGroups = leafletMarkersHelpers.resetUnusedMarkerGroups,
+        $it = leafletIterators,
+        _defaultWatchOptions = leafletHelpers.watchOptions,
+        maybeWatch = leafletWatchHelpers.maybeWatch,
+        extendDirectiveControls = leafletDirectiveControlsHelpers.extend,
+        $log = leafletLogger,
+        watchTrap = { changeFromDirective: false };
+
+    var _getLMarker = function _getLMarker(leafletMarkers, name, maybeLayerName) {
+        if (!Object.keys(leafletMarkers).length) return;
+        if (maybeLayerName && isString(maybeLayerName)) {
+            if (!leafletMarkers[maybeLayerName] || !Object.keys(leafletMarkers[maybeLayerName]).length) return;
+            return leafletMarkers[maybeLayerName][name];
+        }
+        return leafletMarkers[name];
+    };
+
+    var _setLMarker = function _setLMarker(lObject, leafletMarkers, name, maybeLayerName) {
+        if (maybeLayerName && isString(maybeLayerName)) {
+            if (!isDefined(leafletMarkers[maybeLayerName])) leafletMarkers[maybeLayerName] = {};
+            leafletMarkers[maybeLayerName][name] = lObject;
+        } else leafletMarkers[name] = lObject;
+        return lObject;
+    };
+
+    var _maybeAddMarkerToLayer = function _maybeAddMarkerToLayer(layerName, layers, model, marker, watchType, map) {
+
+        if (!isString(layerName)) {
+            $log.error(errorHeader + ' A layername must be a string');
+            return false;
+        }
+
+        if (!isDefined(layers)) {
+            $log.error(errorHeader + ' You must add layers to the directive if the markers are going to use this functionality.');
+            return false;
+        }
+
+        if (!isDefined(layers.overlays) || !isDefined(layers.overlays[layerName])) {
+            $log.error(errorHeader + ' A marker can only be added to a layer of type "group"');
+            return false;
+        }
+        var layerGroup = layers.overlays[layerName];
+        if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {
+            $log.error(errorHeader + ' Adding a marker to an overlay needs a overlay of the type "group" or "featureGroup"');
+            return false;
+        }
+
+        // The marker goes to a correct layer group, so first of all we add it
+        layerGroup.addLayer(marker);
+
+        // The marker is automatically added to the map depending on the visibility
+        // of the layer, so we only have to open the popup if the marker is in the map
+        if (watchType === null && map.hasLayer(marker) && model.focus === true) {
+            marker.openPopup();
+        }
+        return true;
+    };
+    //TODO: move to leafletMarkersHelpers??? or make a new class/function file (leafletMarkersHelpers is large already)
+    var _addMarkers = function _addMarkers(mapId, markersToRender, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, maybeLayerName, skips) {
+        $it.each(markersToRender, function (model, newName) {
+            if (skips[newName]) return;
+
+            if (newName.search("-") !== -1) {
+                $log.error('The marker can\'t use a "-" on his key name: "' + newName + '".');
+                return;
+            }
+
+            var pathToMarker = Helpers.getObjectDotPath(maybeLayerName ? [maybeLayerName, newName] : [newName]);
+            var maybeLMarker = _getLMarker(leafletMarkers, newName, maybeLayerName);
+            Helpers.modelChangeInDirective(watchTrap, "changeFromDirective", function () {
+                if (!isDefined(maybeLMarker)) {
+
+                    var marker = createMarker(model);
+                    var layerName = (model ? model.layer : undefined) || maybeLayerName; //original way takes pref
+                    if (!isDefined(marker)) {
+                        $log.error(errorHeader + ' Received invalid data on the marker ' + newName + '.');
+                        return;
+                    }
+                    _setLMarker(marker, leafletMarkers, newName, maybeLayerName);
+
+                    // Bind message
+                    if (isDefined(model.message)) {
+                        marker.bindPopup(model.message, model.popupOptions);
+                    }
+
+                    // Add the marker to a cluster group if needed
+                    if (isDefined(model.group)) {
+                        var groupOptions = isDefined(model.groupOption) ? model.groupOption : null;
+                        addMarkerToGroup(marker, model.group, groupOptions, map);
+                    }
+
+                    // Show label if defined
+                    if (Helpers.LabelPlugin.isLoaded() && isDefined(model.label) && isDefined(model.label.message)) {
+                        marker.bindLabel(model.label.message, model.label.options);
+                    }
+
+                    // Check if the marker should be added to a layer
+                    if (isDefined(model) && (isDefined(model.layer) || isDefined(maybeLayerName))) {
+
+                        var pass = _maybeAddMarkerToLayer(layerName, layers, model, marker, watchOptions.individual.type, map);
+                        if (!pass) return; //something went wrong move on in the loop
+                    } else if (!isDefined(model.group)) {
+                        // We do not have a layer attr, so the marker goes to the map layer
+                        map.addLayer(marker);
+                        if (watchOptions.individual.type === null && model.focus === true) {
+                            marker.openPopup();
+                        }
+                    }
+
+                    if (watchOptions.individual.type !== null) {
+                        addMarkerWatcher(marker, pathToMarker, leafletScope, layers, map, watchOptions.individual);
+                    }
+
+                    listenMarkerEvents(marker, model, leafletScope, watchOptions.individual.type, map);
+                    leafletMarkerEvents.bindEvents(mapId, marker, pathToMarker, model, leafletScope, layerName);
+                } else {
+                    var oldModel = getModelFromModels(oldModels, newName, maybeLayerName);
+                    updateMarker(model, oldModel, maybeLMarker, pathToMarker, leafletScope, layers, map);
+                }
+            });
+        });
+    };
+    var _seeWhatWeAlreadyHave = function _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, isEqual, cb) {
+        var hasLogged = false,
+            equals = false,
+            oldMarker,
+            newMarker;
+
+        var doCheckOldModel = isDefined(oldMarkerModels);
+        for (var name in lMarkers) {
+            if (!hasLogged) {
+                $log.debug(errorHeader + "[markers] destroy: ");
+                hasLogged = true;
+            }
+
+            if (doCheckOldModel) {
+                //might want to make the option (in watch options) to disable deep checking
+                //ie the options to only check !== (reference check) instead of angular.equals (slow)
+                newMarker = markerModels[name];
+                oldMarker = oldMarkerModels[name];
+                equals = isEqual && angular.equals(newMarker, oldMarker);
+            }
+            if (!isDefined(markerModels) || !Object.keys(markerModels).length || !isDefined(markerModels[name]) || !Object.keys(markerModels[name]).length || equals) {
+                if (cb && Helpers.isFunction(cb)) cb(newMarker, oldMarker, name);
+            }
+        }
+    };
+    var _destroy = function _destroy(markerModels, oldMarkerModels, lMarkers, map, layers) {
+        _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, false, function (newMarker, oldMarker, lMarkerName) {
+            $log.debug(errorHeader + '[marker] is deleting marker: ' + lMarkerName);
+            deleteMarker(lMarkers[lMarkerName], map, layers);
+            delete lMarkers[lMarkerName];
+        });
+    };
+
+    var _getNewModelsToSkipp = function _getNewModelsToSkipp(newModels, oldModels, lMarkers) {
+        var skips = {};
+        _seeWhatWeAlreadyHave(newModels, oldModels, lMarkers, true, function (newMarker, oldMarker, lMarkerName) {
+            $log.debug(errorHeader + '[marker] is already rendered, marker: ' + lMarkerName);
+            skips[lMarkerName] = newMarker;
+        });
+        return skips;
+    };
+
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet', '?layers'],
+
+        link: function link(scope, element, attrs, controller) {
+            var mapController = controller[0],
+                leafletScope = mapController.getLeafletScope();
+
+            mapController.getMap().then(function (map) {
+                var leafletMarkers = {},
+                    getLayers;
+
+                // If the layers attribute is used, we must wait until the layers are created
+                if (isDefined(controller[1])) {
+                    getLayers = controller[1].getLayers;
+                } else {
+                    getLayers = function getLayers() {
+                        var deferred = $q.defer();
+                        deferred.resolve();
+                        return deferred.promise;
+                    };
+                }
+
+                var watchOptions;
+                if (leafletScope.watchOptions && leafletScope.watchOptions.markers) {
+                    watchOptions = leafletScope.watchOptions.markers;
+                } else {
+                    watchOptions = _defaultWatchOptions;
+                }
+
+                var isNested = isDefined(attrs.markersNested) && Helpers.isTruthy(attrs.markersNested);
+
+                getLayers().then(function (layers) {
+                    var _clean = function _clean(models, oldModels) {
+                        resetUnusedMarkerGroups();
+                        if (isNested) {
+                            $it.each(models, function (markerToMaybeDel, layerName) {
+                                var oldLayerModels = getLayerModels(oldModels, layerName);
+                                _destroy(markerToMaybeDel, oldLayerModels, leafletMarkers[layerName], map, layers);
+                            });
+                            return;
+                        }
+                        _destroy(models, oldModels, leafletMarkers, map, layers);
+                    };
+
+                    var _create = function _create(models, oldModels) {
+                        _clean(models, oldModels);
+                        var skips = null;
+                        if (isNested) {
+                            $it.each(models, function (markersToAdd, layerName) {
+                                var oldLayerModels = getLayerModels(oldModels, layerName);
+                                var newlayerModels = getLayerModels(models, layerName);
+                                skips = _getNewModelsToSkipp(newlayerModels, oldLayerModels, leafletMarkers[layerName]);
+                                _addMarkers(attrs.id, markersToAdd, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, layerName, skips);
+                            });
+                            return;
+                        }
+                        skips = _getNewModelsToSkipp(models, oldModels, leafletMarkers);
+                        _addMarkers(attrs.id, models, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, undefined, skips);
+                    };
+                    extendDirectiveControls(attrs.id, 'markers', _create, _clean);
+                    leafletData.setMarkers(leafletMarkers, attrs.id);
+
+                    maybeWatch(leafletScope, 'markers', watchOptions, function (newMarkers, oldMarkers) {
+                        if (watchTrap.changeFromDirective) return;
+                        _create(newMarkers, oldMarkers);
+                    });
+                    scope.$on('$destroy', function () {
+                        _destroy(leafletScope.markers, {}, leafletMarkers, map, layers);
+                    });
+                });
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('maxbounds', ["leafletLogger", "leafletMapDefaults", "leafletBoundsHelpers", "leafletHelpers", function (leafletLogger, leafletMapDefaults, leafletBoundsHelpers, leafletHelpers) {
+    // var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var leafletScope = controller.getLeafletScope(),
+                isValidBounds = leafletBoundsHelpers.isValidBounds,
+                isNumber = leafletHelpers.isNumber;
+
+            controller.getMap().then(function (map) {
+                leafletScope.$watch("maxbounds", function (maxbounds) {
+                    if (!isValidBounds(maxbounds)) {
+                        // Unset any previous maxbounds
+                        map.setMaxBounds();
+                        return;
+                    }
+
+                    var leafletBounds = leafletBoundsHelpers.createLeafletBounds(maxbounds);
+                    if (isNumber(maxbounds.pad)) {
+                        leafletBounds = leafletBounds.pad(maxbounds.pad);
+                    }
+
+                    map.setMaxBounds(leafletBounds);
+                    if (!attrs.center && !attrs.lfCenter) {
+                        map.fitBounds(leafletBounds);
+                    }
+                });
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('paths', ["leafletLogger", "$q", "leafletData", "leafletMapDefaults", "leafletHelpers", "leafletPathsHelpers", "leafletPathEvents", "leafletWatchHelpers", function (leafletLogger, $q, leafletData, leafletMapDefaults, leafletHelpers, leafletPathsHelpers, leafletPathEvents, leafletWatchHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet', '?layers'],
+
+        link: function link(scope, element, attrs, controller) {
+            var mapController = controller[0],
+                isDefined = leafletHelpers.isDefined,
+                isString = leafletHelpers.isString,
+                leafletScope = mapController.getLeafletScope(),
+                paths = leafletScope.paths,
+                createPath = leafletPathsHelpers.createPath,
+                bindPathEvents = leafletPathEvents.bindPathEvents,
+                setPathOptions = leafletPathsHelpers.setPathOptions,
+                maybeWatch = leafletWatchHelpers.maybeWatch;
+
+            mapController.getMap().then(function (map) {
+                var defaults = leafletMapDefaults.getDefaults(attrs.id),
+                    getLayers;
+
+                // If the layers attribute is used, we must wait until the layers are created
+                if (isDefined(controller[1])) {
+                    getLayers = controller[1].getLayers;
+                } else {
+                    getLayers = function getLayers() {
+                        var deferred = $q.defer();
+                        deferred.resolve();
+                        return deferred.promise;
+                    };
+                }
+
+                if (!isDefined(paths)) {
+                    return;
+                }
+
+                //legacy behaviour does a watch collection on the paths
+                var _legacyWatchOptions = {
+                    type: 'watchCollection',
+                    individual: {
+                        type: 'watchDeep'
+                    }
+                };
+
+                var watchOptions;
+                if (leafletScope.watchOptions && leafletScope.watchOptions.paths) {
+                    watchOptions = leafletScope.watchOptions.paths;
+                } else {
+                    watchOptions = _legacyWatchOptions;
+                }
+
+                getLayers().then(function (layers) {
+
+                    var leafletPaths = {};
+                    leafletData.setPaths(leafletPaths, attrs.id);
+
+                    // Function for listening every single path once created
+                    var watchPathFn = function watchPathFn(leafletPath, name, watchOptions) {
+                        var pathWatchPath = "paths[\"" + name + "\"]";
+
+                        maybeWatch(leafletScope, pathWatchPath, watchOptions, function (pathData, old, clearWatch) {
+                            if (!isDefined(pathData)) {
+                                if (isDefined(old.layer)) {
+                                    for (var i in layers.overlays) {
+                                        var overlay = layers.overlays[i];
+                                        overlay.removeLayer(leafletPath);
+                                    }
+                                }
+                                map.removeLayer(leafletPath);
+                                clearWatch();
+                                return;
+                            }
+                            setPathOptions(leafletPath, pathData.type, pathData);
+                        });
+                    };
+
+                    var _clean = function _clean(newPaths) {
+                        // Delete paths (by name) from the array
+                        for (var name in leafletPaths) {
+                            if (!isDefined(newPaths[name])) {
+                                map.removeLayer(leafletPaths[name]);
+                                delete leafletPaths[name];
+                            }
+                        }
+                    };
+
+                    var _create = function _create(newPaths) {
+                        _clean(newPaths);
+                        // Create the new paths
+                        for (var newName in newPaths) {
+                            if (newName.search('\\$') === 0) {
+                                continue;
+                            }
+                            if (newName.search("-") !== -1) {
+                                $log.error('[AngularJS - Leaflet] The path name "' + newName + '" is not valid. It must not include "-" and a number.');
+                                continue;
+                            }
+
+                            if (!isDefined(leafletPaths[newName])) {
+                                var pathData = newPaths[newName];
+                                var newPath = createPath(newName, newPaths[newName], defaults);
+
+                                // bind popup if defined
+                                if (isDefined(newPath) && isDefined(pathData.message)) {
+                                    newPath.bindPopup(pathData.message, pathData.popupOptions);
+                                }
+
+                                // Show label if defined
+                                if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(pathData.label) && isDefined(pathData.label.message)) {
+                                    newPath.bindLabel(pathData.label.message, pathData.label.options);
+                                }
+
+                                // Check if the marker should be added to a layer
+                                if (isDefined(pathData) && isDefined(pathData.layer)) {
+
+                                    if (!isString(pathData.layer)) {
+                                        $log.error('[AngularJS - Leaflet] A layername must be a string');
+                                        continue;
+                                    }
+                                    if (!isDefined(layers)) {
+                                        $log.error('[AngularJS - Leaflet] You must add layers to the directive if the markers are going to use this functionality.');
+                                        continue;
+                                    }
+
+                                    if (!isDefined(layers.overlays) || !isDefined(layers.overlays[pathData.layer])) {
+                                        $log.error('[AngularJS - Leaflet] A path can only be added to a layer of type "group"');
+                                        continue;
+                                    }
+                                    var layerGroup = layers.overlays[pathData.layer];
+                                    if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {
+                                        $log.error('[AngularJS - Leaflet] Adding a path to an overlay needs a overlay of the type "group" or "featureGroup"');
+                                        continue;
+                                    }
+
+                                    // Listen for changes on the new path
+                                    leafletPaths[newName] = newPath;
+                                    // The path goes to a correct layer group, so first of all we add it
+                                    layerGroup.addLayer(newPath);
+
+                                    if (watchOptions.individual.type !== null) {
+                                        watchPathFn(newPath, newName, watchOptions.individual);
+                                    } else {
+                                        setPathOptions(newPath, pathData.type, pathData);
+                                    }
+                                } else if (isDefined(newPath)) {
+                                    // Listen for changes on the new path
+                                    leafletPaths[newName] = newPath;
+                                    map.addLayer(newPath);
+
+                                    if (watchOptions.individual.type !== null) {
+                                        watchPathFn(newPath, newName, watchOptions.individual);
+                                    } else {
+                                        setPathOptions(newPath, pathData.type, pathData);
+                                    }
+                                }
+
+                                bindPathEvents(attrs.id, newPath, newName, pathData, leafletScope);
+                            }
+                        }
+                    };
+
+                    maybeWatch(leafletScope, 'paths', watchOptions, function (newPaths) {
+                        _create(newPaths);
+                    });
+                });
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('tiles', ["leafletLogger", "leafletData", "leafletMapDefaults", "leafletHelpers", function (leafletLogger, leafletData, leafletMapDefaults, leafletHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                tiles = leafletScope.tiles;
+
+            if (!isDefined(tiles) || !isDefined(tiles.url)) {
+                $log.warn("[AngularJS - Leaflet] The 'tiles' definition doesn't have the 'url' property.");
+                return;
+            }
+
+            controller.getMap().then(function (map) {
+                var defaults = leafletMapDefaults.getDefaults(attrs.id);
+                var tileLayerObj;
+                leafletScope.$watch("tiles", function (tiles) {
+                    var tileLayerOptions = defaults.tileLayerOptions;
+                    var tileLayerUrl = defaults.tileLayer;
+
+                    // If no valid tiles are in the scope, remove the last layer
+                    if (!isDefined(tiles.url) && isDefined(tileLayerObj)) {
+                        map.removeLayer(tileLayerObj);
+                        return;
+                    }
+
+                    // No leafletTiles object defined yet
+                    if (!isDefined(tileLayerObj)) {
+                        if (isDefined(tiles.options)) {
+                            angular.copy(tiles.options, tileLayerOptions);
+                        }
+
+                        if (isDefined(tiles.url)) {
+                            tileLayerUrl = tiles.url;
+                        }
+
+                        tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);
+                        tileLayerObj.addTo(map);
+                        leafletData.setTiles(tileLayerObj, attrs.id);
+                        return;
+                    }
+
+                    // If the options of the tilelayer is changed, we need to redraw the layer
+                    if (isDefined(tiles.url) && isDefined(tiles.options) && !angular.equals(tiles.options, tileLayerOptions)) {
+                        map.removeLayer(tileLayerObj);
+                        tileLayerOptions = defaults.tileLayerOptions;
+                        angular.copy(tiles.options, tileLayerOptions);
+                        tileLayerUrl = tiles.url;
+                        tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);
+                        tileLayerObj.addTo(map);
+                        leafletData.setTiles(tileLayerObj, attrs.id);
+                        return;
+                    }
+
+                    // Only the URL of the layer is changed, update the tiles object
+                    if (isDefined(tiles.url)) {
+                        tileLayerObj.setUrl(tiles.url);
+                    }
+                }, true);
+            });
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').directive('watchOptions', ['$log', '$rootScope', '$q', 'leafletData', 'leafletHelpers', function (leafletLogger, $rootScope, $q, leafletData, leafletHelpers) {
+
+    var isDefined = leafletHelpers.isDefined,
+        errorHeader = leafletHelpers.errorHeader,
+        isObject = leafletHelpers.isObject,
+        $log = leafletLogger;
+
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet'],
+
+        link: function link(scope, element, attrs, controller) {
+            var mapController = controller[0],
+                leafletScope = mapController.getLeafletScope();
+
+            var _isValidWatchType = function _isValidWatchType(type) {
+                return type === 'watch' || type === 'watchCollection' || type === 'watchDeep' || type === null;
+            };
+
+            if (isDefined(leafletScope.watchOptions) && isObject(leafletScope.watchOptions)) {
+                angular.forEach(['markers', 'geojson', 'paths'], function (name) {
+                    if (isDefined(leafletScope.watchOptions[name])) {
+                        if (!_isValidWatchType(leafletScope.watchOptions[name].type)) {
+                            $log.error(errorHeader + ' watchOptions.' + name + '.type is not a valid type.');
+                        }
+                        if (isDefined(leafletScope.watchOptions[name].individual)) {
+                            if (!_isValidWatchType(leafletScope.watchOptions[name].individual.type)) {
+                                $log.error(errorHeader + ' watchOptions.' + name + '.individual.type is not a valid type.');
+                            }
+                        } else {
+                            $log.error(errorHeader + ' watchOptions.' + name + '.type.individual must be defined.');
+                        }
+                    }
+                });
+            }
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletEventsHelpersFactory', ["$rootScope", "$q", "leafletLogger", "leafletHelpers", function ($rootScope, $q, leafletLogger, leafletHelpers) {
+    var safeApply = leafletHelpers.safeApply,
+        isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        isArray = leafletHelpers.isArray,
+        errorHeader = leafletHelpers.errorHeader,
+        $log = leafletLogger;
+
+    var EventsHelper = function EventsHelper(rootBroadcastName, lObjectType) {
+        this.rootBroadcastName = rootBroadcastName;
+        $log.debug("leafletEventsHelpersFactory: lObjectType: " + lObjectType + "rootBroadcastName: " + rootBroadcastName);
+        //used to path/key out certain properties based on the type , "markers", "geojson"
+        this.lObjectType = lObjectType;
+    };
+
+    EventsHelper.prototype.getAvailableEvents = function () {
+        return [];
+    };
+
+    /*
+     argument: name: Note this can be a single string or dot notation
+     Example:
+     markerModel : {
+     m1: { lat:_, lon: _}
+     }
+     //would yield name of
+     name = "m1"
+      If nested:
+     markerModel : {
+     cars: {
+     m1: { lat:_, lon: _}
+     }
+     }
+     //would yield name of
+     name = "cars.m1"
+     */
+    EventsHelper.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {
+        var _this = this;
+
+        maybeMapId = maybeMapId || '';
+        if (maybeMapId) maybeMapId = '.' + maybeMapId;
+
+        return function (e) {
+            var broadcastName = _this.rootBroadcastName + maybeMapId + '.' + eventName;
+            $log.debug(broadcastName);
+            _this.fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName, extra);
+        };
+    };
+
+    EventsHelper.prototype.fire = function (scope, broadcastName, logic, event, lObject, model, modelName, layerName, extra) {
+        // Safely broadcast the event
+        safeApply(scope, function () {
+            var toSend = {
+                leafletEvent: event,
+                leafletObject: lObject,
+                modelName: modelName,
+                model: model
+            };
+            if (isDefined(layerName)) angular.extend(toSend, { layerName: layerName });
+
+            if (logic === "emit") {
+                scope.$emit(broadcastName, toSend);
+            } else {
+                $rootScope.$broadcast(broadcastName, toSend);
+            }
+        });
+    };
+
+    EventsHelper.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName, extra) {
+        var events = [];
+        var logic = 'emit';
+        var _this = this;
+
+        if (!isDefined(leafletScope.eventBroadcast)) {
+            // Backward compatibility, if no event-broadcast attribute, all events are broadcasted
+            events = this.getAvailableEvents();
+        } else if (!isObject(leafletScope.eventBroadcast)) {
+            // Not a valid object
+            $log.error(errorHeader + "event-broadcast must be an object check your model.");
+        } else {
+            // We have a possible valid object
+            if (!isDefined(leafletScope.eventBroadcast[_this.lObjectType])) {
+                // We do not have events enable/disable do we do nothing (all enabled by default)
+                events = this.getAvailableEvents();
+            } else if (!isObject(leafletScope.eventBroadcast[_this.lObjectType])) {
+                // Not a valid object
+                $log.warn(errorHeader + 'event-broadcast.' + [_this.lObjectType] + ' must be an object check your model.');
+            } else {
+                // We have a possible valid map object
+                // Event propadation logic
+                if (isDefined(leafletScope.eventBroadcast[this.lObjectType].logic)) {
+                    // We take care of possible propagation logic
+                    if (leafletScope.eventBroadcast[_this.lObjectType].logic !== "emit" && leafletScope.eventBroadcast[_this.lObjectType].logic !== "broadcast") $log.warn(errorHeader + "Available event propagation logic are: 'emit' or 'broadcast'.");
+                }
+                // Enable / Disable
+                var eventsEnable = false,
+                    eventsDisable = false;
+                if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].enable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].enable)) eventsEnable = true;
+                if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].disable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].disable)) eventsDisable = true;
+
+                if (eventsEnable && eventsDisable) {
+                    // Both are active, this is an error
+                    $log.warn(errorHeader + "can not enable and disable events at the same time");
+                } else if (!eventsEnable && !eventsDisable) {
+                    // Both are inactive, this is an error
+                    $log.warn(errorHeader + "must enable or disable events");
+                } else {
+                    // At this point the object is OK, lets enable or disable events
+                    if (eventsEnable) {
+                        // Enable events
+                        leafletScope.eventBroadcast[this.lObjectType].enable.forEach(function (eventName) {
+                            // Do we have already the event enabled?
+                            if (events.indexOf(eventName) !== -1) {
+                                // Repeated event, this is an error
+                                $log.warn(errorHeader + "This event " + eventName + " is already enabled");
+                            } else {
+                                // Does the event exists?
+                                if (_this.getAvailableEvents().indexOf(eventName) === -1) {
+                                    // The event does not exists, this is an error
+                                    $log.warn(errorHeader + "This event " + eventName + " does not exist");
+                                } else {
+                                    // All ok enable the event
+                                    events.push(eventName);
+                                }
+                            }
+                        });
+                    } else {
+                        // Disable events
+                        events = this.getAvailableEvents();
+                        leafletScope.eventBroadcast[_this.lObjectType].disable.forEach(function (eventName) {
+                            var index = events.indexOf(eventName);
+                            if (index === -1) {
+                                // The event does not exist
+                                $log.warn(errorHeader + "This event " + eventName + " does not exist or has been already disabled");
+                            } else {
+                                events.splice(index, 1);
+                            }
+                        });
+                    }
+                }
+            }
+        }
+
+        events.forEach(function (eventName) {
+            lObject.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra));
+        });
+        return logic;
+    };
+
+    return EventsHelper;
+}]).service('leafletEventsHelpers', ["leafletEventsHelpersFactory", function (leafletEventsHelpersFactory) {
+    return new leafletEventsHelpersFactory();
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletGeoJsonEvents', ["$rootScope", "$q", "leafletLogger", "leafletHelpers", "leafletEventsHelpersFactory", "leafletData", function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory, leafletData) {
+    var safeApply = leafletHelpers.safeApply,
+        EventsHelper = leafletEventsHelpersFactory;
+    // $log = leafletLogger;
+
+    var GeoJsonEvents = function GeoJsonEvents() {
+        EventsHelper.call(this, 'leafletDirectiveGeoJson', 'geojson');
+    };
+
+    GeoJsonEvents.prototype = new EventsHelper();
+
+    GeoJsonEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {
+        var base = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName),
+            _this = this;
+
+        return function (e) {
+            if (eventName === 'mouseout') {
+                if (extra.resetStyleOnMouseout) {
+                    leafletData.getGeoJSON(extra.mapId).then(function (leafletGeoJSON) {
+                        //this is broken on nested needs to traverse or user layerName (nested)
+                        var lobj = layerName ? leafletGeoJSON[layerName] : leafletGeoJSON;
+                        lobj.resetStyle(e.target);
+                    });
+                }
+                safeApply(leafletScope, function () {
+                    $rootScope.$broadcast(_this.rootBroadcastName + '.mouseout', e);
+                });
+            }
+            base(e); //common
+        };
+    };
+
+    GeoJsonEvents.prototype.getAvailableEvents = function () {
+        return ['click', 'dblclick', 'mouseover', 'mouseout'];
+    };
+
+    return new GeoJsonEvents();
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletLabelEvents', ["$rootScope", "$q", "leafletLogger", "leafletHelpers", "leafletEventsHelpersFactory", function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory) {
+    var Helpers = leafletHelpers,
+        EventsHelper = leafletEventsHelpersFactory;
+    //$log = leafletLogger;
+
+    var LabelEvents = function LabelEvents() {
+        EventsHelper.call(this, 'leafletDirectiveLabel', 'markers');
+    };
+    LabelEvents.prototype = new EventsHelper();
+
+    LabelEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        var markerName = name.replace('markers.', '');
+        return EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, markerName, model, layerName);
+    };
+
+    LabelEvents.prototype.getAvailableEvents = function () {
+        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];
+    };
+
+    LabelEvents.prototype.genEvents = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        var _this = this;
+        var labelEvents = this.getAvailableEvents();
+        var scopeWatchName = Helpers.getObjectArrayPath("markers." + name);
+        labelEvents.forEach(function (eventName) {
+            lObject.label.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject.label, scopeWatchName, model, layerName));
+        });
+    };
+
+    LabelEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {};
+
+    return new LabelEvents();
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletMapEvents', ["$rootScope", "$q", "leafletLogger", "leafletHelpers", "leafletEventsHelpers", "leafletIterators", function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpers, leafletIterators) {
+    var isDefined = leafletHelpers.isDefined,
+        fire = leafletEventsHelpers.fire;
+
+    var _getAvailableMapEvents = function _getAvailableMapEvents() {
+        return ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'contextmenu', 'focus', 'blur', 'preclick', 'load', 'unload', 'viewreset', 'movestart', 'move', 'moveend', 'dragstart', 'drag', 'dragend', 'zoomstart', 'zoomanim', 'zoomend', 'zoomlevelschange', 'resize', 'autopanstart', 'layeradd', 'layerremove', 'baselayerchange', 'overlayadd', 'overlayremove', 'locationfound', 'locationerror', 'popupopen', 'popupclose', 'draw:created', 'draw:edited', 'draw:deleted', 'draw:drawstart', 'draw:drawstop', 'draw:editstart', 'draw:editstop', 'draw:deletestart', 'draw:deletestop'];
+    };
+
+    var _genDispatchMapEvent = function _genDispatchMapEvent(scope, eventName, logic, maybeMapId) {
+        if (maybeMapId) {
+            maybeMapId = maybeMapId + '.';
+        }
+        return function (e) {
+            // Put together broadcast name
+            var broadcastName = 'leafletDirectiveMap.' + maybeMapId + eventName;
+            leafletLogger.debug(broadcastName);
+            // Safely broadcast the event
+            fire(scope, broadcastName, logic, e, e.target, scope);
+        };
+    };
+
+    var _notifyCenterChangedToBounds = function _notifyCenterChangedToBounds(scope) {
+        scope.$broadcast("boundsChanged");
+    };
+
+    var _notifyCenterUrlHashChanged = function _notifyCenterUrlHashChanged(scope, map, attrs, search) {
+        if (!isDefined(attrs.urlHashCenter)) {
+            return;
+        }
+        var center = map.getCenter();
+        var centerUrlHash = center.lat.toFixed(4) + ":" + center.lng.toFixed(4) + ":" + map.getZoom();
+        if (!isDefined(search.c) || search.c !== centerUrlHash) {
+            //$log.debug("notified new center...");
+            scope.$emit("centerUrlHash", centerUrlHash);
+        }
+    };
+
+    var _addEvents = function _addEvents(map, mapId, mapEvents, contextName, scope, logic) {
+        leafletIterators.each(mapEvents, function (eventName) {
+            var context = {};
+            context[contextName] = eventName;
+            if (!mapId) {
+                mapId = map._container.id || '';
+            }
+
+            map.on(eventName, _genDispatchMapEvent(scope, eventName, logic, mapId), context);
+        });
+    };
+
+    return {
+        getAvailableMapEvents: _getAvailableMapEvents,
+        genDispatchMapEvent: _genDispatchMapEvent,
+        notifyCenterChangedToBounds: _notifyCenterChangedToBounds,
+        notifyCenterUrlHashChanged: _notifyCenterUrlHashChanged,
+        addEvents: _addEvents
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletMarkerEvents', ["$rootScope", "$q", "leafletLogger", "leafletHelpers", "leafletEventsHelpersFactory", "leafletLabelEvents", function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory, leafletLabelEvents) {
+    var safeApply = leafletHelpers.safeApply,
+        isDefined = leafletHelpers.isDefined,
+        Helpers = leafletHelpers,
+        lblHelp = leafletLabelEvents,
+        EventsHelper = leafletEventsHelpersFactory,
+        $log = leafletLogger;
+
+    var MarkerEvents = function MarkerEvents() {
+        EventsHelper.call(this, 'leafletDirectiveMarker', 'markers');
+    };
+
+    MarkerEvents.prototype = new EventsHelper();
+
+    MarkerEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        var handle = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName);
+        return function (e) {
+            // Broadcast old marker click name for backwards compatibility
+            if (eventName === "click") {
+                safeApply(leafletScope, function () {
+                    $rootScope.$broadcast('leafletDirectiveMarkersClick', name);
+                });
+            } else if (eventName === 'dragend') {
+                safeApply(leafletScope, function () {
+                    model.lat = lObject.getLatLng().lat;
+                    model.lng = lObject.getLatLng().lng;
+                });
+                if (model.message && model.focus === true) {
+                    lObject.openPopup();
+                }
+            }
+            handle(e); //common
+        };
+    };
+
+    MarkerEvents.prototype.getAvailableEvents = function () {
+        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu', 'dragstart', 'drag', 'dragend', 'move', 'remove', 'popupopen', 'popupclose', 'touchend', 'touchstart', 'touchmove', 'touchcancel', 'touchleave'];
+    };
+
+    MarkerEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {
+        var logic = EventsHelper.prototype.bindEvents.call(this, maybeMapId, lObject, name, model, leafletScope, layerName);
+
+        if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {
+            lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model, layerName);
+        }
+    };
+
+    return new MarkerEvents();
+}]);
+
+'use strict';
+
+var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
+
+angular.module('ui-leaflet').factory('leafletPathEvents', ["$rootScope", "$q", "leafletLogger", "leafletHelpers", "leafletLabelEvents", "leafletEventsHelpers", function ($rootScope, $q, leafletLogger, leafletHelpers, leafletLabelEvents, leafletEventsHelpers) {
+    var isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        Helpers = leafletHelpers,
+        errorHeader = leafletHelpers.errorHeader,
+        lblHelp = leafletLabelEvents,
+        fire = leafletEventsHelpers.fire,
+        $log = leafletLogger;
+
+    /*
+    TODO (nmccready) This EventsHelper needs to be derrived from leafletEventsHelpers to elminate copy and paste code.
+    */
+
+    var _genDispatchPathEvent = function _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        maybeMapId = maybeMapId || '';
+
+        if (maybeMapId) maybeMapId = '.' + maybeMapId;
+
+        return function (e) {
+            var broadcastName = 'leafletDirectivePath' + maybeMapId + '.' + eventName;
+            $log.debug(broadcastName);
+            fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName);
+        };
+    };
+
+    var _bindPathEvents = function _bindPathEvents(maybeMapId, lObject, name, model, leafletScope) {
+        var pathEvents = [],
+            i,
+            eventName,
+            logic = "broadcast";
+
+        if (!isDefined(leafletScope.eventBroadcast)) {
+            // Backward compatibility, if no event-broadcast attribute, all events are broadcasted
+            pathEvents = _getAvailablePathEvents();
+        } else if (!isObject(leafletScope.eventBroadcast)) {
+            // Not a valid object
+            $log.error(errorHeader + "event-broadcast must be an object check your model.");
+        } else {
+            // We have a possible valid object
+            if (!isDefined(leafletScope.eventBroadcast.path)) {
+                // We do not have events enable/disable do we do nothing (all enabled by default)
+                pathEvents = _getAvailablePathEvents();
+            } else if (isObject(leafletScope.eventBroadcast.paths)) {
+                // Not a valid object
+                $log.warn(errorHeader + "event-broadcast.path must be an object check your model.");
+            } else {
+                // We have a possible valid map object
+                // Event propadation logic
+                if (leafletScope.eventBroadcast.path.logic !== undefined && leafletScope.eventBroadcast.path.logic !== null) {
+                    // We take care of possible propagation logic
+                    if (leafletScope.eventBroadcast.path.logic !== "emit" && leafletScope.eventBroadcast.path.logic !== "broadcast") {
+                        // This is an error
+                        $log.warn(errorHeader + "Available event propagation logic are: 'emit' or 'broadcast'.");
+                    } else if (leafletScope.eventBroadcast.path.logic === "emit") {
+                        logic = "emit";
+                    }
+                }
+                // Enable / Disable
+                var pathEventsEnable = false,
+                    pathEventsDisable = false;
+                if (leafletScope.eventBroadcast.path.enable !== undefined && leafletScope.eventBroadcast.path.enable !== null) {
+                    if (_typeof(leafletScope.eventBroadcast.path.enable) === 'object') {
+                        pathEventsEnable = true;
+                    }
+                }
+                if (leafletScope.eventBroadcast.path.disable !== undefined && leafletScope.eventBroadcast.path.disable !== null) {
+                    if (_typeof(leafletScope.eventBroadcast.path.disable) === 'object') {
+                        pathEventsDisable = true;
+                    }
+                }
+                if (pathEventsEnable && pathEventsDisable) {
+                    // Both are active, this is an error
+                    $log.warn(errorHeader + "can not enable and disable events at the same time");
+                } else if (!pathEventsEnable && !pathEventsDisable) {
+                    // Both are inactive, this is an error
+                    $log.warn(errorHeader + "must enable or disable events");
+                } else {
+                    // At this point the path object is OK, lets enable or disable events
+                    if (pathEventsEnable) {
+                        // Enable events
+                        for (i = 0; i < leafletScope.eventBroadcast.path.enable.length; i++) {
+                            eventName = leafletScope.eventBroadcast.path.enable[i];
+                            // Do we have already the event enabled?
+                            if (pathEvents.indexOf(eventName) !== -1) {
+                                // Repeated event, this is an error
+                                $log.warn(errorHeader + "This event " + eventName + " is already enabled");
+                            } else {
+                                // Does the event exists?
+                                if (_getAvailablePathEvents().indexOf(eventName) === -1) {
+                                    // The event does not exists, this is an error
+                                    $log.warn(errorHeader + "This event " + eventName + " does not exist");
+                                } else {
+                                    // All ok enable the event
+                                    pathEvents.push(eventName);
+                                }
+                            }
+                        }
+                    } else {
+                        // Disable events
+                        pathEvents = _getAvailablePathEvents();
+                        for (i = 0; i < leafletScope.eventBroadcast.path.disable.length; i++) {
+                            eventName = leafletScope.eventBroadcast.path.disable[i];
+                            var index = pathEvents.indexOf(eventName);
+                            if (index === -1) {
+                                // The event does not exist
+                                $log.warn(errorHeader + "This event " + eventName + " does not exist or has been already disabled");
+                            } else {
+                                pathEvents.splice(index, 1);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        for (i = 0; i < pathEvents.length; i++) {
+            eventName = pathEvents[i];
+            lObject.on(eventName, _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, pathEvents, name));
+        }
+
+        if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {
+            lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model);
+        }
+    };
+
+    var _getAvailablePathEvents = function _getAvailablePathEvents() {
+        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu', 'add', 'remove', 'popupopen', 'popupclose'];
+    };
+
+    return {
+        getAvailablePathEvents: _getAvailablePathEvents,
+        bindPathEvents: _bindPathEvents
+    };
+}]);
+
+}(angular));
\ No newline at end of file
Index: bower_components/ui-leaflet/grunt/concurrent.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/concurrent.js	(revision )
+++ bower_components/ui-leaflet/grunt/concurrent.js	(revision )
@@ -0,0 +1,30 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        watchServe: {
+            tasks: ['watch:fast', 'connect:webserver'],
+            options: {
+                logConcurrentOutput: true
+            }
+        },
+        unit: {
+            tasks: ['karma', 'watch:unit'],
+            options: {
+                logConcurrentOutput: true
+            }
+        },
+        dev: {
+            tasks: ['karma', 'watch:unit', 'watch:source'],
+            options: {
+                logConcurrentOutput: true
+            }
+        },
+        website: {
+            tasks: ['concat:website', 'watch:website', 'connect:webserver'],
+            options: {
+                logConcurrentOutput: true
+            }
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/utils/getAvailPort.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/utils/getAvailPort.js	(revision )
+++ bower_components/ui-leaflet/grunt/utils/getAvailPort.js	(revision )
@@ -0,0 +1,23 @@
+var exec = require('shelljs').exec;
+
+var isWin = /^win/.test(process.platform);
+
+var isPortOpen = function (port) {
+    var cmd;
+    if (isWin)
+        cmd = 'netstat -an | find /i ":' + port + '" | find /i "listening"';
+    else
+        cmd = 'lsof -i:' + port + " | tail -n 1 | awk '{print $2}'";
+    var portResponse = exec(cmd, {
+        silent: true
+    }).output;
+    return portResponse ? false : true;
+}
+
+module.exports = function (startPort) {
+    while (!isPortOpen(startPort)) {
+        startPort += 1;
+    }
+
+    return startPort;
+}
Index: bower_components/ui-leaflet/generate-examples.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/generate-examples.js	(revision )
+++ bower_components/ui-leaflet/generate-examples.js	(revision )
@@ -0,0 +1,205 @@
+#!/usr/bin/env node
+
+'use strict';
+
+var fs = require('fs');
+var path = require('path');
+var mkdirp = require('mkdirp');
+var jsdom = require('jsdom');
+var Q = require('q');
+
+var onlyStandAlone = [
+    "0117-basic-routing-show-hide-map-example.html"
+];
+
+var isAnExample = function(filename) {
+    if (filename === '0000-viewer.html') {
+      return false;
+    }
+    return /[0-9][0-9][0-9][0-9].*\.html/.test(filename);
+};
+
+var isJavascript = function(filename) {
+    return /.*\.js/.test(filename);
+};
+
+var deleteFileIfJavascript = function(filename) {
+    var df = Q.defer();
+    if (isJavascript(filename)) {
+        fs.unlink(filename, function() {
+            df.resolve();
+        });
+    } else {
+        df.resolve();
+    }
+
+    return df.promise;
+};
+
+var cleanJavascriptFilesFromControllersDirectory = function(dir) {
+    var df = Q.defer();
+    fs.readdir(dir, function(err, list) {
+        var l = [];
+        var files = list.map(function(file) {
+            return path.join(dir, file);
+        });
+        files.forEach(deleteFileIfJavascript);
+        Q.allSettled(l).then(function(result) {
+            df.resolve();
+        });
+    });
+    return df.promise;
+};
+
+var writeController = function(script, examplefile, controllers_directory) {
+    var df = Q.defer();
+    var scriptLines = script.split('\n');
+    var outfilename;
+    var outScript = [];
+    for (var i = 0; i < scriptLines.length; i++) {
+
+        var line = scriptLines[i];
+
+        // Remove empty lines
+        if (line.replace(/^\s+|\s+$/g, '') === '') {
+            continue;
+        }
+
+        // Remove the module initializacion line
+        if (line.search('angular.module') !== -1) {
+            continue;
+        }
+
+        // Extract controller name
+        if (line.search('app.controller') !== -1 && !outfilename) {
+            var controller = line.match(/app.controller\((\'|\")([^'"]*)/);
+            if (controller && controller.length > 2 && controller[2]) {
+                outfilename = controller[2] + '.js';
+            }
+        }
+
+        outScript.push(line);
+    }
+
+    if (outfilename) {
+        outfilename = path.join(controllers_directory, outfilename);
+        if (!fs.existsSync(outfilename)) {
+            fs.writeFile(outfilename, outScript.join('\n'), function() {
+                df.resolve();
+            });
+        } else {
+            console.log('The controller name is duplicated: ' + outfilename)
+            df.reject();
+        }
+    } else {
+        console.log('Can\'t identify the controller name in the example ' + examplefile)
+        df.reject();
+    }
+
+    return df.promise;
+};
+
+var generateControllersFromExamples = function(examples_directory, controllers_directory) {
+    var df = Q.defer();
+    fs.readdir(examples_directory, function(err, list) {
+        var l = [];
+        list.forEach(function(filename) {
+            if (isAnExample(filename)) {
+                var html = fs.readFileSync(path.join(__dirname, 'examples', filename));
+                jsdom.env({
+                    html: html.toString(),
+                    done: function(err, window) {
+                        var scripts = window.document.getElementsByTagName('script');
+                        var last = scripts.length -1;
+                        var script = scripts[last].innerHTML;
+                        l.push(writeController(script, filename, controllers_directory));
+                    }
+                });
+            }
+        });
+
+        Q.allSettled(l).then(function() {
+            df.resolve();
+        });
+    });
+
+    return df.promise;
+};
+
+var extractId = function(filename) {
+    var arr = filename.replace('.html', '').split('-');
+    arr.splice(0,2);
+    return arr.join('-');
+};
+
+var extractTitle = function(filename) {
+    var html = fs.readFileSync(path.join(__dirname, 'examples', filename));
+    var title;
+    var arr = html.toString().split('\n');
+
+    for (var i = 0; i< arr.length; i++) {
+        var line = arr[i];
+
+        if (line.search('<h1>') !== -1) {
+            title = line.replace('<h1>', '').replace('</h1>', '').replace(/^ */, '');
+        }
+    }
+
+    return title;
+};
+
+var extractDescription = function(filename) {
+
+};
+
+var extractDate = function(filename) {
+    var stats = fs.statSync(filename);
+    return stats.mtime;
+};
+
+var generateExamplesJSONFile = function(examples_directory, json_file) {
+    var df = Q.defer();
+    var examples = {};
+    fs.readdir(examples_directory, function(err, list) {
+        list.forEach(function(filename) {
+            if (isAnExample(filename)) {
+                var section = filename.split('-')[1];
+                var id = extractId(filename);
+                var extUrl = filename;
+                var title = extractTitle(filename);
+                var description = extractDescription(filename);
+                var date = extractDate(path.join(examples_directory, filename));
+
+                if (!(section in examples)) {
+                    examples[section] = [];
+                }
+                examples[section].push({
+                    date: date,
+                    section: section,
+                    onlyStandAlone: onlyStandAlone.indexOf(extUrl) !== -1,
+                    id: '/' + section + '/' + id,
+                    extUrl: extUrl,
+                    title: title,
+                    description: description
+                });
+            }
+        });
+
+        fs.writeFile(json_file, JSON.stringify(examples, null, 4), function(err) {
+            df.resolve();
+        });
+    });
+
+    return df.promise;
+};
+
+var controllers_directory = path.join(__dirname, 'examples', 'js', 'controllers');
+mkdirp(controllers_directory, function(err) {
+    cleanJavascriptFilesFromControllersDirectory(controllers_directory).then(function() {
+        var examples_directory = path.join(__dirname, 'examples');
+        generateControllersFromExamples(examples_directory, controllers_directory).then(function() {
+            var json_file = path.join(__dirname, 'examples', 'json', 'examples.json');
+            generateExamplesJSONFile(examples_directory, json_file);
+        });
+    });
+});
Index: bower_components/ui-leaflet/grunt/aliases.coffee
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/aliases.coffee	(revision )
+++ bower_components/ui-leaflet/grunt/aliases.coffee	(revision )
@@ -0,0 +1,51 @@
+module.exports =
+    test:[ 'jshint', 'testunit', 'teste2e']
+
+    testunit: ['karma']
+
+    teste2e:[ 'shell:protractor_update', 'connect:testserver', 'protractor:run']
+
+    teste2efirefox:[ 'shell:protractor_update', 'connect:testserver', 'protractor:firefox']
+
+    testcoverage: ['karma']
+
+    coverage:['karma', 'open:coverage', 'connect:coverage']
+
+    install:[ 'shell:npm_install','bower:install','shell:protractor_update']
+
+    default:['build']
+
+    # cause zsh always puts me in grunt folder
+    d:['default']
+
+    #force:on to keep failing specs from killing grunt
+    dev:['force:on', 'connect:devserver', 'open:devserver', 'concurrent:dev' ]
+
+    #continuos running specs
+    spec: [ 'fastbuild', 'concurrent:unit' ]
+
+    serve:['concurrent:watchServe']
+
+    s:['serve']
+
+    fastbuild:[ 'clean:dist', 'jshint' ,'babel', 'concat:dist', 'concat:distMapped', 'ngAnnotate']
+
+    dwatch:[ 'fastbuild', 'concurrent:unit' ]
+
+    build:[ 'fastbuild', 'uglify', 'testunit', 'concat:license', 'clean:pre' ]
+
+    travis:[ 'fastbuild', 'bower:install', 'testunit' ]
+
+    changelog: ['conventionalChangelog']
+
+    'bump@':[ 'bumponly', 'default', 'changelog', 'bumpcommit' ]
+
+    'bump@minor':[ 'bumponly:minor', 'default', 'changelog', 'bumpcommit' ]
+
+    'bump@major':[ 'bumponly:major', 'default', 'changelog', 'bumpcommit' ]
+    #To Update examples for Viewer
+    examples:[ 'shell:examples', 'concat:examples' ]
+
+    graph:['angular_architecture_graph']
+
+    website:['concurrent:website']
Index: rest_service.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- rest_service.js	(revision 25eea5333ab01c6d75fbbdd60df446ad600e0d90)
+++ rest_service.js	(revision )
@@ -15,8 +15,8 @@
         var json = [];
         for (var i = 0; i<array.length; i++){
             var object = {
-                lat: array[i].split(" ")[0] === undefined ? "" : array[i].split(" ")[0].trim(),
-                long: array[i].split(" ")[1] === undefined ? "" : array[i].split(" ")[1].trim()
+                lat: array[i].split(" ")[0] === undefined ? "" : parseFloat(array[i].split(" ")[0].trim()),
+                long: array[i].split(" ")[1] === undefined ? "" : parseFloat(array[i].split(" ")[1].trim())
             };
             json.push(object);
         }
Index: assets/less/app.less
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- assets/less/app.less	(revision 25eea5333ab01c6d75fbbdd60df446ad600e0d90)
+++ assets/less/app.less	(revision )
@@ -92,14 +92,76 @@
     display: none;
 }
 
+/**
+    Bottom Legend CSS
+*/
+
+
+/* basic positioning */
+.legend { list-style: none; margin-top: 20px;}
+.legend li { float: left; margin-right: 10px; }
+.legend span { border: 1px solid #ccc; float: left; width: 12px; height: 12px; margin: 2px; }
+/* your colors */
+.legend .gas_station_locations { background-color: #0000ff; }
+
+/**
+    Toggle Switch UI
+*/
+
+.onoffswitch {
+    position: relative; width: 77px;
+    -webkit-user-select:none; -moz-user-select:none; -ms-user-select: none;
+}
+.onoffswitch-checkbox {
+    display: none;
+}
+.onoffswitch-label {
+    display: block; overflow: hidden; cursor: pointer;
+    border: 2px solid #FFFFFF; border-radius: 50px;
+}
+.onoffswitch-inner {
+    display: block; width: 200%; margin-left: -100%;
+    transition: margin 0.3s ease-in 0s;
+}
+.onoffswitch-inner:before, .onoffswitch-inner:after {
+    display: block; float: left; width: 50%; height: 28px; padding: 0; line-height: 28px;
+    font-size: 14px; color: white; font-family: Trebuchet, Arial, sans-serif; font-weight: bold;
+    box-sizing: border-box;
+}
+.onoffswitch-inner:before {
+    content: "ON";
+    padding-left: 10px;
+    background-color: #34A7C1; color: #FFFFFF;
+}
+.onoffswitch-inner:after {
+    content: "OFF";
+    padding-right: 10px;
+    background-color: #EEEEEE; color: #999999;
+    text-align: right;
+}
+.onoffswitch-switch {
+    display: block; width: 15px; margin: 6.5px;
+    background: #FFFFFF;
+    position: absolute; top: 0; bottom: 0;
+    right: 45px;
+    border: 2px solid #FFFFFF; border-radius: 50px;
+    transition: all 0.3s ease-in 0s;
+}
+.onoffswitch-checkbox:checked + .onoffswitch-label .onoffswitch-inner {
+    margin-left: 0;
+}
+.onoffswitch-checkbox:checked + .onoffswitch-label .onoffswitch-switch {
+    right: 0px;
+}
+
 /* Personal preference for BS modal.  The LESS below makes the backdrop white and
    causes the modal to fade in rather than slide in. */
-//@modal-backdrop-bg: white;
-//.modal {
-//	&.fade {
-//		.transition(opacity .3s);
-//	}
-//	&.fade .modal-dialog {
-//		.translate(0,0);
-//	}
-//}
+@modal-backdrop-bg: white;
+.modal {
+	&.fade {
+		.transition(opacity .3s);
+	}
+	&.fade .modal-dialog {
+		.translate(0,0);
+	}
+}
Index: bower_components/ui-leaflet/grunt/concat.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/concat.js	(revision )
+++ bower_components/ui-leaflet/grunt/concat.js	(revision )
@@ -0,0 +1,54 @@
+'use strict';
+
+var concatDist, concatDistMapped = null;
+
+concatDist = {
+    options: {
+        banner: require('./utils/banner') + "(function(angular){\n" + "'use strict';\n",
+        footer: '\n}(angular));'
+    },
+    src: [
+        'dist/src/directives/leaflet.js',
+        'dist/src/services/*.js',
+        'dist/src/**/*.js'
+
+    ],
+    dest: 'dist/<%= pkg.name %>.pre.js'
+};
+
+concatDistMapped = _.clone(concatDist, true);
+concatDistMapped.options.sourceMap = true;
+concatDistMapped.options.sourceMapName = "dist/<%= pkg.name %>_dev_mapped.js.map";
+concatDistMapped.dest = "dist/<%= pkg.name %>_dev_mapped.js";
+
+
+module.exports = function (grunt, options) {
+    return {
+        dist: concatDist,
+        distMapped: concatDistMapped,
+        license: {
+            src: [
+                'src/header-MIT-license.txt',
+                'dist/<%= pkg.name %>.min.no-header.js'
+            ],
+            dest: 'dist/<%= pkg.name %>.min.js'
+        },
+        examples: {
+            options: {
+                banner: '(function(angular){ \nvar app = angular.module(\'webapp\');\n',
+                footer: '}(angular));'
+            },
+            src: ['examples/js/controllers/*.js'],
+            dest: 'examples/js/controllers.js'
+        },
+        website: {
+            options: {
+                //separator: ';',
+                banner: '(function (angular) {\n',
+                footer: '})(window.angular);'
+            },
+            src: ['website/src/js/app.js', 'website/src/js/**/*.js'],
+            dest: 'website/dist/js/<%= pkg.name %>-webpage.js',
+        }
+    };
+};
Index: bower_components/ui-leaflet/dist/ui-leaflet.min.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/dist/ui-leaflet.min.js	(revision )
+++ bower_components/ui-leaflet/dist/ui-leaflet.min.js	(revision )
@@ -0,0 +1,39 @@
+/**!
+ * The MIT License
+ *
+ * Copyright (c) the ui-leaflet Team, http://angular-ui.github.io/ui-leaflet
+ *
+ * Original Copyright (c) https://github.com/angular-ui/ui-leaflet
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * ui-leaflet
+ * https://github.com/angular-ui/ui-leaflet
+ *
+ * @authors https://github.com/angular-ui/ui-leaflet/graphs/contributors
+ */
+
+/*!
+*  ui-leaflet 2.0.0 2016-10-04
+*  ui-leaflet - An AngularJS directive to easily interact with Leaflet maps
+*  git: https://github.com/angular-ui/ui-leaflet
+*/
+!function(a){"use strict";a.module("ui-leaflet",["nemLogging"]).directive("leaflet",["$q","leafletData","leafletMapDefaults","leafletHelpers","leafletMapEvents",function(a,b,c,d,e){return{restrict:"EA",replace:!0,scope:{center:"=",lfCenter:"=",defaults:"=",maxbounds:"=",bounds:"=",markers:"=",legend:"=",geojson:"=",paths:"=",tiles:"=",layers:"=",controls:"=",decorations:"=",eventBroadcast:"=",watchOptions:"=",id:"@"},transclude:!0,template:'<div class="angular-leaflet-map"><div ng-transclude></div></div>',controller:["$scope",function(b){this._leafletMap=a.defer(),this.getMap=function(){return this._leafletMap.promise},this.getLeafletScope=function(){return b}}],link:function(a,f,g,h){function i(){isNaN(g.width)?f.css("width",g.width):f.css("width",g.width+"px")}function j(){isNaN(g.height)?f.css("height",g.height):f.css("height",g.height+"px")}var k=d.isDefined,l=c.setDefaults(a.defaults,g.id),m=e.getAvailableMapEvents(),n=e.addEvents;a.mapId=g.id,b.setDirectiveControls({},g.id);var o=new L.Map(f[0],c.getMapCreationDefaults(g.id));if(h._leafletMap.resolve(o),k(g.width)&&(i(),a.$watch(function(){return f[0].getAttribute("width")},function(){i(),o.invalidateSize()})),k(g.height)&&(j(),a.$watch(function(){return f[0].getAttribute("height")},function(){j(),o.invalidateSize()})),k(g.center)||k(g.lfCenter)||o.setView([l.center.lat,l.center.lng],l.center.zoom),!k(g.tiles)&&!k(g.layers)){var p=L.tileLayer(l.tileLayer,l.tileLayerOptions);p.addTo(o),b.setTiles(p,g.id)}if(k(o.zoomControl)&&k(l.zoomControlPosition)&&o.zoomControl.setPosition(l.zoomControlPosition),k(o.zoomControl)&&l.zoomControl===!1&&o.zoomControl.removeFrom(o),k(o.zoomsliderControl)&&k(l.zoomsliderControl)&&l.zoomsliderControl===!1&&o.zoomsliderControl.removeFrom(o),!k(g.eventBroadcast)){var q="broadcast";n(o,g.id,m,"eventName",a,q)}o.whenReady(function(){b.setMap(o,g.id)}),a.$on("$destroy",function(){c.reset(),o.remove(),b.unresolveMap(g.id)}),a.$on("invalidateSize",function(){o.invalidateSize()})}}}]),function(){a.module("ui-leaflet").factory("eventManager",[function(){var a=function(){this.listeners={}};return a.prototype={addEventListener:function(a,b,c){for(var d=[],e=arguments.length,f=0;f<e;f++)d.push(arguments[f]);d=d.length>3?d.splice(3,d.length-1):[],"undefined"!=typeof this.listeners[a]?this.listeners[a].push({scope:c,callback:b,args:d}):this.listeners[a]=[{scope:c,callback:b,args:d}]},removeEventListener:function(a,b,c){if("undefined"!=typeof this.listeners[a]){for(var d=this.listeners[a].length,e=[],f=0;f<d;f++){var g=this.listeners[a][f];g.scope===c&&g.callback===b||e.push(g)}this.listeners[a]=e}},hasEventListener:function(a,b,c){if("undefined"!=typeof this.listeners[a]){var d=this.listeners[a].length;if(void 0===b&&void 0===c)return d>0;for(var e=0;e<d;e++){var f=this.listeners[a][e];if((!c||f.scope===c)&&f.callback===b)return!0}}return!1},dispatch:function(a,b){for(var c=0,d={type:a,target:b},e=[],f=arguments.length,g=0;g<f;g++)e.push(arguments[g]);if(e=e.length>2?e.splice(2,e.length-1):[],e=[d].concat(e),"undefined"!=typeof this.listeners[a])for(var h=this.listeners[a].length,i=0;i<h;i++){var j=this.listeners[a][i];if(j&&j.callback){var k=e.concat(j.args);j.callback.apply(j.scope,k),c+=1}}},getEvents:function(){var a="";for(var b in this.listeners)for(var c=this.listeners[b].length,d=0;d<c;d++){var e=this.listeners[b][d];a+=e.scope&&e.scope.className?e.scope.className:"anonymous",a+=" listen for '"+b+"'\n"}return a}},a}]).service("eventManager",["EventManager",function(a){return new a}])}(),a.module("ui-leaflet").factory("leafletBoundsHelpers",["leafletLogger","leafletHelpers",function(b,c){function d(b){return a.isDefined(b)&&a.isDefined(b.southWest)&&a.isDefined(b.northEast)&&a.isNumber(b.southWest.lat)&&a.isNumber(b.southWest.lng)&&a.isNumber(b.northEast.lat)&&a.isNumber(b.northEast.lng)}var e=c.isArray,f=c.isNumber,g=c.isFunction,h=c.isDefined,i=b;return{createLeafletBounds:function(a){if(d(a))return L.latLngBounds([a.southWest.lat,a.southWest.lng],[a.northEast.lat,a.northEast.lng])},isValidBounds:d,createBoundsFromArray:function(a){return e(a)&&2===a.length&&e(a[0])&&e(a[1])&&2===a[0].length&&2===a[1].length&&f(a[0][0])&&f(a[0][1])&&f(a[1][0])&&f(a[1][1])?{northEast:{lat:a[0][0],lng:a[0][1]},southWest:{lat:a[1][0],lng:a[1][1]}}:void i.error("[AngularJS - Leaflet] The bounds array is not valid.")},createBoundsFromLeaflet:function(a){if(!(h(a)&&g(a.getNorthEast)&&g(a.getSouthWest)))return void i.error("[AngularJS - Leaflet] The leaflet bounds is not valid object.");var b=a.getNorthEast(),c=a.getSouthWest();return{northEast:{lat:b.lat,lng:b.lng},southWest:{lat:c.lat,lng:c.lng}}}}}]),a.module("ui-leaflet").factory("leafletControlHelpers",["$rootScope","leafletLogger","leafletHelpers","leafletLayerHelpers","leafletMapDefaults",function(b,c,d,e,f){var g=d.isDefined,h=d.isObject,i=e.createLayer,j={},k=d.errorHeader+" [Controls] ",l=c,m=function(a,b,c){var d=f.getDefaults(c);if(!d.controls.layers.visible)return!1;var e=!1;return h(a)&&Object.keys(a).forEach(function(b){var c=a[b];g(c.layerOptions)&&c.layerOptions.showOnSelector===!1||(e=!0)}),h(b)&&Object.keys(b).forEach(function(a){var c=b[a];g(c.layerParams)&&c.layerParams.showOnSelector===!1||(e=!0)}),e},n=function(b){var c=f.getDefaults(b),d={collapsed:c.controls.layers.collapsed,position:c.controls.layers.position,autoZIndex:!1};a.extend(d,c.controls.layers.options);var e;return e=c.controls.layers&&g(c.controls.layers.control)?c.controls.layers.control.apply(this,[[],[],d]):new L.control.layers([],[],d)},o={draw:{isPluginLoaded:function(){return!!a.isDefined(L.Control.Draw)||(l.error(k+" Draw plugin is not loaded."),!1)},checkValidParams:function(){return!0},createControl:function(a){return new L.Control.Draw(a)}},scale:{isPluginLoaded:function(){return!0},checkValidParams:function(){return!0},createControl:function(a){return new L.control.scale(a)}},fullscreen:{isPluginLoaded:function(){return!!a.isDefined(L.Control.Fullscreen)||(l.error(k+" Fullscreen plugin is not loaded."),!1)},checkValidParams:function(){return!0},createControl:function(a){return new L.Control.Fullscreen(a)}},search:{isPluginLoaded:function(){return!!a.isDefined(L.Control.Search)||(l.error(k+" Search plugin is not loaded."),!1)},checkValidParams:function(){return!0},createControl:function(a){return new L.Control.Search(a)}},custom:{},minimap:{isPluginLoaded:function(){return!!a.isDefined(L.Control.MiniMap)||(l.error(k+" Minimap plugin is not loaded."),!1)},checkValidParams:function(a){return!!g(a.layer)||(l.warn(k+' minimap "layer" option should be defined.'),!1)},createControl:function(a){var b=i(a.layer);return g(b)?new L.Control.MiniMap(b,a):void l.warn(k+' minimap control "layer" could not be created.')}}};return{layersControlMustBeVisible:m,isValidControlType:function(a){return Object.keys(o).indexOf(a)!==-1},createControl:function(a,b){if(o[a].checkValidParams(b))return o[a].createControl(b)},updateLayersControl:function(a,b,c,d,e,f){var h,i=j[b],k=m(d,e,b);if(g(i)&&c){for(h in f.baselayers)i.removeLayer(f.baselayers[h]);for(h in f.overlays)i.removeLayer(f.overlays[h]);a.removeControl(i),delete j[b]}if(k){i=n(b),j[b]=i;for(h in d){var l=g(d[h].layerOptions)&&d[h].layerOptions.showOnSelector===!1;!l&&g(f.baselayers[h])&&i.addBaseLayer(f.baselayers[h],d[h].name)}for(h in e){var o=g(e[h].layerParams)&&e[h].layerParams.showOnSelector===!1;!o&&g(f.overlays[h])&&i.addOverlay(f.overlays[h],e[h].name)}a.addControl(i)}return k},destroyMapLayersControl:function(a){delete j[a]}}}]),a.module("ui-leaflet").service("leafletData",["leafletLogger","$q","leafletHelpers",function(a,b,c){var d=c.getDefer,e=c.getUnresolvedDefer,f=c.setResolvedDefer,g={},h=this,i=function(a){return a.charAt(0).toUpperCase()+a.slice(1)},j=["map","tiles","layers","paths","markers","geoJSON","UTFGrid","decorations","directiveControls"];j.forEach(function(a){g[a]={}}),this.unresolveMap=function(a){var b=c.obtainEffectiveMapId(g.map,a);j.forEach(function(a){g[a][b]=void 0})},j.forEach(function(a){var b=i(a);h["set"+b]=function(b,c){var d=e(g[a],c);d.resolve(b),f(g[a],c)},h["get"+b]=function(b){var c=d(g[a],b);return c.promise}})}]),a.module("ui-leaflet").service("leafletDirectiveControlsHelpers",["leafletLogger","leafletData","leafletHelpers",function(b,c,d){var e=d.isDefined,f=d.isString,g=d.isObject,h=d.errorHeader,i=b,j=h+"[leafletDirectiveControlsHelpers",k=function(b,d,h,k){var l=j+".extend] ",m={};if(!e(d))return void i.error(l+"thingToAddName cannot be undefined");if(f(d)&&e(h)&&e(k))m[d]={create:h,clean:k};else{if(!g(d)||e(h)||e(k))return void i.error(l+"incorrect arguments");m=d}c.getDirectiveControls().then(function(d){a.extend(d,m),c.setDirectiveControls(d,b)})};return{extend:k}}]),a.module("ui-leaflet").service("leafletGeoJsonHelpers",["leafletHelpers","leafletIterators",function(b,c){var d=b,e=c,f=function(a,b){return this.lat=a,this.lng=b,this},g=function(a){return Array.isArray(a)&&2===a.length?a[1]:d.isDefined(a.type)&&"Point"===a.type?+a.coordinates[1]:+a.lat},h=function(a){return Array.isArray(a)&&2===a.length?a[0]:d.isDefined(a.type)&&"Point"===a.type?+a.coordinates[0]:+a.lng},i=function(a){if(d.isUndefined(a))return!1;if(d.isArray(a)){if(2===a.length&&d.isNumber(a[0])&&d.isNumber(a[1]))return!0}else if(d.isDefined(a.type)&&"Point"===a.type&&d.isArray(a.coordinates)&&2===a.coordinates.length&&d.isNumber(a.coordinates[0])&&d.isNumber(a.coordinates[1]))return!0;var b=e.all(["lat","lng"],function(b){return d.isDefined(a[b])&&d.isNumber(a[b])});return b},j=function(b){if(b&&i(b)){var c=null;if(Array.isArray(b)&&2===b.length)c=new f(b[1],b[0]);else{if(!d.isDefined(b.type)||"Point"!==b.type)return b;c=new f(b.coordinates[1],b.coordinates[0])}return a.extend(b,c)}};return{getLat:g,getLng:h,validateCoords:i,getCoords:j}}]),a.module("ui-leaflet").service("leafletHelpers",["$q","$log","$timeout",function(b,c,d){function e(b,d){var e,f;if(a.isDefined(d))e=d;else if(0===Object.keys(b).length)e="main";else if(Object.keys(b).length>=1)for(f in b)b.hasOwnProperty(f)&&(e=f);else c.error(g+"- You have more than 1 map on the DOM, you must provide the map ID to the leafletData.getXXX call");return e}function f(c,d){var f,g=e(c,d);return a.isDefined(c[g])&&c[g].resolvedDefer!==!0?f=c[g].defer:(f=b.defer(),c[g]={defer:f,resolvedDefer:!1}),f}var g="[ui-leaflet] ",h=a.copy,i=h,j=function(b,c){var d;if(b&&a.isObject(b))return null!==c&&a.isString(c)?(d=b,c.split(".").forEach(function(a){d&&(d=d[a])}),d):c},k=function(a){return a.split(".").reduce(function(a,b){return a+'["'+b+'"]'})},l=function(a){return a.reduce(function(a,b){return a+"."+b})},m=function(b){return a.isDefined(b)&&null!==b},n=function(a){return!m(a)},o=/([\:\-\_]+(.))/g,p=/^moz([A-Z])/,q=/^((?:x|data)[\:\-_])/i,r=function(a){return a.replace(o,function(a,b,c,d){return d?c.toUpperCase():c}).replace(p,"Moz$1")},s=function(a){return r(a.replace(q,""))},t=10,u=function(a,b,c){if(!a)throw new Error(g+"trapObj is undefined");if(!b)throw new Error(g+"trapField is undefined");a[b]=!0;var e=c();return d(function(){a[b]=!1},t),e};return{watchTrapDelayMilliSec:t,modelChangeInDirective:u,camelCase:r,directiveNormalize:s,copy:h,clone:i,errorHeader:g,getObjectValue:j,getObjectArrayPath:k,getObjectDotPath:l,defaultTo:function(a,b){return m(a)?a:b},isTruthy:function(a){return"true"===a||a===!0},isEmpty:function(a){return 0===Object.keys(a).length},isUndefinedOrEmpty:function(b){return a.isUndefined(b)||null===b||0===Object.keys(b).length},isDefined:m,isUndefined:n,isNumber:a.isNumber,isString:a.isString,isArray:a.isArray,isObject:a.isObject,isFunction:a.isFunction,equals:a.equals,isValidCenter:function(b){return a.isDefined(b)&&a.isNumber(b.lat)&&a.isNumber(b.lng)&&a.isNumber(b.zoom)},isValidPoint:function(b){return!!a.isDefined(b)&&(a.isArray(b)?2===b.length&&a.isNumber(b[0])&&a.isNumber(b[1]):a.isNumber(b.lat)&&a.isNumber(b.lng))},isSameCenterOnMap:function(a,b){var c=b.getCenter(),d=b.getZoom();return!(!a.lat||!a.lng||c.lat.toFixed(4)!==a.lat.toFixed(4)||c.lng.toFixed(4)!==a.lng.toFixed(4)||d!==a.zoom)},safeApply:function(a,b){var c=a.$root.$$phase;"$apply"===c||"$digest"===c?a.$eval(b):a.$evalAsync(b)},obtainEffectiveMapId:e,getDefer:function(b,c){var d,g=e(b,c);return d=a.isDefined(b[g])&&b[g].resolvedDefer!==!1?b[g].defer:f(b,c)},getUnresolvedDefer:f,setResolvedDefer:function(a,b){var c=e(a,b);a[c].resolvedDefer=!0},rangeIsSupported:function(){var a=document.createElement("input");return a.setAttribute("type","range"),"range"===a.type},FullScreenControlPlugin:{isLoaded:function(){return a.isDefined(L.Control.Fullscreen)}},MiniMapControlPlugin:{isLoaded:function(){return a.isDefined(L.Control.MiniMap)}},AwesomeMarkersPlugin:{isLoaded:function(){return a.isDefined(L.AwesomeMarkers)&&a.isDefined(L.AwesomeMarkers.Icon)},is:function(a){return!!this.isLoaded()&&a instanceof L.AwesomeMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},VectorMarkersPlugin:{isLoaded:function(){return a.isDefined(L.VectorMarkers)&&a.isDefined(L.VectorMarkers.Icon)},is:function(a){return!!this.isLoaded()&&a instanceof L.VectorMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},DomMarkersPlugin:{isLoaded:function(){return!(!a.isDefined(L.DomMarkers)||!a.isDefined(L.DomMarkers.Icon))},is:function(a){return!!this.isLoaded()&&a instanceof L.DomMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},PolylineDecoratorPlugin:{isLoaded:function(){return!!a.isDefined(L.PolylineDecorator)},is:function(a){return!!this.isLoaded()&&a instanceof L.PolylineDecorator},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},MakiMarkersPlugin:{isLoaded:function(){return!(!a.isDefined(L.MakiMarkers)||!a.isDefined(L.MakiMarkers.Icon))},is:function(a){return!!this.isLoaded()&&a instanceof L.MakiMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},ExtraMarkersPlugin:{isLoaded:function(){return!(!a.isDefined(L.ExtraMarkers)||!a.isDefined(L.ExtraMarkers.Icon))},is:function(a){return!!this.isLoaded()&&a instanceof L.ExtraMarkers.Icon},equal:function(b,c){return!!this.isLoaded()&&(!!this.is(b)&&a.equals(b,c))}},LabelPlugin:{isLoaded:function(){return a.isDefined(L.Label)},is:function(a){return!!this.isLoaded()&&a instanceof L.MarkerClusterGroup}},MarkerClusterPlugin:{isLoaded:function(){return a.isDefined(L.MarkerClusterGroup)},is:function(a){return!!this.isLoaded()&&a instanceof L.MarkerClusterGroup}},GeoJSONPlugin:{isLoaded:function(){return a.isDefined(L.TileLayer.GeoJSON)},is:function(a){return!!this.isLoaded()&&a instanceof L.TileLayer.GeoJSON}},CartoDB:{isLoaded:function(){return cartodb},is:function(){return!0}},Leaflet:{DivIcon:{is:function(a){return a instanceof L.DivIcon},equal:function(b,c){return!!this.is(b)&&a.equals(b,c)}},Icon:{is:function(a){return a instanceof L.Icon},equal:function(b,c){return!!this.is(b)&&a.equals(b,c)}}},watchOptions:{type:"watchDeep",individual:{type:"watchDeep"}}}}]),a.module("ui-leaflet").service("leafletIterators",["leafletLogger","leafletHelpers",function(a,b){var c,d=b,e=b.errorHeader+"leafletIterators: ",f=Object.keys,g=d.isFunction,h=d.isObject,i=a,j=Math.pow(2,53)-1,k=function(a){var b=null!==a&&a.length;return d.isNumber(b)&&b>=0&&b<=j},l=function(a){return a},m=function(a){return function(b){return null===b?void 0:b[a]}},n=function(a,b,c){if(void 0===b)return a;switch(null===c?3:c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)};case 4:return function(c,d,e,f){return a.call(b,c,d,e,f)}}return function(){return a.apply(b,arguments)}},o=function(a,b){return function(c){var d=arguments.length;if(d<2||null===c)return c;for(var e=1;e<d;e++)for(var f=arguments[e],g=a(f),h=g.length,i=0;i<h;i++){var j=g[i];b&&void 0!==c[j]||(c[j]=f[j])}return c}},p=null;c=p=o(f);var q,r=function(a,b){var c=f(b),d=c.length;if(null===a)return!d;for(var e=Object(a),g=0;g<d;g++){var h=c[g];if(b[h]!==e[h]||!(h in e))return!1}return!0},s=null;q=s=function(a){return a=c({},a),function(b){return r(b,a)}};var t,u=function(a,b,c){return null===a?l:g(a)?n(a,b,c):h(a)?q(a):m(a)},v=null;t=v=function(a,b,c){b=u(b,c);for(var d=!k(a)&&f(a),e=(d||a).length,g=0;g<e;g++){var h=d?d[g]:g;if(!b(a[h],h,a))return!1}return!0};var w=function(a,b,c,f){return!(c||d.isDefined(a)&&d.isDefined(b))||!d.isFunction(b)&&(f=d.defaultTo(b,"cb"),i.error(e+f+" is not a function"),!0)},x=function(a,b,c){if(!w(void 0,c,!0,"internalCb")&&!w(a,b))for(var d in a)a.hasOwnProperty(d)&&c(a[d],d)},y=function(a,b){x(a,b,function(a,c){b(a,c)})};return{each:y,forEach:y,every:t,all:v}}]),a.module("ui-leaflet").factory("leafletLayerHelpers",["$rootScope","$q","leafletLogger","leafletHelpers","leafletIterators",function(b,c,d,e,f){function g(a){return l(a.type)?Object.keys(t).indexOf(a.type)===-1?(r.error("[AngularJS - Leaflet] A layer must have a valid type: "+Object.keys(t)),!1):t[a.type].mustHaveUrl&&!l(a.url)?(r.error("[AngularJS - Leaflet] A base layer must have an url"),!1):t[a.type].mustHaveData&&!o(a.data)?(r.error('[AngularJS - Leaflet] The base layer must have a "data" array attribute'),!1):t[a.type].mustHaveLayer&&!o(a.layer)?(r.error("[AngularJS - Leaflet] The type of layer "+a.type+" must have an layer defined"),!1):t[a.type].mustHaveBounds&&!o(a.bounds)?(r.error("[AngularJS - Leaflet] The type of layer "+a.type+" must have bounds defined"),!1):!(t[a.type].mustHaveKey&&!o(a.key))||(r.error("[AngularJS - Leaflet] The type of layer "+a.type+" must have key defined"),!1):(r.error("[AngularJS - Leaflet] A layer must have a valid type defined."),!1)}function h(a){if(g(a)){if(!l(a.name))return void r.error("[AngularJS - Leaflet] A base layer must have a name");m(a.layerParams)||(a.layerParams={}),m(a.layerOptions)||(a.layerOptions={});for(var b in a.layerParams)a.layerOptions[b]=a.layerParams[b];var c={url:a.url,data:a.data,options:a.layerOptions,layer:a.layer,icon:a.icon,type:a.layerType,bounds:a.bounds,key:a.key,apiKey:a.apiKey,pluginOptions:a.pluginOptions,user:a.user,$parent:a};return t[a.type].createLayer(c)}}function i(a,b){b&&"function"==typeof b.addTo?b.addTo(a):a.addLayer(b)}function j(b,c,d){if(o(d)&&o(d.loadedDefer))if(a.isFunction(d.loadedDefer)){var e=d.loadedDefer();r.debug("Loaded Deferred",e);var f=e.length;if(f>0)for(var g=function(){f--,0===f&&b.removeLayer(c)},h=0;h<e.length;h++)e[h].promise.then(g);else b.removeLayer(c)}else d.loadedDefer.promise.then(function(){b.removeLayer(c)});else b.removeLayer(c)}var k=e,l=e.isString,m=e.isObject,n=e.isArray,o=e.isDefined,p=e.errorHeader,q=f,r=d,s=function(c){if(!k.UTFGridPlugin.isLoaded())return void r.error("[AngularJS - Leaflet] The UTFGrid plugin is not loaded.");var d=new L.UtfGrid(c.url,c.pluginOptions),e={model:c.$parent};return d.on("mouseover",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridMouseover",e)}),d.on("mouseout",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridMouseout",e)}),d.on("click",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridClick",e)}),d.on("mousemove",function(c){a.extend(e,{leafletEvent:c,leafletObject:c.target}),b.$broadcast("leafletDirectiveMap.utfgridMousemove",e)}),d},t={xyz:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer(a.url,a.options)}},geoJSON:{mustHaveUrl:!0,createLayer:function(a){if(k.GeoJSONPlugin.isLoaded())return new L.TileLayer.GeoJSON(a.url,a.pluginOptions,a.options)}},geoJSONShape:{mustHaveUrl:!1,createLayer:function(a){return new L.GeoJSON(a.data,a.options)}},geoJSONAwesomeMarker:{mustHaveUrl:!1,createLayer:function(a){return new L.geoJson(a.data,{pointToLayer:function(b,c){return L.marker(c,{icon:L.AwesomeMarkers.icon(a.icon)})}})}},geoJSONVectorMarker:{mustHaveUrl:!1,createLayer:function(a){return new L.geoJson(a.data,{pointToLayer:function(b,c){return L.marker(c,{icon:L.VectorMarkers.icon(a.icon)})}})}},cartodbTiles:{mustHaveKey:!0,createLayer:function(a){var b=o(a.url)?a.url+"/"+a.user:"//"+a.user+".cartodb.com";return b+="/api/v1/map/"+a.key+"/{z}/{x}/{y}.png",L.tileLayer(b,a.options)}},cartodbUTFGrid:{mustHaveKey:!0,mustHaveLayer:!0,createLayer:function(a){var b=o(a.url)?a.url+"/"+a.user:"//"+a.user+".cartodb.com";return a.url=b+"/api/v1/map/"+a.key+"/"+a.layer+"/{z}/{x}/{y}.grid.json",s(a)}},cartodbInteractive:{mustHaveKey:!0,mustHaveLayer:!0,createLayer:function(b){var c=o(b.url)?b.url+"/"+b.user:"//"+b.user+".cartodb.com",d=c+"/api/v1/map/"+b.key+"/{z}/{x}/{y}.png",e=L.tileLayer(d,b.options),f=[e],g=function(b,d,e){var f=a.copy(d);f.url=c+"/api/v1/map/"+f.key+"/"+e+"/{z}/{x}/{y}.grid.json",b.push(s(f))};if(n(b.layer))for(var h=0;h<b.layer.length;h++)g(f,b,b.layer[h]);else g(f,b,b.layer);return L.layerGroup(f)}},wms:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer.wms(a.url,a.options)}},wmts:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer.wmts(a.url,a.options)}},group:{mustHaveUrl:!1,createLayer:function(a){var b=[];return q.each(a.options.layers,function(a){b.push(h(a))}),a.options.loadedDefer=function(){var b=[];if(o(a.options.layers))for(var c=0;c<a.options.layers.length;c++){var d=a.options.layers[c].layerOptions.loadedDefer;o(d)&&b.push(d)}return b},L.layerGroup(b)}},featureGroup:{mustHaveUrl:!1,createLayer:function(){return L.featureGroup()}},markercluster:{mustHaveUrl:!1,createLayer:function(a){return k.MarkerClusterPlugin.isLoaded()?new L.MarkerClusterGroup(a.options):void r.warn(p+" The markercluster plugin is not loaded.")}},imageOverlay:{mustHaveUrl:!0,mustHaveBounds:!0,createLayer:function(a){return L.imageOverlay(a.url,a.bounds,a.options)}},iip:{mustHaveUrl:!0,createLayer:function(a){return L.tileLayer.iip(a.url,a.options)}},custom:{createLayer:function(b){return b.layer instanceof L.Class?a.copy(b.layer):void r.error("[AngularJS - Leaflet] A custom layer must be a leaflet Class")}},cartodb:{mustHaveUrl:!0,createLayer:function(a){return cartodb.createLayer(a.map,a.url)}}},u=function(a){return function(b){o(b.setOpacity)&&b.setOpacity(a)}};return{createLayer:h,layerTypes:t,safeAddLayer:i,safeRemoveLayer:j,changeOpacityListener:u}}]),a.module("ui-leaflet").factory("leafletLegendHelpers",["$http","$q","$log","leafletHelpers",function(a,b,c,d){var e={},f=d.isDefined,g=function b(c){var d=e[c],f=d[0];a(f.c).then(function(a){d.shift(),f.d.resolve(a),d.length>0&&b(c)},function(a){d.shift(),f.d.reject(a),d.length>0&&b(c)})},h=function(a,b,c,d){if(a.innerHTML="",b.error)a.innerHTML+='<div class="info-title alert alert-danger">'+b.error.message+"</div>";else if("arcgis"===c)for(var e=0;e<b.layers.length;e++){var f=b.layers[e];a.innerHTML+='<div class="info-title" data-layerid="'+f.layerId+'">'+f.layerName+"</div>";for(var g=0;g<f.legend.length;g++){var h=f.legend[g];a.innerHTML+='<div class="inline" data-layerid="'+f.layerId+'"><img src="data:'+h.contentType+";base64,"+h.imageData+'" /></div><div class="info-label" data-layerid="'+f.layerId+'">'+h.label+"</div>"}}else"image"===c&&(a.innerHTML='<img src="'+d+'"/>')},i=function(a,b,c,d){return function(){var e=L.DomUtil.create("div",b);return L.Browser.touch?L.DomEvent.on(e,"click",L.DomEvent.stopPropagation):(L.DomEvent.disableClickPropagation(e),L.DomEvent.on(e,"mousewheel",L.DomEvent.stopPropagation)),h(e,a,c,d),e}},j=function(a,b){return function(){for(var c=L.DomUtil.create("div",b),d=0;d<a.colors.length;d++)c.innerHTML+='<div class="outline"><i style="background:'+a.colors[d]+'"></i></div><div class="info-label">'+a.labels[d]+"</div>";return L.Browser.touch?L.DomEvent.on(c,"click",L.DomEvent.stopPropagation):(L.DomEvent.disableClickPropagation(c),L.DomEvent.on(c,"mousewheel",L.DomEvent.stopPropagation)),c}};return{getOnAddLegend:i,getOnAddArrayLegend:j,updateLegend:h,addLegendURL:function(a,c){var d=b.defer();return f(e[a])||(e[a]=[]),e[a].push({c:c,d:d}),1===e[a].length&&g(a),d.promise}}}]),a.module("ui-leaflet").factory("leafletMapDefaults",["$q","leafletHelpers",function(b,c){function d(){return{keyboard:!0,dragging:!0,worldCopyJump:!1,doubleClickZoom:!0,scrollWheelZoom:!0,tap:!0,touchZoom:!0,zoomControl:!0,zoomsliderControl:!1,zoomControlPosition:"topleft",attributionControl:!0,controls:{layers:{visible:!0,position:"topright",collapsed:!0}},nominatim:{server:" http://nominatim.openstreetmap.org/search"},crs:L.CRS.EPSG3857,tileLayer:"//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",tileLayerOptions:{attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'},path:{weight:10,opacity:1,color:"#0000ff"},center:{lat:0,lng:0,zoom:1},trackResize:!0}}var e=c.isDefined,f=c.isObject,g=c.obtainEffectiveMapId,h={};return{reset:function(){h={}},getDefaults:function(a){var b=g(h,a);return h[b]},getMapCreationDefaults:function(a){var b=g(h,a),c=h[b],d={maxZoom:c.maxZoom,keyboard:c.keyboard,dragging:c.dragging,zoomControl:c.zoomControl,doubleClickZoom:c.doubleClickZoom,scrollWheelZoom:c.scrollWheelZoom,tap:c.tap,touchZoom:c.touchZoom,attributionControl:c.attributionControl,worldCopyJump:c.worldCopyJump,crs:c.crs,trackResize:c.trackResize};if(e(c.minZoom)&&(d.minZoom=c.minZoom),e(c.zoomAnimation)&&(d.zoomAnimation=c.zoomAnimation),e(c.fadeAnimation)&&(d.fadeAnimation=c.fadeAnimation),e(c.markerZoomAnimation)&&(d.markerZoomAnimation=c.markerZoomAnimation),c.map)for(var f in c.map)d[f]=c.map[f];return d},setDefaults:function(b,c){var i=d();e(b)&&(i.doubleClickZoom=e(b.doubleClickZoom)?b.doubleClickZoom:i.doubleClickZoom,i.scrollWheelZoom=e(b.scrollWheelZoom)?b.scrollWheelZoom:i.doubleClickZoom,i.tap=e(b.tap)?b.tap:i.tap,i.touchZoom=e(b.touchZoom)?b.touchZoom:i.doubleClickZoom,i.zoomControl=e(b.zoomControl)?b.zoomControl:i.zoomControl,i.zoomsliderControl=e(b.zoomsliderControl)?b.zoomsliderControl:i.zoomsliderControl,i.attributionControl=e(b.attributionControl)?b.attributionControl:i.attributionControl,i.tileLayer=e(b.tileLayer)?b.tileLayer:i.tileLayer,i.zoomControlPosition=e(b.zoomControlPosition)?b.zoomControlPosition:i.zoomControlPosition,i.keyboard=e(b.keyboard)?b.keyboard:i.keyboard,i.dragging=e(b.dragging)?b.dragging:i.dragging,i.trackResize=e(b.trackResize)?b.trackResize:i.trackResize,e(b.controls)&&a.extend(i.controls,b.controls),f(b.crs)?i.crs=b.crs:e(L.CRS[b.crs])&&(i.crs=L.CRS[b.crs]),e(b.center)&&a.copy(b.center,i.center),e(b.tileLayerOptions)&&a.copy(b.tileLayerOptions,i.tileLayerOptions),e(b.maxZoom)&&(i.maxZoom=b.maxZoom),e(b.minZoom)&&(i.minZoom=b.minZoom),e(b.zoomAnimation)&&(i.zoomAnimation=b.zoomAnimation),e(b.fadeAnimation)&&(i.fadeAnimation=b.fadeAnimation),e(b.markerZoomAnimation)&&(i.markerZoomAnimation=b.markerZoomAnimation),e(b.worldCopyJump)&&(i.worldCopyJump=b.worldCopyJump),e(b.map)&&(i.map=b.map),e(b.path)&&(i.path=b.path));var j=g(h,c);return h[j]=i,i}}}]),a.module("ui-leaflet").service("leafletMarkersHelpers",["$rootScope","$timeout","leafletHelpers","leafletLogger","$compile","leafletGeoJsonHelpers","leafletWatchHelpers",function(b,c,d,e,f,g,h){var i=d.isDefined,j=d.defaultTo,k=d.MarkerClusterPlugin,l=d.AwesomeMarkersPlugin,m=d.VectorMarkersPlugin,n=d.MakiMarkersPlugin,o=d.ExtraMarkersPlugin,p=d.DomMarkersPlugin,q=d.safeApply,r=d,s=d.isString,t=d.isNumber,u=d.isObject,v={},w=g,x=d.errorHeader,y=h.maybeWatch,z=e,A=function(a){var b="";return["_icon","_latlng","_leaflet_id","_map","_shadow"].forEach(function(c){b+=c+": "+j(a[c],"undefined")+" \n"}),"[leafletMarker] : \n"+b},B=function(a,b){var c=b?console:z;c.debug(A(a))},C=function(b){return a.element(v[b]._map._container).parent().length>0},D=function(c){if(i(c)&&i(c.type)&&"awesomeMarker"===c.type)return l.isLoaded()||z.error(x+" The AwesomeMarkers Plugin is not loaded."),new L.AwesomeMarkers.icon(c);if(i(c)&&i(c.type)&&"vectorMarker"===c.type)return m.isLoaded()||z.error(x+" The VectorMarkers Plugin is not loaded."),new L.VectorMarkers.icon(c);if(i(c)&&i(c.type)&&"makiMarker"===c.type)return n.isLoaded()||z.error(x+"The MakiMarkers Plugin is not loaded."),new L.MakiMarkers.icon(c);if(i(c)&&i(c.type)&&"extraMarker"===c.type)return o.isLoaded()||z.error(x+"The ExtraMarkers Plugin is not loaded."),new L.ExtraMarkers.icon(c);if(i(c)&&i(c.type)&&"div"===c.type)return new L.divIcon(c);if(i(c)&&i(c.type)&&"dom"===c.type){p.isLoaded()||z.error(x+"The DomMarkers Plugin is not loaded.");var d=a.isFunction(c.getMarkerScope)?c.getMarkerScope().$new():b,e=f(c.template)(d),g=a.copy(c);return g.ngElement=e,g.element=e[0],a.isFunction(c.getMarkerScope)&&(g.scope=d),new L.DomMarkers.icon(g)}if(i(c)&&i(c.type)&&"icon"===c.type)return c.icon;var h="data:image/png;base64,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",j="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=";
+return i(c)&&i(c.iconUrl)?new L.Icon(c):new L.Icon.Default({iconUrl:h,shadowUrl:j,iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]})},E=function(a){i(v[a])&&delete v[a]},F=function(){v={}},G=function(){for(var a in v)C(a)||E(a)},H=function(a){a.options.icon.options.ngElement&&a.options.icon.options.ngElement.remove(),a.options.icon.options.scope&&a.options.icon.options.scope.$destroy()},I=function(a,b,c){if(a.closePopup(),a.options.icon&&a.options.icon.options&&"dom"===a.options.icon.options.type&&H(a),i(c)&&i(c.overlays))for(var d in c.overlays)if((c.overlays[d]instanceof L.LayerGroup||c.overlays[d]instanceof L.FeatureGroup)&&c.overlays[d].hasLayer(a))return void c.overlays[d].removeLayer(a);if(i(v))for(var e in v)v[e].hasLayer(a)&&v[e].removeLayer(a);b.hasLayer(a)&&b.removeLayer(a)},J=function(a,b){var c=a._popup._container.offsetHeight,d=new L.Point(a._popup._containerLeft,-c-a._popup._containerBottom),e=b.layerPointToContainerPoint(d);null!==e&&a._popup._adjustPan()},K=function(a,b){f(a._popup._contentNode)(b)},M=function a(b,d,e){var f=b._popup._contentNode.innerText||b._popup._contentNode.textContent;f.length<1&&c(function(){a(b,d,e)});var g=b._popup._contentNode.offsetWidth;return b._popup._updateLayout(),b._popup._updatePosition(),b._popup.options.autoPan&&J(b,e),g},N=function(c,d,e){var f=a.isFunction(d.getMessageScope)?d.getMessageScope():b,g=!i(d.compileMessage)||d.compileMessage;if(g){if(!i(c._popup)||!i(c._popup._contentNode))return z.error(x+"Popup is invalid or does not have any content."),!1;K(c,f),M(c,d,e)}},O=function(c,d){var e=a.isFunction(d.getMessageScope)?d.getMessageScope():b,g=a.isFunction(d.getLabelScope)?d.getLabelScope():e,h=!i(d.compileMessage)||d.compileMessage;r.LabelPlugin.isLoaded()&&i(d.label)&&(i(d.label.options)&&d.label.options.noHide===!0&&c.showLabel(),h&&i(c.label)&&f(c.label._container)(g))},P=function(b,c,d,e,f,g,h){if(i(c)){if(!w.validateCoords(b))return z.warn("There are problems with lat-lng data, please verify your marker model"),void I(d,h,g);var j=b===c;if(i(b.iconAngle)&&c.iconAngle!==b.iconAngle&&d.setIconAngle(b.iconAngle),s(b.layer)||s(c.layer)&&(i(g.overlays[c.layer])&&g.overlays[c.layer].hasLayer(d)&&(g.overlays[c.layer].removeLayer(d),d.closePopup()),h.hasLayer(d)||h.addLayer(d)),(t(b.opacity)||t(parseFloat(b.opacity)))&&b.opacity!==c.opacity&&d.setOpacity(b.opacity),s(b.layer)&&c.layer!==b.layer){if(s(c.layer)&&i(g.overlays[c.layer])&&g.overlays[c.layer].hasLayer(d)&&g.overlays[c.layer].removeLayer(d),d.closePopup(),h.hasLayer(d)&&h.removeLayer(d),!i(g.overlays[b.layer]))return void z.error(x+"You must use a name of an existing layer");var k=g.overlays[b.layer];if(!(k instanceof L.LayerGroup||k instanceof L.FeatureGroup))return void z.error(x+'A marker can only be added to a layer of type "group" or "featureGroup"');k.addLayer(d),h.hasLayer(d)&&b.focus===!0&&d.openPopup()}if(b.draggable!==!0&&c.draggable===!0&&i(d.dragging)&&d.dragging.disable(),b.draggable===!0&&c.draggable!==!0&&(d.dragging?d.dragging.enable():L.Handler.MarkerDrag&&(d.dragging=new L.Handler.MarkerDrag(d),d.options.draggable=!0,d.dragging.enable())),u(b.icon)||u(c.icon)&&("dom"===c.icon.type&&H(d),d.setIcon(D()),d.closePopup(),d.unbindPopup(),s(b.message)&&d.bindPopup(b.message,b.popupOptions)),u(b.icon)&&u(c.icon)&&!a.equals(b.icon,c.icon)){var l=!1;d.dragging&&(l=d.dragging.enabled()),"dom"===c.icon.type&&H(d),d.setIcon(D(b.icon)),l&&d.dragging.enable(),d.closePopup(),d.unbindPopup(),s(b.message)&&(d.bindPopup(b.message,b.popupOptions),h.hasLayer(d)&&b.focus===!0&&d.openPopup())}!s(b.message)&&s(c.message)&&(d.closePopup(),d.unbindPopup()),r.LabelPlugin.isLoaded()&&(i(b.label)&&i(b.label.message)?"label"in c&&"message"in c.label&&!a.equals(b.label.message,c.label.message)?d.updateLabelContent(b.label.message):!a.isFunction(d.getLabel)||a.isFunction(d.getLabel)&&!i(d.getLabel())?(d.bindLabel(b.label.message,b.label.options),O(d,b)):O(d,b):"label"in b&&!("message"in b.label)||a.isFunction(d.unbindLabel)&&d.unbindLabel()),s(b.message)&&!s(c.message)&&d.bindPopup(b.message,b.popupOptions),s(b.message)&&s(c.message)&&b.message!==c.message&&d.setPopupContent(b.message);var m=!1;b.focus!==!0&&c.focus===!0&&(d.closePopup(),m=!0),(b.focus===!0&&(!i(c.focus)||c.focus===!1)||j&&b.focus===!0)&&(d.openPopup(),m=!0),c.zIndexOffset!==b.zIndexOffset&&d.setZIndexOffset(b.zIndexOffset);var n=d.getLatLng(),o=s(b.layer)&&r.MarkerClusterPlugin.is(g.overlays[b.layer]);o?m?b.lat===c.lat&&b.lng===c.lng||(g.overlays[b.layer].removeLayer(d),d.setLatLng([b.lat,b.lng]),g.overlays[b.layer].addLayer(d)):n.lat!==b.lat||n.lng!==b.lng?(g.overlays[b.layer].removeLayer(d),d.setLatLng([b.lat,b.lng]),g.overlays[b.layer].addLayer(d)):b.lat!==c.lat||b.lng!==c.lng?(g.overlays[b.layer].removeLayer(d),d.setLatLng([b.lat,b.lng]),g.overlays[b.layer].addLayer(d)):u(b.icon)&&u(c.icon)&&!a.equals(b.icon,c.icon)&&(g.overlays[b.layer].removeLayer(d),g.overlays[b.layer].addLayer(d)):n.lat===b.lat&&n.lng===b.lng||d.setLatLng([b.lat,b.lng])}},Q=function(a,b){if(i(a))return b?a[b]:a},R=function(a,b,c){if(i(a))return b?c?a[c][b]:a[b]:void z.error(x+"marker id missing in getMarker")};return{resetMarkerGroup:E,resetMarkerGroups:F,resetUnusedMarkerGroups:G,deleteMarker:I,manageOpenPopup:N,manageOpenLabel:O,createMarker:function(a){if(!i(a)||!w.validateCoords(a))return void z.error(x+"The marker definition is not valid.");var b=w.getCoords(a);if(!i(b))return void z.error(x+"Unable to get coordinates from markerData.");var c={icon:D(a.icon),title:i(a.title)?a.title:"",draggable:!!i(a.draggable)&&a.draggable,clickable:!i(a.clickable)||a.clickable,riseOnHover:!!i(a.riseOnHover)&&a.riseOnHover,zIndexOffset:i(a.zIndexOffset)?a.zIndexOffset:0,iconAngle:i(a.iconAngle)?a.iconAngle:0};for(var d in a)a.hasOwnProperty(d)&&!c.hasOwnProperty(d)&&(c[d]=a[d]);var e=new L.marker(b,c);return s(a.message)||e.unbindPopup(),e},addMarkerToGroup:function(a,b,c,d){return s(b)?k.isLoaded()?(i(v[b])||(v[b]=new L.MarkerClusterGroup(c),d.addLayer(v[b])),void v[b].addLayer(a)):void z.error(x+"The MarkerCluster plugin is not loaded."):void z.error(x+"The marker group you have specified is invalid.")},listenMarkerEvents:function(a,b,c,d,e){a.on("popupopen",function(){q(c,function(){(i(a._popup)||i(a._popup._contentNode))&&(b.focus=!0,N(a,b,e))})}),a.on("popupclose",function(){q(c,function(){b.focus=!1})}),a.on("add",function(){q(c,function(){"label"in b&&O(a,b)})})},updateMarker:P,addMarkerWatcher:function(a,b,c,d,e,f){var g=r.getObjectArrayPath("markers."+b);y(c,g,f,function(f,g,h){return i(f)?void P(f,g,a,b,c,d,e):(I(a,e,d),void h())})},string:A,log:B,getModelFromModels:R,getLayerModels:Q}}]),a.module("ui-leaflet").factory("leafletPathsHelpers",["$rootScope","leafletLogger","leafletHelpers",function(a,b,c){function d(a){return a.filter(function(a){return k(a)}).map(function(a){return e(a)})}function e(a){return i(a)?new L.LatLng(a[0],a[1]):new L.LatLng(a.lat,a.lng)}function f(a){return a.map(function(a){return d(a)})}function g(a,b){for(var c={},d=0;d<m.length;d++){var e=m[d];h(a[e])?c[e]=a[e]:h(b.path[e])&&(c[e]=b.path[e])}return c}var h=c.isDefined,i=c.isArray,j=c.isNumber,k=c.isValidPoint,l=b,m=["stroke","weight","color","opacity","fill","fillColor","fillOpacity","dashArray","lineCap","lineJoin","clickable","pointerEvents","className","smoothFactor","noClip"],n=function(a,b){for(var c={},d=0;d<m.length;d++){var e=m[d];h(b[e])&&(c[e]=b[e])}a.setStyle(b)},o=function(a){if(!i(a))return!1;for(var b=0;b<a.length;b++){var c=a[b];if(!k(c))return!1}return!0},p={polyline:{isValid:function(a){var b=a.latlngs;return o(b)},createPath:function(a){return new L.Polyline([],a)},setPath:function(a,b){a.setLatLngs(d(b.latlngs)),n(a,b)}},multiPolyline:{isValid:function(a){var b=a.latlngs;if(!i(b))return!1;for(var c in b){var d=b[c];if(!o(d))return!1}return!0},createPath:function(a){return new L.multiPolyline([[[0,0],[1,1]]],a)},setPath:function(a,b){a.setLatLngs(f(b.latlngs)),n(a,b)}},polygon:{isValid:function(a){var b=a.latlngs;return o(b)},createPath:function(a){return new L.Polygon([],a)},setPath:function(a,b){a.setLatLngs(d(b.latlngs)),n(a,b)}},multiPolygon:{isValid:function(a){var b=a.latlngs;if(!i(b))return!1;for(var c in b){var d=b[c];if(!o(d))return!1}return!0},createPath:function(a){return new L.MultiPolygon([[[0,0],[1,1],[0,1]]],a)},setPath:function(a,b){a.setLatLngs(f(b.latlngs)),n(a,b)}},rectangle:{isValid:function(a){var b=a.latlngs;if(!i(b)||2!==b.length)return!1;for(var c in b){var d=b[c];if(!k(d))return!1}return!0},createPath:function(a){return new L.Rectangle([[0,0],[1,1]],a)},setPath:function(a,b){a.setBounds(new L.LatLngBounds(d(b.latlngs))),n(a,b)}},circle:{isValid:function(a){var b=a.latlngs;return k(b)&&j(a.radius)},createPath:function(a){return new L.Circle([0,0],1,a)},setPath:function(a,b){a.setLatLng(e(b.latlngs)),h(b.radius)&&a.setRadius(b.radius),n(a,b)}},circleMarker:{isValid:function(a){var b=a.latlngs;return k(b)&&j(a.radius)},createPath:function(a){return new L.CircleMarker([0,0],a)},setPath:function(a,b){a.setLatLng(e(b.latlngs)),h(b.radius)&&a.setRadius(b.radius),n(a,b)}}},q=function(a){var b={};return a.latlngs&&(b.latlngs=a.latlngs),a.radius&&(b.radius=a.radius),b};return{setPathOptions:function(a,b,c){h(b)||(b="polyline"),p[b].setPath(a,c)},createPath:function(a,b,c){h(b.type)||(b.type="polyline");var d=g(b,c),e=q(b);return p[b.type].isValid(e)?p[b.type].createPath(d):void l.error("[AngularJS - Leaflet] Invalid data passed to the "+b.type+" path")}}}]),a.module("ui-leaflet").service("leafletWatchHelpers",function(){var a=function(a,b,c,d,e){var f=a[b](c,function(a,b){e(a,b,f),null===d.type&&f()},"watchDeep"===d.type);return f},b=function(b,c,d,e){var f;return f="watchCollection"===d.type?"$watchCollection":"$watch",a(b,f,c,d,e)};return{maybeWatch:b}}),a.module("ui-leaflet").service("leafletLogger",["nemSimpleLogger",function(a){return a.spawn()}]),a.module("ui-leaflet").factory("nominatimService",["$q","$http","leafletHelpers","leafletMapDefaults",function(a,b,c,d){var e=c.isDefined;return{query:function(c,f){var g=d.getDefaults(f),h=g.nominatim.server,i=a.defer();return b.get(h,{params:{format:"json",limit:1,q:c}}).success(function(a){a.length>0&&e(a[0].boundingbox)?i.resolve(a[0]):i.reject("[Nominatim] Invalid address")}),i.promise}}}]),a.module("ui-leaflet").directive("bounds",["leafletLogger","$timeout","$http","leafletHelpers","nominatimService","leafletBoundsHelpers",function(b,c,d,e,f,g){var h=b;return{restrict:"A",scope:!1,replace:!1,require:["leaflet"],link:function(b,d,i,j){var k=e.isDefined,l=g.createLeafletBounds,m=j[0].getLeafletScope(),n=j[0],o=e.errorHeader+" [Bounds] ",p=function(a){return 0===a._southWest.lat&&0===a._southWest.lng&&0===a._northEast.lat&&0===a._northEast.lng};n.getMap().then(function(d){m.$on("boundsChanged",function(b){var e=b.currentScope,f=d.getBounds();if(!p(f)&&!e.settingBoundsFromScope){e.settingBoundsFromLeaflet=!0;var g={northEast:{lat:f._northEast.lat,lng:f._northEast.lng},southWest:{lat:f._southWest.lat,lng:f._southWest.lng},options:f.options};a.equals(e.bounds,g)||(e.bounds=g),c(function(){e.settingBoundsFromLeaflet=!1})}});var e;m.$watch("bounds",function(a){if(!b.settingBoundsFromLeaflet){if(k(a.address)&&a.address!==e)return b.settingBoundsFromScope=!0,f.query(a.address,i.id).then(function(a){var b=a.boundingbox,c=[[b[0],b[2]],[b[1],b[3]]];d.fitBounds(c)},function(a){h.error(o+" "+a+".")}),e=a.address,void c(function(){b.settingBoundsFromScope=!1});var g=l(a);g&&!d.getBounds().equals(g)&&(b.settingBoundsFromScope=!0,d.fitBounds(g,a.options),c(function(){b.settingBoundsFromScope=!1}))}},!0)})}}}]);var b=["center","lfCenter"],c={};b.forEach(function(b){c[b]=["leafletLogger","$q","$location","$timeout","leafletMapDefaults","leafletHelpers","leafletBoundsHelpers","leafletMapEvents",function(c,d,e,f,g,h,i,j){var k,l=h.isDefined,m=h.isNumber,n=h.isSameCenterOnMap,o=h.safeApply,p=h.isValidCenter,q=i.isValidBounds,r=h.isUndefinedOrEmpty,s=h.errorHeader,t=c,u=function(a,b){return l(a)&&q(a)&&r(b)};return{restrict:"A",scope:!1,replace:!1,require:"leaflet",controller:function(){k=d.defer(),this.getCenter=function(){return k.promise}},link:function(c,d,h,q){var r=q.getLeafletScope(),v=r[b];q.getMap().then(function(c){var d=g.getDefaults(h.id);if(h[b].search("-")!==-1)return t.error(s+' The "center" variable can\'t use a "-" on its key name: "'+h[b]+'".'),void c.setView([d.center.lat,d.center.lng],d.center.zoom);if(u(r.bounds,v))c.fitBounds(i.createLeafletBounds(r.bounds),r.bounds.options),v=c.getCenter(),o(r,function(d){a.extend(d[b],{lat:c.getCenter().lat,lng:c.getCenter().lng,zoom:c.getZoom(),autoDiscover:!1})}),o(r,function(a){var b=c.getBounds();a.bounds={northEast:{lat:b._northEast.lat,lng:b._northEast.lng},southWest:{lat:b._southWest.lat,lng:b._southWest.lng}}});else{if(!l(v))return t.error(s+' The "center" property is not defined in the main scope'),void c.setView([d.center.lat,d.center.lng],d.center.zoom);l(v.lat)&&l(v.lng)||l(v.autoDiscover)||a.copy(d.center,v)}var q,w;if("yes"===h.urlHashCenter){var x=function(){var a,b=e.search(),c=h.urlHashParam?h.urlHashParam:"c";if(l(b[c])){var d=b[c].split(":");3===d.length&&(a={lat:parseFloat(d[0]),lng:parseFloat(d[1]),zoom:parseInt(d[2],10)})}return a};q=x(),r.$on("$locationChangeSuccess",function(d){var e=d.currentScope,f=x();l(f)&&!n(f,c)&&a.extend(e[b],{lat:f.lat,lng:f.lng,zoom:f.zoom})})}r.$watch(b,function(b){if(!r.settingCenterFromLeaflet)return l(q)&&(a.copy(q,b),q=void 0),p(b)||b.autoDiscover===!0?b.autoDiscover===!0?(m(b.zoom)||c.setView([d.center.lat,d.center.lng],d.center.zoom),void(m(b.zoom)&&b.zoom>d.center.zoom?c.locate({setView:!0,maxZoom:b.zoom}):l(d.maxZoom)?c.locate({setView:!0,maxZoom:d.maxZoom}):c.locate({setView:!0}))):void(w&&n(b,c)||(r.settingCenterFromScope=!0,c.setView([b.lat,b.lng],b.zoom),j.notifyCenterChangedToBounds(r,c),f(function(){r.settingCenterFromScope=!1}))):void t.warn(s+" invalid 'center'")},!0),c.whenReady(function(){w=!0}),c.on("moveend",function(){k.resolve(),j.notifyCenterUrlHashChanged(r,c,h,e.search()),n(v,c)||r.settingCenterFromScope||(r.settingCenterFromLeaflet=!0,o(r,function(d){r.settingCenterFromScope||a.extend(d[b],{lat:c.getCenter().lat,lng:c.getCenter().lng,zoom:c.getZoom(),autoDiscover:!1}),j.notifyCenterChangedToBounds(r,c),f(function(){r.settingCenterFromLeaflet=!1})}))}),v.autoDiscover===!0&&c.on("locationerror",function(){t.warn(s+" The Geolocation API is unauthorized on this page."),p(v)?(c.setView([v.lat,v.lng],v.zoom),j.notifyCenterChangedToBounds(r,c)):(c.setView([d.center.lat,d.center.lng],d.center.zoom),j.notifyCenterChangedToBounds(r,c))})})}}}]}),b.forEach(function(b){a.module("ui-leaflet").directive(b,c[b])}),a.module("ui-leaflet").directive("controls",["leafletLogger","leafletHelpers","leafletControlHelpers",function(a,b,c){var d=a;return{restrict:"A",scope:!1,replace:!1,require:"?^leaflet",link:function(a,e,f,g){if(g){var h=c.createControl,i=c.isValidControlType,j=g.getLeafletScope(),k=b.isDefined,l=b.isArray,m={},n=b.errorHeader+" [Controls] ";a.$on("$destroy",function(){c.destroyMapLayersControl(a.mapId)}),g.getMap().then(function(a){j.$watchCollection("controls",function(b){for(var c in m)k(b[c])||(a.hasControl(m[c])&&a.removeControl(m[c]),delete m[c]);for(var e in b){var f,g=k(b[e].type)?b[e].type:e;if(!i(g))return void d.error(n+" Invalid control type: "+g+".");if("custom"!==g)f=h(g,b[e]),a.addControl(f),m[e]=f;else{var j=b[e];if(l(j))for(var o=0;o<j.length;o++){var p=j[o];a.addControl(p),m[e]=k(m[e])?m[e].concat([p]):[p]}else a.addControl(j),m[e]=j}}})})}}}}]),a.module("ui-leaflet").directive("decorations",["leafletLogger","leafletHelpers",function(b,c){var d=b;return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(b,e,f,g){function h(a){return l(a)&&l(a.coordinates)&&(k.isLoaded()||d.error("[AngularJS - Leaflet] The PolylineDecorator Plugin is not loaded.")),L.polylineDecorator(a.coordinates)}function i(a,b){if(l(a)&&l(b)&&l(b.coordinates)&&l(b.patterns))return a.setPaths(b.coordinates),a.setPatterns(b.patterns),a}var j=g.getLeafletScope(),k=c.PolylineDecoratorPlugin,l=c.isDefined,m={};g.getMap().then(function(b){j.$watch("decorations",function(c){for(var d in m)l(c[d])&&a.equals(c[d],m)||(b.removeLayer(m[d]),delete m[d]);for(var e in c){var f=c[e],g=h(f);l(g)&&(m[e]=g,b.addLayer(g),i(g,f))}},!0)})}}}]),a.module("ui-leaflet").directive("eventBroadcast",["leafletLogger","$rootScope","leafletHelpers","leafletMapEvents","leafletIterators",function(a,b,c,d,e){var f=a;return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(a,b,g,h){var i=c.isObject,j=c.isDefined,k=h.getLeafletScope(),l=k.eventBroadcast,m=d.getAvailableMapEvents(),n=d.addEvents;h.getMap().then(function(a){var b=[],c="broadcast";j(l.map)?i(l.map)?("emit"!==l.map.logic&&"broadcast"!==l.map.logic?f.warn("[AngularJS - Leaflet] Available event propagation logic are: 'emit' or 'broadcast'."):c=l.map.logic,i(l.map.enable)&&l.map.enable.length>=0?e.each(l.map.enable,function(a){b.indexOf(a)===-1&&m.indexOf(a)!==-1&&b.push(a)}):f.warn("[AngularJS - Leaflet] event-broadcast.map.enable must be an object check your model.")):f.warn("[AngularJS - Leaflet] event-broadcast.map must be an object check your model."):b=m,n(a,g.id,b,"eventName",k,c)})}}}]),a.module("ui-leaflet").directive("geojson",["$timeout","leafletLogger","leafletData","leafletHelpers","leafletWatchHelpers","leafletDirectiveControlsHelpers","leafletIterators","leafletGeoJsonEvents",function(b,c,d,e,f,g,h,i){var j=f.maybeWatch,k=e.watchOptions,l=g.extend,m=e,n=h,o={changeFromDirective:!1};return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(b,c,f,g){var h=e.isDefined,p=g.getLeafletScope(),q={},r=!1;g.getMap().then(function(b){var c;c=p.watchOptions&&p.watchOptions.geojson?p.watchOptions.geojson:k;var g=function(b,c){var d;return d=a.isFunction(b.onEachFeature)?b.onEachFeature:function(a,d){e.LabelPlugin.isLoaded()&&h(a.properties.description)&&d.bindLabel(a.properties.description),i.bindEvents(f.id,d,null,a,p,c,{resetStyleOnMouseout:b.resetStyleOnMouseout,mapId:f.id})}},s=m.isDefined(f.geojsonNested)&&m.isTruthy(f.geojsonNested),t=function(){if(q){var a=function(a){h(a)&&b.hasLayer(a)&&b.removeLayer(a)};return s?void n.each(q,function(b){a(b)}):void a(q)}},u=function(a,c){if(h(a)&&h(a.data)){var e=g(a,c);h(a.options)||m.modelChangeInDirective(o,"changeFromDirective",function(){a.options={style:a.style,filter:a.filter,onEachFeature:e,pointToLayer:a.pointToLayer}});var i=L.geoJson(a.data,a.options);c&&m.isString(c)?q[c]=i:q=i,i.addTo(b),r||(r=!0,d.setGeoJSON(q,f.id))}},v=function(a){if(t(),s){if(!a||!Object.keys(a).length)return;return void n.each(a,function(a,b){u(a,b)})}u(a)};l(f.id,"geojson",v,t),j(p,"geojson",c,function(a){o.changeFromDirective||v(a)})})}}}]),a.module("ui-leaflet").directive("layercontrol",["$filter","leafletLogger","leafletData","leafletHelpers",function(b,c,d,e){var f=c;return{restrict:"E",scope:{icons:"=?",autoHideOpacity:"=?",showGroups:"=?",title:"@",baseTitle:"@",overlaysTitle:"@"},replace:!0,transclude:!1,require:"^leaflet",controller:["$scope","$element","$sce",function(b,c,g){f.debug("[Angular Directive - Layers] layers",b,c);var h=e.safeApply,i=e.isDefined;a.extend(b,{baselayer:"",oldGroup:"",layerProperties:{},groupProperties:{},rangeIsSupported:e.rangeIsSupported(),changeBaseLayer:function(a,c){e.safeApply(b,function(c){c.baselayer=a,d.getMap().then(function(e){d.getLayers().then(function(d){if(!e.hasLayer(d.baselayers[a])){for(var f in c.layers.baselayers)c.layers.baselayers[f].icon=c.icons.unradio,e.hasLayer(d.baselayers[f])&&e.removeLayer(d.baselayers[f]);e.addLayer(d.baselayers[a]),c.layers.baselayers[a].icon=b.icons.radio}})})}),c.preventDefault()},moveLayer:function(a,c,d){var e=Object.keys(b.layers.baselayers).length;if(c>=1+e&&c<=b.overlaysArray.length+e){var f;for(var g in b.layers.overlays)if(b.layers.overlays[g].index===c){f=b.layers.overlays[g];break}f&&h(b,function(){f.index=a.index,a.index=c})}d.stopPropagation(),d.preventDefault()},initIndex:function(a,c){var d=Object.keys(b.layers.baselayers).length;a.index=i(a.index)?a.index:c+d+1},initGroup:function(a){b.groupProperties[a]=b.groupProperties[a]?b.groupProperties[a]:{}},toggleOpacity:function(a,c){if(c.visible){if(b.autoHideOpacity&&!b.layerProperties[c.name].opacityControl)for(var d in b.layerProperties)b.layerProperties[d].opacityControl=!1;b.layerProperties[c.name].opacityControl=!b.layerProperties[c.name].opacityControl}a.stopPropagation(),a.preventDefault()},toggleLegend:function(a){b.layerProperties[a.name].showLegend=!b.layerProperties[a.name].showLegend},showLegend:function(a){return a.legend&&b.layerProperties[a.name].showLegend},unsafeHTML:function(a){return g.trustAsHtml(a)},getOpacityIcon:function(a){return a.visible&&b.layerProperties[a.name].opacityControl?b.icons.close:b.icons.open},getGroupIcon:function(a){return a.visible?b.icons.check:b.icons.uncheck},changeGroupVisibility:function(a){if(i(b.groupProperties[a])){var c=b.groupProperties[a].visible;for(var d in b.layers.overlays){var e=b.layers.overlays[d];e.group===a&&(e.visible=c)}}}});var j=c.get(0);L.Browser.touch?L.DomEvent.on(j,"click",L.DomEvent.stopPropagation):(L.DomEvent.disableClickPropagation(j),L.DomEvent.on(j,"mousewheel",L.DomEvent.stopPropagation))}],template:'<div class="angular-leaflet-control-layers" ng-show="overlaysArray.length"><h4 ng-if="title">{{ title }}</h4><div class="lf-baselayers"><h5 class="lf-title" ng-if="baseTitle">{{ baseTitle }}</h5><div class="lf-row" ng-repeat="(key, layer) in baselayersArray"><label class="lf-icon-bl" ng-click="changeBaseLayer(key, $event)"><input class="leaflet-control-layers-selector" type="radio" name="lf-radio" ng-show="false" ng-checked="baselayer === key" ng-value="key" /> <i class="lf-icon lf-icon-radio" ng-class="layer.icon"></i><div class="lf-text">{{layer.name}}</div></label></div></div><div class="lf-overlays"><h5 class="lf-title" ng-if="overlaysTitle">{{ overlaysTitle }}</h5><div class="lf-container"><div class="lf-row" ng-repeat="layer in (o = (overlaysArray | orderBy:\'index\':order))" ng-init="initIndex(layer, $index)"><label class="lf-icon-ol-group" ng-if="showGroups &amp;&amp; layer.group &amp;&amp; layer.group != o[$index-1].group"><input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-change="changeGroupVisibility(layer.group)" ng-model="groupProperties[layer.group].visible"/> <i class="lf-icon lf-icon-check" ng-class="getGroupIcon(groupProperties[layer.group])"></i><div class="lf-text">{{ layer.group }}</div></label><label class="lf-icon-ol"><input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-model="layer.visible"/> <i class="lf-icon lf-icon-check" ng-class="layer.icon"></i><div class="lf-text">{{layer.name}}</div></label><div class="lf-icons"><i class="lf-icon lf-up" ng-class="icons.up" ng-click="moveLayer(layer, layer.index - orderNumber, $event)"></i> <i class="lf-icon lf-down" ng-class="icons.down" ng-click="moveLayer(layer, layer.index + orderNumber, $event)"></i> <i class="lf-icon lf-toggle-legend" ng-class="icons.toggleLegend" ng-if="layer.legend" ng-click="toggleLegend(layer)"></i> <i class="lf-icon lf-open" ng-class="getOpacityIcon(layer)" ng-click="toggleOpacity($event, layer)"></i></div><div class="lf-legend" ng-if="showLegend(layer)" ng-bind-html="unsafeHTML(layer.legend)"></div><div class="lf-opacity clearfix" ng-if="layer.visible &amp;&amp; layerProperties[layer.name].opacityControl"><label ng-if="rangeIsSupported" class="pull-left" style="width: 50%">0</label><label ng-if="rangeIsSupported" class="pull-left text-right" style="width: 50%">100</label><input ng-if="rangeIsSupported" class="clearfix" type="range" min="0" max="1" step="0.05" class="lf-opacity-control" ng-model="layerProperties[layer.name].layerOptions.opacity"/><h6 ng-if="!rangeIsSupported">Range is not supported in this browser</h6></div></div></div></div></div>',link:function(b,c,f,g){var h=e.isDefined,i=g.getLeafletScope(),j=i.layers;b.$watch("icons",function(){var c={uncheck:"fa fa-square-o",check:"fa fa-check-square-o",radio:"fa fa-dot-circle-o",unradio:"fa fa-circle-o",up:"fa fa-angle-up",down:"fa fa-angle-down",open:"fa fa-angle-double-down",close:"fa fa-angle-double-up",toggleLegend:"fa fa-pencil-square-o"};h(b.icons)?(a.extend(c,b.icons),a.extend(b.icons,c)):b.icons=c}),f.order=!h(f.order)||"normal"!==f.order&&"reverse"!==f.order?"normal":f.order,b.order="normal"===f.order,b.orderNumber="normal"===f.order?-1:1,b.layers=j,g.getMap().then(function(a){i.$watch("layers.baselayers",function(c){var e={};d.getLayers().then(function(d){var f;for(f in c){var g=c[f];g.icon=b.icons[a.hasLayer(d.baselayers[f])?"radio":"unradio"],e[f]=g}b.baselayersArray=e})}),i.$watch("layers.overlays",function(a){var c=[],e={};d.getLayers().then(function(){var d;for(d in a){var f=a[d];f.icon=b.icons[f.visible?"check":"uncheck"],c.push(f),h(b.layerProperties[f.name])||(h(f.layerOptions.opacity)&&(f.layerOptions.opacity=1),b.layerProperties[f.name]={opacityControl:!1,showLegend:!0,layerOptions:f.layerOptions}),h(f.group)&&(h(b.groupProperties[f.group])||(b.groupProperties[f.group]={visible:!1}),e[f.group]=h(e[f.group])?e[f.group]:{count:0,visibles:0},e[f.group].count++,f.visible&&e[f.group].visibles++)}for(d in e)b.groupProperties[d].visible=e[d].visibles===e[d].count;b.overlaysArray=c})},!0)})}}}]),a.module("ui-leaflet").directive("layers",["leafletLogger","$q","leafletData","leafletHelpers","leafletLayerHelpers","leafletControlHelpers",function(b,c,d,e,f,g){return{restrict:"A",scope:!1,replace:!1,require:"leaflet",controller:["$scope",function(a){a._leafletLayers=c.defer(),this.getLayers=function(){return a._leafletLayers.promise}}],link:function(b,c,h,i){var j=e.isDefined,k={},l=i.getLeafletScope(),m=l.layers,n=f.createLayer,o=f.safeAddLayer,p=f.safeRemoveLayer,q=f.changeOpacityListener,r=g.updateLayersControl,s=!1;b.$on("$destroy",function(){g.destroyMapLayersControl(b.mapId)}),i.getMap().then(function(c){b._leafletLayers.resolve(k),d.setLayers(k,h.id),k.baselayers={},k.overlays={};var e=h.id,f=!1;for(var g in m.baselayers){var i=n(m.baselayers[g]);j(i)?(k.baselayers[g]=i,m.baselayers[g].top===!0&&(o(c,k.baselayers[g]),f=!0)):delete m.baselayers[g]}!f&&Object.keys(k.baselayers).length>0&&o(c,k.baselayers[Object.keys(m.baselayers)[0]]);for(g in m.overlays){"cartodb"===m.overlays[g].type;var t=n(m.overlays[g]);j(t)?(k.overlays[g]=t,m.overlays[g].visible===!0&&o(c,k.overlays[g])):delete m.overlays[g]}l.$watch("layers.baselayers",function(b,d){if(a.equals(b,d))return s=r(c,e,s,b,m.overlays,k),!0;for(var f in k.baselayers)j(b[f])&&!b[f].doRefresh||(c.hasLayer(k.baselayers[f])&&c.removeLayer(k.baselayers[f]),delete k.baselayers[f],b[f]&&b[f].doRefresh&&(b[f].doRefresh=!1));for(var g in b)if(j(k.baselayers[g]))b[g].top!==!0||c.hasLayer(k.baselayers[g])?b[g].top===!1&&c.hasLayer(k.baselayers[g])&&c.removeLayer(k.baselayers[g]):o(c,k.baselayers[g]);else{var h=n(b[g]);j(h)&&(k.baselayers[g]=h,b[g].top===!0&&o(c,k.baselayers[g]))}var i=!1;for(var l in k.baselayers)if(c.hasLayer(k.baselayers[l])){i=!0;break}!i&&Object.keys(k.baselayers).length>0&&o(c,k.baselayers[Object.keys(k.baselayers)[0]]),s=r(c,e,s,b,m.overlays,k)},!0),l.$watch("layers.overlays",function(b,d){if(a.equals(b,d))return s=r(c,e,s,m.baselayers,b,k),!0;for(var f in k.overlays)if(!j(b[f])||b[f].doRefresh){if(c.hasLayer(k.overlays[f])){var g=j(b[f])?b[f].layerOptions:null;p(c,k.overlays[f],g)}delete k.overlays[f],b[f]&&b[f].doRefresh&&(b[f].doRefresh=!1)}for(var h in b){if(j(k.overlays[h])){b[h].visible&&!c.hasLayer(k.overlays[h])?o(c,k.overlays[h]):b[h].visible===!1&&c.hasLayer(k.overlays[h])&&p(c,k.overlays[h],b[h].layerOptions);var i=k.overlays[h];c.hasLayer(k.overlays[h])&&(b[h].layerOptions.opacity!==d[h].layerOptions.opacity&&(j(i.setOpacity)&&i.setOpacity(b[h].layerOptions.opacity),j(i.getLayers)&&j(i.eachLayer)&&i.eachLayer(q(b[h].layerOptions.opacity))),j(b[h].index)&&i.setZIndex&&b[h].index!==d[h].index&&i.setZIndex(b[h].index))}else{var l=n(b[h]);if(!j(l))continue;k.overlays[h]=l,b[h].visible===!0&&o(c,k.overlays[h]),j(b[h].index)&&k.overlays[h].setZIndex&&k.overlays[h].setZIndex(b[h].index)}b[h].visible&&c._loaded&&b[h].data&&"heatmap"===b[h].type&&(k.overlays[h].setData(b[h].data),k.overlays[h].update())}s=r(c,e,s,m.baselayers,b,k)},!0)})}}}]),a.module("ui-leaflet").directive("legend",["leafletLogger","$http","$timeout","leafletHelpers","leafletLegendHelpers",function(a,b,c,d,e){var f=a,g=d.errorHeader+" [Legend] ";return{restrict:"A",scope:!1,replace:!1,require:"leaflet",transclude:!1,link:function(a,b,c,h){var i,j,k,l,m=d.isArray,n=d.isString,o=d.isDefined,p=d.isFunction,q=h.getLeafletScope(),r=q.legend;q.$watch("legend",function(a){o(a)&&(i=a.legendClass?a.legendClass:"legend",j=a.position||"bottomright",l=a.type||"arcgis")},!0);var s=function(a,b,c){b&&b.layers&&b.layers.length>0&&(o(k)?e.updateLegend(k.getContainer(),b,l,c):(k=L.control({position:j}),k.onAdd=e.getOnAddLegend(b,i,l,c),k.addTo(a)),o(r.loadedData)&&p(r.loadedData)&&r.loadedData())};h.getMap().then(function(a){q.$watch("legend",function(b){return o(b)?o(b.url)||"arcgis"!==l||m(b.colors)&&m(b.labels)&&b.colors.length===b.labels.length?o(b.url)?void f.info(g+" loading legend service."):(o(k)&&(k.removeFrom(a),k=null),k=L.control({position:j}),"arcgis"===l&&(k.onAdd=e.getOnAddArrayLegend(b,i)),void k.addTo(a)):void f.warn(g+" legend.colors and legend.labels must be set."):void(o(k)&&(k.removeFrom(a),k=null))}),q.$watch("legend.url",function(b){if(o(b)){if(!m(b)&&!n(b))return void f.warn(g+" legend.url must be an array or string.");for(var d,h=n(b)?[b]:b,i=function(c,e){return function(i){o(i.data.error)?f.warn(g+"Error loadin legend from: "+e,i.data.error.message):d&&d.layers&&d.layers.length>0?d.layers=d.layers.concat(i.data.layers):d=i.data,c===h.length-1&&s(a,d,b)}},j=function(a){f.warn(g+" legend.url not loaded.",a)},k=0;k<h.length;k++)e.addLegendURL(c.id,{url:h[k],method:"GET"}).then(i(k)).catch(j)}}),q.$watch("legend.legendData",function(b){f.debug("legendData",b),!o(q.legend.url)&&o(b)&&s(a,b)},!0)})}}}]),a.module("ui-leaflet").directive("markers",["leafletLogger","$rootScope","$q","leafletData","leafletHelpers","leafletMapDefaults","leafletMarkersHelpers","leafletMarkerEvents","leafletIterators","leafletWatchHelpers","leafletDirectiveControlsHelpers",function(b,c,d,e,f,g,h,i,j,k,l){var m=f.isDefined,n=f.errorHeader,o=f,p=f.isString,q=h.addMarkerWatcher,r=h.updateMarker,s=h.listenMarkerEvents,t=h.addMarkerToGroup,u=h.createMarker,v=h.deleteMarker,w=h.getModelFromModels,x=h.getLayerModels,y=h.resetUnusedMarkerGroups,z=j,A=f.watchOptions,B=k.maybeWatch,C=l.extend,D=b,E={changeFromDirective:!1},F=function(a,b,c){if(Object.keys(a).length){if(c&&p(c)){if(!a[c]||!Object.keys(a[c]).length)return;return a[c][b]}return a[b]}},G=function(a,b,c,d){return d&&p(d)?(m(b[d])||(b[d]={}),b[d][c]=a):b[c]=a,a},H=function(a,b,c,d,e,f){if(!p(a))return D.error(n+" A layername must be a string"),!1;if(!m(b))return D.error(n+" You must add layers to the directive if the markers are going to use this functionality."),!1;if(!m(b.overlays)||!m(b.overlays[a]))return D.error(n+' A marker can only be added to a layer of type "group"'),!1;var g=b.overlays[a];return g instanceof L.LayerGroup||g instanceof L.FeatureGroup?(g.addLayer(d),null===e&&f.hasLayer(d)&&c.focus===!0&&d.openPopup(),!0):(D.error(n+' Adding a marker to an overlay needs a overlay of the type "group" or "featureGroup"'),!1)},I=function(a,b,c,d,e,f,g,h,j,k){z.each(b,function(b,l){if(!k[l]){if(l.search("-")!==-1)return void D.error('The marker can\'t use a "-" on his key name: "'+l+'".');var p=o.getObjectDotPath(j?[j,l]:[l]),v=F(f,l,j);o.modelChangeInDirective(E,"changeFromDirective",function(){if(m(v)){var k=w(c,l,j);r(b,k,v,p,g,e,d)}else{var x=u(b),y=(b?b.layer:void 0)||j;if(!m(x))return void D.error(n+" Received invalid data on the marker "+l+".");if(G(x,f,l,j),
+m(b.message)&&x.bindPopup(b.message,b.popupOptions),m(b.group)){var z=m(b.groupOption)?b.groupOption:null;t(x,b.group,z,d)}if(o.LabelPlugin.isLoaded()&&m(b.label)&&m(b.label.message)&&x.bindLabel(b.label.message,b.label.options),m(b)&&(m(b.layer)||m(j))){var A=H(y,e,b,x,h.individual.type,d);if(!A)return}else m(b.group)||(d.addLayer(x),null===h.individual.type&&b.focus===!0&&x.openPopup());null!==h.individual.type&&q(x,p,g,e,d,h.individual),s(x,b,g,h.individual.type,d),i.bindEvents(a,x,p,b,g,y)}})}})},J=function(b,c,d,e,f){var g,h,i=!1,j=!1,k=m(c);for(var l in d)i||(D.debug(n+"[markers] destroy: "),i=!0),k&&(h=b[l],g=c[l],j=e&&a.equals(h,g)),m(b)&&Object.keys(b).length&&m(b[l])&&Object.keys(b[l]).length&&!j||f&&o.isFunction(f)&&f(h,g,l)},K=function(a,b,c,d,e){J(a,b,c,!1,function(a,b,f){D.debug(n+"[marker] is deleting marker: "+f),v(c[f],d,e),delete c[f]})},M=function(a,b,c){var d={};return J(a,b,c,!0,function(a,b,c){D.debug(n+"[marker] is already rendered, marker: "+c),d[c]=a}),d};return{restrict:"A",scope:!1,replace:!1,require:["leaflet","?layers"],link:function(a,b,c,f){var g=f[0],h=g.getLeafletScope();g.getMap().then(function(b){var g,i={};g=m(f[1])?f[1].getLayers:function(){var a=d.defer();return a.resolve(),a.promise};var j;j=h.watchOptions&&h.watchOptions.markers?h.watchOptions.markers:A;var k=m(c.markersNested)&&o.isTruthy(c.markersNested);g().then(function(d){var f=function(a,c){return y(),k?void z.each(a,function(a,e){var f=x(c,e);K(a,f,i[e],b,d)}):void K(a,c,i,b,d)},g=function(a,e){f(a,e);var g=null;return k?void z.each(a,function(f,k){var l=x(e,k),m=x(a,k);g=M(m,l,i[k]),I(c.id,f,e,b,d,i,h,j,k,g)}):(g=M(a,e,i),void I(c.id,a,e,b,d,i,h,j,void 0,g))};C(c.id,"markers",g,f),e.setMarkers(i,c.id),B(h,"markers",j,function(a,b){E.changeFromDirective||g(a,b)}),a.$on("$destroy",function(){K(h.markers,{},i,b,d)})})})}}}]),a.module("ui-leaflet").directive("maxbounds",["leafletLogger","leafletMapDefaults","leafletBoundsHelpers","leafletHelpers",function(a,b,c,d){return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(a,b,e,f){var g=f.getLeafletScope(),h=c.isValidBounds,i=d.isNumber;f.getMap().then(function(a){g.$watch("maxbounds",function(b){if(!h(b))return void a.setMaxBounds();var d=c.createLeafletBounds(b);i(b.pad)&&(d=d.pad(b.pad)),a.setMaxBounds(d),e.center||e.lfCenter||a.fitBounds(d)})})}}}]),a.module("ui-leaflet").directive("paths",["leafletLogger","$q","leafletData","leafletMapDefaults","leafletHelpers","leafletPathsHelpers","leafletPathEvents","leafletWatchHelpers",function(a,b,c,d,e,f,g,h){var i=a;return{restrict:"A",scope:!1,replace:!1,require:["leaflet","?layers"],link:function(a,j,k,l){var m=l[0],n=e.isDefined,o=e.isString,p=m.getLeafletScope(),q=p.paths,r=f.createPath,s=g.bindPathEvents,t=f.setPathOptions,u=h.maybeWatch;m.getMap().then(function(a){var f,g=d.getDefaults(k.id);if(f=n(l[1])?l[1].getLayers:function(){var a=b.defer();return a.resolve(),a.promise},n(q)){var h,j={type:"watchCollection",individual:{type:"watchDeep"}};h=p.watchOptions&&p.watchOptions.paths?p.watchOptions.paths:j,f().then(function(b){var d={};c.setPaths(d,k.id);var f=function(c,d,e){var f='paths["'+d+'"]';u(p,f,e,function(d,e,f){if(!n(d)){if(n(e.layer))for(var g in b.overlays){var h=b.overlays[g];h.removeLayer(c)}return a.removeLayer(c),void f()}t(c,d.type,d)})},j=function(b){for(var c in d)n(b[c])||(a.removeLayer(d[c]),delete d[c])},l=function(c){j(c);for(var l in c)if(0!==l.search("\\$"))if(l.search("-")===-1){if(!n(d[l])){var m=c[l],q=r(l,c[l],g);if(n(q)&&n(m.message)&&q.bindPopup(m.message,m.popupOptions),e.LabelPlugin.isLoaded()&&n(m.label)&&n(m.label.message)&&q.bindLabel(m.label.message,m.label.options),n(m)&&n(m.layer)){if(!o(m.layer)){i.error("[AngularJS - Leaflet] A layername must be a string");continue}if(!n(b)){i.error("[AngularJS - Leaflet] You must add layers to the directive if the markers are going to use this functionality.");continue}if(!n(b.overlays)||!n(b.overlays[m.layer])){i.error('[AngularJS - Leaflet] A path can only be added to a layer of type "group"');continue}var u=b.overlays[m.layer];if(!(u instanceof L.LayerGroup||u instanceof L.FeatureGroup)){i.error('[AngularJS - Leaflet] Adding a path to an overlay needs a overlay of the type "group" or "featureGroup"');continue}d[l]=q,u.addLayer(q),null!==h.individual.type?f(q,l,h.individual):t(q,m.type,m)}else n(q)&&(d[l]=q,a.addLayer(q),null!==h.individual.type?f(q,l,h.individual):t(q,m.type,m));s(k.id,q,l,m,p)}}else i.error('[AngularJS - Leaflet] The path name "'+l+'" is not valid. It must not include "-" and a number.')};u(p,"paths",h,function(a){l(a)})})}})}}}]),a.module("ui-leaflet").directive("tiles",["leafletLogger","leafletData","leafletMapDefaults","leafletHelpers",function(b,c,d,e){var f=b;return{restrict:"A",scope:!1,replace:!1,require:"leaflet",link:function(b,g,h,i){var j=e.isDefined,k=i.getLeafletScope(),l=k.tiles;return j(l)&&j(l.url)?void i.getMap().then(function(b){var e,f=d.getDefaults(h.id);k.$watch("tiles",function(d){var g=f.tileLayerOptions,i=f.tileLayer;return!j(d.url)&&j(e)?void b.removeLayer(e):j(e)?j(d.url)&&j(d.options)&&!a.equals(d.options,g)?(b.removeLayer(e),g=f.tileLayerOptions,a.copy(d.options,g),i=d.url,e=L.tileLayer(i,g),e.addTo(b),void c.setTiles(e,h.id)):void(j(d.url)&&e.setUrl(d.url)):(j(d.options)&&a.copy(d.options,g),j(d.url)&&(i=d.url),e=L.tileLayer(i,g),e.addTo(b),void c.setTiles(e,h.id))},!0)}):void f.warn("[AngularJS - Leaflet] The 'tiles' definition doesn't have the 'url' property.")}}}]),a.module("ui-leaflet").directive("watchOptions",["$log","$rootScope","$q","leafletData","leafletHelpers",function(b,c,d,e,f){var g=f.isDefined,h=f.errorHeader,i=f.isObject,j=b;return{restrict:"A",scope:!1,replace:!1,require:["leaflet"],link:function(b,c,d,e){var f=e[0],k=f.getLeafletScope(),l=function(a){return"watch"===a||"watchCollection"===a||"watchDeep"===a||null===a};g(k.watchOptions)&&i(k.watchOptions)&&a.forEach(["markers","geojson","paths"],function(a){g(k.watchOptions[a])&&(l(k.watchOptions[a].type)||j.error(h+" watchOptions."+a+".type is not a valid type."),g(k.watchOptions[a].individual)?l(k.watchOptions[a].individual.type)||j.error(h+" watchOptions."+a+".individual.type is not a valid type."):j.error(h+" watchOptions."+a+".type.individual must be defined."))})}}}]),a.module("ui-leaflet").factory("leafletEventsHelpersFactory",["$rootScope","$q","leafletLogger","leafletHelpers",function(b,c,d,e){var f=e.safeApply,g=e.isDefined,h=e.isObject,i=e.isArray,j=e.errorHeader,k=d,l=function(a,b){this.rootBroadcastName=a,k.debug("leafletEventsHelpersFactory: lObjectType: "+b+"rootBroadcastName: "+a),this.lObjectType=b};return l.prototype.getAvailableEvents=function(){return[]},l.prototype.genDispatchEvent=function(a,b,c,d,e,f,g,h,i){var j=this;return a=a||"",a&&(a="."+a),function(l){var m=j.rootBroadcastName+a+"."+b;k.debug(m),j.fire(d,m,c,l,l.target||e,g,f,h,i)}},l.prototype.fire=function(c,d,e,h,i,j,k,l,m){f(c,function(){var f={leafletEvent:h,leafletObject:i,modelName:k,model:j};g(l)&&a.extend(f,{layerName:l}),"emit"===e?c.$emit(d,f):b.$broadcast(d,f)})},l.prototype.bindEvents=function(a,b,c,d,e,f,l){var m=[],n="emit",o=this;if(g(e.eventBroadcast))if(h(e.eventBroadcast))if(g(e.eventBroadcast[o.lObjectType]))if(h(e.eventBroadcast[o.lObjectType])){g(e.eventBroadcast[this.lObjectType].logic)&&"emit"!==e.eventBroadcast[o.lObjectType].logic&&"broadcast"!==e.eventBroadcast[o.lObjectType].logic&&k.warn(j+"Available event propagation logic are: 'emit' or 'broadcast'.");var p=!1,q=!1;g(e.eventBroadcast[o.lObjectType].enable)&&i(e.eventBroadcast[o.lObjectType].enable)&&(p=!0),g(e.eventBroadcast[o.lObjectType].disable)&&i(e.eventBroadcast[o.lObjectType].disable)&&(q=!0),p&&q?k.warn(j+"can not enable and disable events at the same time"):p||q?p?e.eventBroadcast[this.lObjectType].enable.forEach(function(a){m.indexOf(a)!==-1?k.warn(j+"This event "+a+" is already enabled"):o.getAvailableEvents().indexOf(a)===-1?k.warn(j+"This event "+a+" does not exist"):m.push(a)}):(m=this.getAvailableEvents(),e.eventBroadcast[o.lObjectType].disable.forEach(function(a){var b=m.indexOf(a);b===-1?k.warn(j+"This event "+a+" does not exist or has been already disabled"):m.splice(b,1)})):k.warn(j+"must enable or disable events")}else k.warn(j+"event-broadcast."+[o.lObjectType]+" must be an object check your model.");else m=this.getAvailableEvents();else k.error(j+"event-broadcast must be an object check your model.");else m=this.getAvailableEvents();return m.forEach(function(g){b.on(g,o.genDispatchEvent(a,g,n,e,b,c,d,f,l))}),n},l}]).service("leafletEventsHelpers",["leafletEventsHelpersFactory",function(a){return new a}]),a.module("ui-leaflet").factory("leafletGeoJsonEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpersFactory","leafletData",function(a,b,c,d,e,f){var g=d.safeApply,h=e,i=function(){h.call(this,"leafletDirectiveGeoJson","geojson")};return i.prototype=new h,i.prototype.genDispatchEvent=function(b,c,d,e,i,j,k,l,m){var n=h.prototype.genDispatchEvent.call(this,b,c,d,e,i,j,k,l),o=this;return function(b){"mouseout"===c&&(m.resetStyleOnMouseout&&f.getGeoJSON(m.mapId).then(function(a){var c=l?a[l]:a;c.resetStyle(b.target)}),g(e,function(){a.$broadcast(o.rootBroadcastName+".mouseout",b)})),n(b)}},i.prototype.getAvailableEvents=function(){return["click","dblclick","mouseover","mouseout"]},new i}]),a.module("ui-leaflet").factory("leafletLabelEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpersFactory",function(a,b,c,d,e){var f=d,g=e,h=function(){g.call(this,"leafletDirectiveLabel","markers")};return h.prototype=new g,h.prototype.genDispatchEvent=function(a,b,c,d,e,f,h,i){var j=f.replace("markers.","");return g.prototype.genDispatchEvent.call(this,a,b,c,d,e,j,h,i)},h.prototype.getAvailableEvents=function(){return["click","dblclick","mousedown","mouseover","mouseout","contextmenu"]},h.prototype.genEvents=function(a,b,c,d,e,g,h,i){var j=this,k=this.getAvailableEvents(),l=f.getObjectArrayPath("markers."+g);k.forEach(function(b){e.label.on(b,j.genDispatchEvent(a,b,c,d,e.label,l,h,i))})},h.prototype.bindEvents=function(a,b,c,d,e,f){},new h}]),a.module("ui-leaflet").factory("leafletMapEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpers","leafletIterators",function(a,b,c,d,e,f){var g=d.isDefined,h=e.fire,i=function(){return["click","dblclick","mousedown","mouseup","mouseover","mouseout","mousemove","contextmenu","focus","blur","preclick","load","unload","viewreset","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoomanim","zoomend","zoomlevelschange","resize","autopanstart","layeradd","layerremove","baselayerchange","overlayadd","overlayremove","locationfound","locationerror","popupopen","popupclose","draw:created","draw:edited","draw:deleted","draw:drawstart","draw:drawstop","draw:editstart","draw:editstop","draw:deletestart","draw:deletestop"]},j=function(a,b,d,e){return e&&(e+="."),function(f){var g="leafletDirectiveMap."+e+b;c.debug(g),h(a,g,d,f,f.target,a)}},k=function(a){a.$broadcast("boundsChanged")},l=function(a,b,c,d){if(g(c.urlHashCenter)){var e=b.getCenter(),f=e.lat.toFixed(4)+":"+e.lng.toFixed(4)+":"+b.getZoom();g(d.c)&&d.c===f||a.$emit("centerUrlHash",f)}},m=function(a,b,c,d,e,g){f.each(c,function(c){var f={};f[d]=c,b||(b=a._container.id||""),a.on(c,j(e,c,g,b),f)})};return{getAvailableMapEvents:i,genDispatchMapEvent:j,notifyCenterChangedToBounds:k,notifyCenterUrlHashChanged:l,addEvents:m}}]),a.module("ui-leaflet").factory("leafletMarkerEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletEventsHelpersFactory","leafletLabelEvents",function(a,b,c,d,e,f){var g=d.safeApply,h=d.isDefined,i=d,j=f,k=e,l=function(){k.call(this,"leafletDirectiveMarker","markers")};return l.prototype=new k,l.prototype.genDispatchEvent=function(b,c,d,e,f,h,i,j){var l=k.prototype.genDispatchEvent.call(this,b,c,d,e,f,h,i,j);return function(b){"click"===c?g(e,function(){a.$broadcast("leafletDirectiveMarkersClick",h)}):"dragend"===c&&(g(e,function(){i.lat=f.getLatLng().lat,i.lng=f.getLatLng().lng}),i.message&&i.focus===!0&&f.openPopup()),l(b)}},l.prototype.getAvailableEvents=function(){return["click","dblclick","mousedown","mouseover","mouseout","contextmenu","dragstart","drag","dragend","move","remove","popupopen","popupclose","touchend","touchstart","touchmove","touchcancel","touchleave"]},l.prototype.bindEvents=function(a,b,c,d,e,f){var g=k.prototype.bindEvents.call(this,a,b,c,d,e,f);i.LabelPlugin.isLoaded()&&h(b.label)&&j.genEvents(a,c,g,e,b,d,f)},new l}]);var d="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol?"symbol":typeof a};a.module("ui-leaflet").factory("leafletPathEvents",["$rootScope","$q","leafletLogger","leafletHelpers","leafletLabelEvents","leafletEventsHelpers",function(a,b,c,e,f,g){var h=e.isDefined,i=e.isObject,j=e,k=e.errorHeader,l=f,m=g.fire,n=c,o=function(a,b,c,d,e,f,g,h){return a=a||"",a&&(a="."+a),function(i){var j="leafletDirectivePath"+a+"."+b;n.debug(j),m(d,j,c,i,i.target||e,g,f,h)}},p=function(a,b,c,e,f){var g,m,p=[],r="broadcast";if(h(f.eventBroadcast))if(i(f.eventBroadcast))if(h(f.eventBroadcast.path))if(i(f.eventBroadcast.paths))n.warn(k+"event-broadcast.path must be an object check your model.");else{void 0!==f.eventBroadcast.path.logic&&null!==f.eventBroadcast.path.logic&&("emit"!==f.eventBroadcast.path.logic&&"broadcast"!==f.eventBroadcast.path.logic?n.warn(k+"Available event propagation logic are: 'emit' or 'broadcast'."):"emit"===f.eventBroadcast.path.logic&&(r="emit"));var s=!1,t=!1;if(void 0!==f.eventBroadcast.path.enable&&null!==f.eventBroadcast.path.enable&&"object"===d(f.eventBroadcast.path.enable)&&(s=!0),void 0!==f.eventBroadcast.path.disable&&null!==f.eventBroadcast.path.disable&&"object"===d(f.eventBroadcast.path.disable)&&(t=!0),s&&t)n.warn(k+"can not enable and disable events at the same time");else if(s||t)if(s)for(g=0;g<f.eventBroadcast.path.enable.length;g++)m=f.eventBroadcast.path.enable[g],p.indexOf(m)!==-1?n.warn(k+"This event "+m+" is already enabled"):q().indexOf(m)===-1?n.warn(k+"This event "+m+" does not exist"):p.push(m);else for(p=q(),g=0;g<f.eventBroadcast.path.disable.length;g++){m=f.eventBroadcast.path.disable[g];var u=p.indexOf(m);u===-1?n.warn(k+"This event "+m+" does not exist or has been already disabled"):p.splice(u,1)}else n.warn(k+"must enable or disable events")}else p=q();else n.error(k+"event-broadcast must be an object check your model.");else p=q();for(g=0;g<p.length;g++)m=p[g],b.on(m,o(a,m,r,f,p,c));j.LabelPlugin.isLoaded()&&h(b.label)&&l.genEvents(a,c,r,f,b,e)},q=function(){return["click","dblclick","mousedown","mouseover","mouseout","contextmenu","add","remove","popupopen","popupclose"]};return{getAvailablePathEvents:q,bindPathEvents:p}}])}(angular);
\ No newline at end of file
Index: bower_components/ui-leaflet/grunt/uglify.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/uglify.js	(revision )
+++ bower_components/ui-leaflet/grunt/uglify.js	(revision )
@@ -0,0 +1,14 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        options: {
+            banner: require('./utils/banner')
+        },
+        dist: {
+            files: {
+                'dist/<%= pkg.name %>.min.no-header.js': ['dist/<%= pkg.name %>.js']
+            }
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/shell.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/shell.js	(revision )
+++ bower_components/ui-leaflet/grunt/shell.js	(revision )
@@ -0,0 +1,25 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        options: {
+            stdout: true
+        },
+        selenium: {
+            command: 'node node_modules/protractor/bin/webdriver-manager start',
+            options: {
+                stdout: false,
+                async: true
+            }
+        },
+        protractor_update: {
+            command: 'node node_modules/protractor/bin/webdriver-manager update'
+        },
+        npm_install: {
+            command: 'npm install'
+        },
+        examples: {
+            command: 'node generate-examples.js'
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/jshint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/jshint.js	(revision )
+++ bower_components/ui-leaflet/grunt/jshint.js	(revision )
@@ -0,0 +1,17 @@
+'use strict';
+var fs = require('fs');
+
+module.exports = function (grunt, options) {
+    return {
+        options: JSON.parse(fs.readFileSync('.jshintrc')),
+        source: {
+            src: ['src/directives/*.js', 'src/services/*.js', 'website/js/**/*.js']
+        },
+        tests: {
+            src: ['test/unit/*.js', 'test/e2e/*.js']
+        },
+        grunt: {
+            src: ['Gruntfile.js']
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/pkg.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/pkg.js	(revision )
+++ bower_components/ui-leaflet/grunt/pkg.js	(revision )
@@ -0,0 +1,13 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    var pkgFunction = function () {
+        return grunt.file.readJSON('package.json')
+    };
+    //THIS extension forces the banner or whatever uses pkgFunction to always get the latest version
+    //where as pkg is only done once at grunt init.
+    _.extend(options, {
+        pkgFunction: pkgFunction
+    });
+    return pkgFunction();
+};
Index: bower_components/ui-leaflet/grunt/utils/karma.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/utils/karma.js	(revision )
+++ bower_components/ui-leaflet/grunt/utils/karma.js	(revision )
@@ -0,0 +1,33 @@
+const karmaLib = require('karma');
+//<=0.12 || //^0.13
+const twelveKarma = karmaLib.server ? karmaLib.server.start : undefined;
+const thirteenKarma = karmaLib.Server || undefined;
+const Karma = thirteenKarma || twelveKarma;
+
+// console.log(Karma,true);
+module.exports = (pathToKarmaFile, grunt) => {
+    var log;
+    log = grunt.log.oklns;
+    return (done, karmaConf) => {
+        var e, server;
+        if (karmaConf == null) {
+            karmaConf = require.resolve(pathToKarmaFile);
+        }
+        log('-- Karma Setup --');
+        try {
+            server = new Karma({
+                configFile: karmaConf,
+                singleRun: true
+            }, (code) => {
+                log("Karma Callback Code: " + code);
+                done(!code ? void 0 : false);
+            });
+            if (server.start)
+                server.start(); //^0.13
+        } catch (_error) {
+            e = _error;
+            log("KARMA ERROR: " + e);
+            return done(false);
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/ngAnnotate.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/ngAnnotate.js	(revision )
+++ bower_components/ui-leaflet/grunt/ngAnnotate.js	(revision )
@@ -0,0 +1,12 @@
+'use strict';
+
+module.exports = function ngAnnotate(grunt, options) {
+    return {
+        options: {},
+        dist: {
+            files: {
+                'dist/<%= pkg.name %>.js': ['dist/<%= pkg.name %>.pre.js']
+            }
+        }
+    };
+};
Index: bower_components/ui-leaflet/bower.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/bower.json	(revision )
+++ bower_components/ui-leaflet/bower.json	(revision )
@@ -0,0 +1,75 @@
+{
+  "name": "ui-leaflet",
+  "author": "https://github.com/angular-ui/ui-leaflet/graphs/contributors",
+  "description": "ui-leaflet - An AngularJS directive to easily interact with Leaflet maps",
+  "version": "2.0.0",
+  "homepage": "http://angular-ui.github.io/ui-leaflet/",
+  "keywords": [
+    "angularjs",
+    "javascript",
+    "directive",
+    "leaflet",
+    "angular-ui"
+  ],
+  "main": [
+    "dist/ui-leaflet.js"
+  ],
+  "dependencies": {
+    "angular": "1.x",
+    "angular-simple-logger": "~0.1.4",
+    "leaflet": "~0.7.x"
+  },
+  "resolutions": {
+    "angular": "~1.5.x",
+    "leaflet": "0.7.x"
+  },
+  "devDependencies": {
+    "jquery": "*",
+    "semantic-ui": "*",
+    "bootstrap": "*",
+    "prism": "*",
+    "angular-route": "1.x",
+    "angular-animate": "1.x",
+    "angular-mocks": "1.x",
+    "leaflet.markercluster": "~0.5.0",
+    "leaflet.draw": "*",
+    "Leaflet.label": "*",
+    "leaflet-tilelayer-geojson": "*",
+    "Leaflet.utfgrid": "danzel/Leaflet.utfgrid",
+    "Leaflet.awesome-markers": "*",
+    "leaflet-providers": "~1.1.5",
+    "leaflet.vector-markers": "0.0.4",
+    "webgl-heatmap-leaflet": "*",
+    "leaflet-plugins": "*",
+    "esri-leaflet": "~1.0.4",
+    "proj4": "*",
+    "font-awesome": "~4.3.x",
+    "proj4leaflet": "*",
+    "Leaflet.MakiMarkers": "*",
+    "Leaflet.heat": "https://github.com/Leaflet/Leaflet.heat/archive/gh-pages.tar.gz",
+    "Leaflet.ExtraMarkers": "https://github.com/coryasilva/Leaflet.ExtraMarkers/archive/v1.0.1.tar.gz",
+    "Leaflet.fullscreen": "http://github.com/Leaflet/Leaflet.fullscreen/archive/v0.0.4.tar.gz",
+    "Leaflet.PolylineDecorator": "bbecquet/Leaflet.PolylineDecorator",
+    "leaflet-minimap": "~2.2.0",
+    "esri-leaflet-clustered-feature-layer": "~1.0.x",
+    "esri-leaflet-heatmap-feature-layer": "~1.0.x",
+    "leaflet-search": "~1.5.8",
+    "highlightjs": "~8.8.0",
+    "angular-highlightjs": "~0.4.3"
+  },
+  "ignore": [
+    "dist/coverage/",
+    "dist/src/",
+    "website/",
+    "**/.*",
+    "src",
+    "doc",
+    "examples",
+    "test",
+    "*.md",
+    "Gruntfile.js",
+    "package.json",
+    "dist/coverage/",
+    "logo.svg"
+  ]
+}
Index: bower_components/ui-leaflet/grunt/protractor.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/protractor.js	(revision )
+++ bower_components/ui-leaflet/grunt/protractor.js	(revision )
@@ -0,0 +1,23 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        options: {
+            keepAlive: false,
+            configFile: 'test/protractor.conf.js',
+            args: {
+                specs: ['test/e2e/*.js']
+            }
+        },
+        run: {},
+        saucelabs: {
+            options: {
+                args: {
+                    baseUrl: "http://<%= pkg.org %>.github.io/<%= pkg.name %>/examples/",
+                    sauceUser: process.env.SAUCE_USERNAME,
+                    sauceKey: process.env.SAUCE_ACCESS_KEY
+                }
+            }
+        }
+    };
+};
Index: bower_components/ui-leaflet/LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/LICENSE	(revision )
+++ bower_components/ui-leaflet/LICENSE	(revision )
@@ -0,0 +1,23 @@
+The MIT License
+
+Copyright (c) https://github.com/angular-ui/ui-leaflet
+
+Original Copyright (c) https://github.com/tombatossals/angular-leaflet-directive
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
Index: bower_components/ui-leaflet/grunt/open.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/open.js	(revision )
+++ bower_components/ui-leaflet/grunt/open.js	(revision )
@@ -0,0 +1,12 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    return {
+        devserver: {
+            path: 'http://localhost:8888'
+        },
+        coverage: {
+            path: 'http://localhost:5555'
+        }
+    };
+};
Index: bower_components/ui-leaflet/grunt/clean.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/clean.js	(revision )
+++ bower_components/ui-leaflet/grunt/clean.js	(revision )
@@ -0,0 +1,9 @@
+'use strict';
+var pkg = require('./pkg');
+
+module.exports = function (grunt, options) {
+    return {
+        dist: ["dist/"],
+        pre: ['dist/*.pre.js']
+    };
+};
Index: bower_components/ui-leaflet/coffeelint.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/coffeelint.json	(revision )
+++ bower_components/ui-leaflet/coffeelint.json	(revision )
@@ -0,0 +1,114 @@
+{
+    "coffeescript_error": {
+        "level": "error"
+    },
+    "arrow_spacing": {
+        "name": "arrow_spacing",
+        "level": "warn"
+    },
+    "no_tabs": {
+        "name": "no_tabs",
+        "level": "error"
+    },
+    "no_trailing_whitespace": {
+        "name": "no_trailing_whitespace",
+        "level": "warn",
+        "allowed_in_comments": false,
+        "allowed_in_empty_lines": true
+    },
+    "max_line_length": {
+        "name": "max_line_length",
+        "value": 125,
+        "level": "warn",
+        "limitComments": true
+    },
+    "line_endings": {
+        "name": "line_endings",
+        "level": "ignore",
+        "value": "unix"
+    },
+    "no_trailing_semicolons": {
+        "name": "no_trailing_semicolons",
+        "level": "error"
+    },
+    "indentation": {
+        "name": "indentation",
+        "value": 4,
+        "level": "error"
+    },
+    "camel_case_classes": {
+        "name": "camel_case_classes",
+        "level": "error"
+    },
+    "colon_assignment_spacing": {
+        "name": "colon_assignment_spacing",
+        "level": "ignore",
+        "spacing": {
+            "left": 0,
+            "right": 1
+        }
+    },
+    "no_implicit_braces": {
+        "name": "no_implicit_braces",
+        "level": "ignore",
+        "strict": true
+    },
+    "no_plusplus": {
+        "name": "no_plusplus",
+        "level": "ignore"
+    },
+    "no_throwing_strings": {
+        "name": "no_throwing_strings",
+        "level": "error"
+    },
+    "no_backticks": {
+        "name": "no_backticks",
+        "level": "error"
+    },
+    "no_implicit_parens": {
+        "name": "no_implicit_parens",
+        "level": "ignore"
+    },
+    "no_empty_param_list": {
+        "name": "no_empty_param_list",
+        "level": "warn"
+    },
+    "no_stand_alone_at": {
+        "name": "no_stand_alone_at",
+        "level": "ignore"
+    },
+    "space_operators": {
+        "name": "space_operators",
+        "level": "warn"
+    },
+    "duplicate_key": {
+        "name": "duplicate_key",
+        "level": "error"
+    },
+    "empty_constructor_needs_parens": {
+        "name": "empty_constructor_needs_parens",
+        "level": "ignore"
+    },
+    "cyclomatic_complexity": {
+        "name": "cyclomatic_complexity",
+        "value": 10,
+        "level": "ignore"
+    },
+    "newlines_after_classes": {
+        "name": "newlines_after_classes",
+        "value": 3,
+        "level": "ignore"
+    },
+    "no_unnecessary_fat_arrows": {
+        "name": "no_unnecessary_fat_arrows",
+        "level": "warn"
+    },
+    "missing_fat_arrows": {
+        "name": "missing_fat_arrows",
+        "level": "ignore"
+    },
+    "non_empty_constructor_needs_parens": {
+        "name": "non_empty_constructor_needs_parens",
+        "level": "ignore"
+    }
+}
Index: bower_components/ui-leaflet/grunt/coveralls.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/grunt/coveralls.js	(revision )
+++ bower_components/ui-leaflet/grunt/coveralls.js	(revision )
@@ -0,0 +1,11 @@
+'use strict';
+
+module.exports = function (grunt, options) {
+    // Options
+    return {
+        options: {
+            debug: true,
+            coverage_dir: 'coverage'
+        }
+    };
+};
Index: bower_components/ui-leaflet/.bower.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/.bower.json	(revision )
+++ bower_components/ui-leaflet/.bower.json	(revision )
@@ -0,0 +1,85 @@
+{
+  "name": "ui-leaflet",
+  "author": "https://github.com/angular-ui/ui-leaflet/graphs/contributors",
+  "description": "ui-leaflet - An AngularJS directive to easily interact with Leaflet maps",
+  "version": "2.0.0",
+  "homepage": "http://angular-ui.github.io/ui-leaflet/",
+  "keywords": [
+    "angularjs",
+    "javascript",
+    "directive",
+    "leaflet",
+    "angular-ui"
+  ],
+  "main": [
+    "dist/ui-leaflet.js"
+  ],
+  "dependencies": {
+    "angular": "1.x",
+    "angular-simple-logger": "~0.1.4",
+    "leaflet": "~0.7.x"
+  },
+  "resolutions": {
+    "angular": "~1.5.x",
+    "leaflet": "0.7.x"
+  },
+  "devDependencies": {
+    "jquery": "*",
+    "semantic-ui": "*",
+    "bootstrap": "*",
+    "prism": "*",
+    "angular-route": "1.x",
+    "angular-animate": "1.x",
+    "angular-mocks": "1.x",
+    "leaflet.markercluster": "~0.5.0",
+    "leaflet.draw": "*",
+    "Leaflet.label": "*",
+    "leaflet-tilelayer-geojson": "*",
+    "Leaflet.utfgrid": "danzel/Leaflet.utfgrid",
+    "Leaflet.awesome-markers": "*",
+    "leaflet-providers": "~1.1.5",
+    "leaflet.vector-markers": "0.0.4",
+    "webgl-heatmap-leaflet": "*",
+    "leaflet-plugins": "*",
+    "esri-leaflet": "~1.0.4",
+    "proj4": "*",
+    "font-awesome": "~4.3.x",
+    "proj4leaflet": "*",
+    "Leaflet.MakiMarkers": "*",
+    "Leaflet.heat": "https://github.com/Leaflet/Leaflet.heat/archive/gh-pages.tar.gz",
+    "Leaflet.ExtraMarkers": "https://github.com/coryasilva/Leaflet.ExtraMarkers/archive/v1.0.1.tar.gz",
+    "Leaflet.fullscreen": "http://github.com/Leaflet/Leaflet.fullscreen/archive/v0.0.4.tar.gz",
+    "Leaflet.PolylineDecorator": "bbecquet/Leaflet.PolylineDecorator",
+    "leaflet-minimap": "~2.2.0",
+    "esri-leaflet-clustered-feature-layer": "~1.0.x",
+    "esri-leaflet-heatmap-feature-layer": "~1.0.x",
+    "leaflet-search": "~1.5.8",
+    "highlightjs": "~8.8.0",
+    "angular-highlightjs": "~0.4.3"
+  },
+  "ignore": [
+    "dist/coverage/",
+    "dist/src/",
+    "website/",
+    "**/.*",
+    "src",
+    "doc",
+    "examples",
+    "test",
+    "*.md",
+    "Gruntfile.js",
+    "package.json",
+    "dist/coverage/",
+    "logo.svg"
+  ],
+  "_release": "2.0.0",
+  "_resolution": {
+    "type": "version",
+    "tag": "v2.0.0",
+    "commit": "919b862389ddddc85c197746f3126fd24de0dc42"
+  },
+  "_source": "https://github.com/angular-ui/ui-leaflet.git",
+  "_target": "^2.0.0",
+  "_originalSource": "ui-leaflet",
+  "_direct": true
+}
\ No newline at end of file
Index: bower_components/ui-leaflet/dist/ui-leaflet_dev_mapped.js.map
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/dist/ui-leaflet_dev_mapped.js.map	(revision )
+++ bower_components/ui-leaflet/dist/ui-leaflet_dev_mapped.js.map	(revision )
@@ -0,0 +1,1 @@
+{"version":3,"sources":["src/directives/leaflet.js","src/services/eventManager.js","src/services/leafletBoundsHelpers.js","src/services/leafletControlHelpers.js","src/services/leafletData.js","src/services/leafletDirectiveControlsHelpers.js","src/services/leafletGeoJsonHelpers.js","src/services/leafletHelpers.js","src/services/leafletIterators.js","src/services/leafletLayerHelpers.js","src/services/leafletLegendHelpers.js","src/services/leafletMapDefaults.js","src/services/leafletMarkersHelpers.js","src/services/leafletPathsHelpers.js","src/services/leafletWatchHelpers.js","src/services/logger.js","src/services/nominatim.js","src/directives/bounds.js","src/directives/center.js","src/directives/controls.js","src/directives/decorations.js","src/directives/eventBroadcast.js","src/directives/geojson.js","src/directives/layercontrol.js","src/directives/layers.js","src/directives/legend.js","src/directives/markers.js","src/directives/maxbounds.js","src/directives/paths.js","src/directives/tiles.js","src/directives/watchOptions.js","src/services/events/leafletEventsHelpers.js","src/services/events/leafletGeoJsonEvents.js","src/services/events/leafletLabelEvents.js","src/services/events/leafletMapEvents.js","src/services/events/leafletMarkerEvents.js","src/services/events/leafletPathEvents.js"],"names":[],"mappings":"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","file":"ui-leaflet_dev_mapped.js","sourcesContent":["'use strict';\n\nangular.module('ui-leaflet', ['nemLogging']).directive('leaflet', function ($q, leafletData, leafletMapDefaults, leafletHelpers, leafletMapEvents) {\n    return {\n        restrict: \"EA\",\n        replace: true,\n        scope: {\n            center: '=',\n            lfCenter: '=',\n            defaults: '=',\n            maxbounds: '=',\n            bounds: '=',\n            markers: '=',\n            legend: '=',\n            geojson: '=',\n            paths: '=',\n            tiles: '=',\n            layers: '=',\n            controls: '=',\n            decorations: '=',\n            eventBroadcast: '=',\n            watchOptions: '=',\n            id: '@'\n        },\n        transclude: true,\n        template: '<div class=\"angular-leaflet-map\"><div ng-transclude></div></div>',\n        controller: function controller($scope) {\n            this._leafletMap = $q.defer();\n            this.getMap = function () {\n                return this._leafletMap.promise;\n            };\n\n            this.getLeafletScope = function () {\n                return $scope;\n            };\n        },\n\n        link: function link(scope, element, attrs, ctrl) {\n            var isDefined = leafletHelpers.isDefined,\n                defaults = leafletMapDefaults.setDefaults(scope.defaults, attrs.id),\n                mapEvents = leafletMapEvents.getAvailableMapEvents(),\n                addEvents = leafletMapEvents.addEvents;\n\n            scope.mapId = attrs.id;\n            leafletData.setDirectiveControls({}, attrs.id);\n\n            // Set width and height utility functions\n            function updateWidth() {\n                if (isNaN(attrs.width)) {\n                    element.css('width', attrs.width);\n                } else {\n                    element.css('width', attrs.width + 'px');\n                }\n            }\n\n            function updateHeight() {\n                if (isNaN(attrs.height)) {\n                    element.css('height', attrs.height);\n                } else {\n                    element.css('height', attrs.height + 'px');\n                }\n            }\n\n            // Create the Leaflet Map Object with the options\n            var map = new L.Map(element[0], leafletMapDefaults.getMapCreationDefaults(attrs.id));\n            ctrl._leafletMap.resolve(map);\n\n            // If the width attribute defined update css\n            // Then watch if bound property changes and update css\n            if (isDefined(attrs.width)) {\n                updateWidth();\n\n                scope.$watch(function () {\n                    return element[0].getAttribute('width');\n                }, function () {\n                    updateWidth();\n                    map.invalidateSize();\n                });\n            }\n\n            // If the height attribute defined update css\n            // Then watch if bound property changes and update css\n            if (isDefined(attrs.height)) {\n                updateHeight();\n\n                scope.$watch(function () {\n                    return element[0].getAttribute('height');\n                }, function () {\n                    updateHeight();\n                    map.invalidateSize();\n                });\n            }\n\n            if (!isDefined(attrs.center) && !isDefined(attrs.lfCenter)) {\n                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n            }\n\n            // If no layers nor tiles defined, set the default tileLayer\n            if (!isDefined(attrs.tiles) && !isDefined(attrs.layers)) {\n                var tileLayerObj = L.tileLayer(defaults.tileLayer, defaults.tileLayerOptions);\n                tileLayerObj.addTo(map);\n                leafletData.setTiles(tileLayerObj, attrs.id);\n            }\n\n            // Set zoom control configuration\n            if (isDefined(map.zoomControl) && isDefined(defaults.zoomControlPosition)) {\n                map.zoomControl.setPosition(defaults.zoomControlPosition);\n            }\n\n            if (isDefined(map.zoomControl) && defaults.zoomControl === false) {\n                map.zoomControl.removeFrom(map);\n            }\n\n            if (isDefined(map.zoomsliderControl) && isDefined(defaults.zoomsliderControl) && defaults.zoomsliderControl === false) {\n                map.zoomsliderControl.removeFrom(map);\n            }\n\n            // if no event-broadcast attribute, all events are broadcasted\n            if (!isDefined(attrs.eventBroadcast)) {\n                var logic = \"broadcast\";\n                addEvents(map, attrs.id, mapEvents, \"eventName\", scope, logic);\n            }\n\n            // Resolve the map object to the promises\n            map.whenReady(function () {\n                leafletData.setMap(map, attrs.id);\n            });\n\n            scope.$on('$destroy', function () {\n                leafletMapDefaults.reset();\n                map.remove();\n                leafletData.unresolveMap(attrs.id);\n            });\n\n            //Handle request to invalidate the map size\n            //Up scope using $scope.$emit('invalidateSize')\n            //Down scope using $scope.$broadcast('invalidateSize')\n            scope.$on('invalidateSize', function () {\n                map.invalidateSize();\n            });\n        }\n    };\n});\n","'use strict';\n\n(function () {\n    angular.module('ui-leaflet').factory('eventManager', [function () {\n        var EventManager = function EventManager() {\n            this.listeners = {};\n        };\n\n        EventManager.prototype = {\n            addEventListener: function addEventListener(type, callback, scope) {\n                var args = [];\n                var numOfArgs = arguments.length;\n                for (var i = 0; i < numOfArgs; i++) {\n                    args.push(arguments[i]);\n                }\n                args = args.length > 3 ? args.splice(3, args.length - 1) : [];\n                if (typeof this.listeners[type] !== \"undefined\") {\n                    this.listeners[type].push({ scope: scope, callback: callback, args: args });\n                } else {\n                    this.listeners[type] = [{ scope: scope, callback: callback, args: args }];\n                }\n            },\n            removeEventListener: function removeEventListener(type, callback, scope) {\n                if (typeof this.listeners[type] !== \"undefined\") {\n                    var numOfCallbacks = this.listeners[type].length;\n                    var newArray = [];\n                    for (var i = 0; i < numOfCallbacks; i++) {\n                        var listener = this.listeners[type][i];\n                        if (listener.scope === scope && listener.callback === callback) {} else {\n                            newArray.push(listener);\n                        }\n                    }\n                    this.listeners[type] = newArray;\n                }\n            },\n            hasEventListener: function hasEventListener(type, callback, scope) {\n                if (typeof this.listeners[type] !== \"undefined\") {\n                    var numOfCallbacks = this.listeners[type].length;\n                    if (callback === undefined && scope === undefined) {\n                        return numOfCallbacks > 0;\n                    }\n                    for (var i = 0; i < numOfCallbacks; i++) {\n                        var listener = this.listeners[type][i];\n                        if ((scope ? listener.scope === scope : true) && listener.callback === callback) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            },\n            dispatch: function dispatch(type, target) {\n                var numOfListeners = 0;\n                var event = {\n                    type: type,\n                    target: target\n                };\n                var args = [];\n                var numOfArgs = arguments.length;\n                for (var i = 0; i < numOfArgs; i++) {\n                    args.push(arguments[i]);\n                }\n                args = args.length > 2 ? args.splice(2, args.length - 1) : [];\n                args = [event].concat(args);\n                if (typeof this.listeners[type] !== \"undefined\") {\n                    var numOfCallbacks = this.listeners[type].length;\n                    for (var x = 0; x < numOfCallbacks; x++) {\n                        var listener = this.listeners[type][x];\n                        if (listener && listener.callback) {\n                            var concatArgs = args.concat(listener.args);\n                            listener.callback.apply(listener.scope, concatArgs);\n                            numOfListeners += 1;\n                        }\n                    }\n                }\n            },\n            getEvents: function getEvents() {\n                var str = \"\";\n                for (var type in this.listeners) {\n                    var numOfCallbacks = this.listeners[type].length;\n                    for (var i = 0; i < numOfCallbacks; i++) {\n                        var listener = this.listeners[type][i];\n                        str += listener.scope && listener.scope.className ? listener.scope.className : \"anonymous\";\n                        str += \" listen for '\" + type + \"'\\n\";\n                    }\n                }\n                return str;\n            }\n        };\n        return EventManager;\n    }]).service('eventManager', function (EventManager) {\n        return new EventManager();\n    });\n})();\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletBoundsHelpers', function (leafletLogger, leafletHelpers) {\n\n    var isArray = leafletHelpers.isArray,\n        isNumber = leafletHelpers.isNumber,\n        isFunction = leafletHelpers.isFunction,\n        isDefined = leafletHelpers.isDefined,\n        $log = leafletLogger;\n\n    function _isValidBounds(bounds) {\n        return angular.isDefined(bounds) && angular.isDefined(bounds.southWest) && angular.isDefined(bounds.northEast) && angular.isNumber(bounds.southWest.lat) && angular.isNumber(bounds.southWest.lng) && angular.isNumber(bounds.northEast.lat) && angular.isNumber(bounds.northEast.lng);\n    }\n\n    return {\n        createLeafletBounds: function createLeafletBounds(bounds) {\n            if (_isValidBounds(bounds)) {\n                return L.latLngBounds([bounds.southWest.lat, bounds.southWest.lng], [bounds.northEast.lat, bounds.northEast.lng]);\n            }\n        },\n\n        isValidBounds: _isValidBounds,\n\n        createBoundsFromArray: function createBoundsFromArray(boundsArray) {\n            if (!(isArray(boundsArray) && boundsArray.length === 2 && isArray(boundsArray[0]) && isArray(boundsArray[1]) && boundsArray[0].length === 2 && boundsArray[1].length === 2 && isNumber(boundsArray[0][0]) && isNumber(boundsArray[0][1]) && isNumber(boundsArray[1][0]) && isNumber(boundsArray[1][1]))) {\n                $log.error(\"[AngularJS - Leaflet] The bounds array is not valid.\");\n                return;\n            }\n\n            return {\n                northEast: {\n                    lat: boundsArray[0][0],\n                    lng: boundsArray[0][1]\n                },\n                southWest: {\n                    lat: boundsArray[1][0],\n                    lng: boundsArray[1][1]\n                }\n            };\n        },\n\n        createBoundsFromLeaflet: function createBoundsFromLeaflet(lfBounds) {\n            if (!(isDefined(lfBounds) && isFunction(lfBounds.getNorthEast) && isFunction(lfBounds.getSouthWest))) {\n                $log.error(\"[AngularJS - Leaflet] The leaflet bounds is not valid object.\");\n                return;\n            }\n\n            var northEast = lfBounds.getNorthEast(),\n                southWest = lfBounds.getSouthWest();\n\n            return {\n                northEast: {\n                    lat: northEast.lat,\n                    lng: northEast.lng\n                },\n                southWest: {\n                    lat: southWest.lat,\n                    lng: southWest.lng\n                }\n            };\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletControlHelpers', function ($rootScope, leafletLogger, leafletHelpers, leafletLayerHelpers, leafletMapDefaults) {\n    var isDefined = leafletHelpers.isDefined,\n        isObject = leafletHelpers.isObject,\n        createLayer = leafletLayerHelpers.createLayer,\n        _controls = {},\n        errorHeader = leafletHelpers.errorHeader + ' [Controls] ',\n        $log = leafletLogger;\n\n    var _controlLayersMustBeVisible = function _controlLayersMustBeVisible(baselayers, overlays, mapId) {\n        var defaults = leafletMapDefaults.getDefaults(mapId);\n        if (!defaults.controls.layers.visible) {\n            return false;\n        }\n\n        var atLeastOneControlItemMustBeShown = false;\n\n        if (isObject(baselayers)) {\n            Object.keys(baselayers).forEach(function (key) {\n                var layer = baselayers[key];\n                if (!isDefined(layer.layerOptions) || layer.layerOptions.showOnSelector !== false) {\n                    atLeastOneControlItemMustBeShown = true;\n                }\n            });\n        }\n\n        if (isObject(overlays)) {\n            Object.keys(overlays).forEach(function (key) {\n                var layer = overlays[key];\n                if (!isDefined(layer.layerParams) || layer.layerParams.showOnSelector !== false) {\n                    atLeastOneControlItemMustBeShown = true;\n                }\n            });\n        }\n\n        return atLeastOneControlItemMustBeShown;\n    };\n\n    var _createLayersControl = function _createLayersControl(mapId) {\n        var defaults = leafletMapDefaults.getDefaults(mapId);\n        var controlOptions = {\n            collapsed: defaults.controls.layers.collapsed,\n            position: defaults.controls.layers.position,\n            autoZIndex: false\n        };\n\n        angular.extend(controlOptions, defaults.controls.layers.options);\n\n        var control;\n        if (defaults.controls.layers && isDefined(defaults.controls.layers.control)) {\n            control = defaults.controls.layers.control.apply(this, [[], [], controlOptions]);\n        } else {\n            control = new L.control.layers([], [], controlOptions);\n        }\n\n        return control;\n    };\n\n    var controlTypes = {\n        draw: {\n            isPluginLoaded: function isPluginLoaded() {\n                if (!angular.isDefined(L.Control.Draw)) {\n                    $log.error(errorHeader + ' Draw plugin is not loaded.');\n                    return false;\n                }\n                return true;\n            },\n            checkValidParams: function checkValidParams() /* params */{\n                return true;\n            },\n            createControl: function createControl(params) {\n                return new L.Control.Draw(params);\n            }\n        },\n        scale: {\n            isPluginLoaded: function isPluginLoaded() {\n                return true;\n            },\n            checkValidParams: function checkValidParams() /* params */{\n                return true;\n            },\n            createControl: function createControl(params) {\n                return new L.control.scale(params);\n            }\n        },\n        fullscreen: {\n            isPluginLoaded: function isPluginLoaded() {\n                if (!angular.isDefined(L.Control.Fullscreen)) {\n                    $log.error(errorHeader + ' Fullscreen plugin is not loaded.');\n                    return false;\n                }\n                return true;\n            },\n            checkValidParams: function checkValidParams() /* params */{\n                return true;\n            },\n            createControl: function createControl(params) {\n                return new L.Control.Fullscreen(params);\n            }\n        },\n        search: {\n            isPluginLoaded: function isPluginLoaded() {\n                if (!angular.isDefined(L.Control.Search)) {\n                    $log.error(errorHeader + ' Search plugin is not loaded.');\n                    return false;\n                }\n                return true;\n            },\n            checkValidParams: function checkValidParams() /* params */{\n                return true;\n            },\n            createControl: function createControl(params) {\n                return new L.Control.Search(params);\n            }\n        },\n        custom: {},\n        minimap: {\n            isPluginLoaded: function isPluginLoaded() {\n                if (!angular.isDefined(L.Control.MiniMap)) {\n                    $log.error(errorHeader + ' Minimap plugin is not loaded.');\n                    return false;\n                }\n\n                return true;\n            },\n            checkValidParams: function checkValidParams(params) {\n                if (!isDefined(params.layer)) {\n                    $log.warn(errorHeader + ' minimap \"layer\" option should be defined.');\n                    return false;\n                }\n                return true;\n            },\n            createControl: function createControl(params) {\n                var layer = createLayer(params.layer);\n\n                if (!isDefined(layer)) {\n                    $log.warn(errorHeader + ' minimap control \"layer\" could not be created.');\n                    return;\n                }\n\n                return new L.Control.MiniMap(layer, params);\n            }\n        }\n    };\n\n    return {\n        layersControlMustBeVisible: _controlLayersMustBeVisible,\n\n        isValidControlType: function isValidControlType(type) {\n            return Object.keys(controlTypes).indexOf(type) !== -1;\n        },\n\n        createControl: function createControl(type, params) {\n            if (!controlTypes[type].checkValidParams(params)) {\n                return;\n            }\n\n            return controlTypes[type].createControl(params);\n        },\n\n        updateLayersControl: function updateLayersControl(map, mapId, loaded, baselayers, overlays, leafletLayers) {\n            var i;\n            var _layersControl = _controls[mapId];\n            var mustBeLoaded = _controlLayersMustBeVisible(baselayers, overlays, mapId);\n\n            if (isDefined(_layersControl) && loaded) {\n                for (i in leafletLayers.baselayers) {\n                    _layersControl.removeLayer(leafletLayers.baselayers[i]);\n                }\n                for (i in leafletLayers.overlays) {\n                    _layersControl.removeLayer(leafletLayers.overlays[i]);\n                }\n                map.removeControl(_layersControl);\n                delete _controls[mapId];\n            }\n\n            if (mustBeLoaded) {\n                _layersControl = _createLayersControl(mapId);\n                _controls[mapId] = _layersControl;\n                for (i in baselayers) {\n                    var hideOnSelector = isDefined(baselayers[i].layerOptions) && baselayers[i].layerOptions.showOnSelector === false;\n                    if (!hideOnSelector && isDefined(leafletLayers.baselayers[i])) {\n                        _layersControl.addBaseLayer(leafletLayers.baselayers[i], baselayers[i].name);\n                    }\n                }\n                for (i in overlays) {\n                    var hideOverlayOnSelector = isDefined(overlays[i].layerParams) && overlays[i].layerParams.showOnSelector === false;\n                    if (!hideOverlayOnSelector && isDefined(leafletLayers.overlays[i])) {\n                        _layersControl.addOverlay(leafletLayers.overlays[i], overlays[i].name);\n                    }\n                }\n\n                map.addControl(_layersControl);\n            }\n            return mustBeLoaded;\n        },\n\n        destroyMapLayersControl: function destroyMapLayersControl(mapId) {\n            delete _controls[mapId];\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletData', function (leafletLogger, $q, leafletHelpers) {\n    var getDefer = leafletHelpers.getDefer,\n        getUnresolvedDefer = leafletHelpers.getUnresolvedDefer,\n        setResolvedDefer = leafletHelpers.setResolvedDefer;\n    // $log = leafletLogger;\n\n    var _private = {};\n    var self = this;\n\n    var upperFirst = function upperFirst(string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    };\n\n    var _privateItems = ['map', 'tiles', 'layers', 'paths', 'markers', 'geoJSON', 'UTFGrid', //odd ball on naming convention keeping to not break\n    'decorations', 'directiveControls'];\n\n    //init\n    _privateItems.forEach(function (itemName) {\n        _private[itemName] = {};\n    });\n\n    this.unresolveMap = function (scopeId) {\n        var id = leafletHelpers.obtainEffectiveMapId(_private.map, scopeId);\n        _privateItems.forEach(function (itemName) {\n            _private[itemName][id] = undefined;\n        });\n    };\n\n    //int repetitive stuff (get and sets)\n    _privateItems.forEach(function (itemName) {\n        var name = upperFirst(itemName);\n        self['set' + name] = function (lObject, scopeId) {\n            var defer = getUnresolvedDefer(_private[itemName], scopeId);\n            defer.resolve(lObject);\n            setResolvedDefer(_private[itemName], scopeId);\n        };\n\n        self['get' + name] = function (scopeId) {\n            var defer = getDefer(_private[itemName], scopeId);\n            return defer.promise;\n        };\n    });\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletDirectiveControlsHelpers', function (leafletLogger, leafletData, leafletHelpers) {\n    var _isDefined = leafletHelpers.isDefined,\n        _isString = leafletHelpers.isString,\n        _isObject = leafletHelpers.isObject,\n        _mainErrorHeader = leafletHelpers.errorHeader,\n        $log = leafletLogger;\n\n    var _errorHeader = _mainErrorHeader + '[leafletDirectiveControlsHelpers';\n\n    var _extend = function _extend(id, thingToAddName, createFn, cleanFn) {\n        var _fnHeader = _errorHeader + '.extend] ';\n        var extender = {};\n        if (!_isDefined(thingToAddName)) {\n            $log.error(_fnHeader + 'thingToAddName cannot be undefined');\n            return;\n        }\n\n        if (_isString(thingToAddName) && _isDefined(createFn) && _isDefined(cleanFn)) {\n            extender[thingToAddName] = {\n                create: createFn,\n                clean: cleanFn\n            };\n        } else if (_isObject(thingToAddName) && !_isDefined(createFn) && !_isDefined(cleanFn)) {\n            extender = thingToAddName;\n        } else {\n            $log.error(_fnHeader + 'incorrect arguments');\n            return;\n        }\n\n        //add external control to create / destroy markers without a watch\n        leafletData.getDirectiveControls().then(function (controls) {\n            angular.extend(controls, extender);\n            leafletData.setDirectiveControls(controls, id);\n        });\n    };\n\n    return {\n        extend: _extend\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletGeoJsonHelpers', function (leafletHelpers, leafletIterators) {\n    var lHlp = leafletHelpers,\n        lIt = leafletIterators;\n    var Point = function Point(lat, lng) {\n        this.lat = lat;\n        this.lng = lng;\n        return this;\n    };\n\n    var _getLat = function _getLat(value) {\n        if (Array.isArray(value) && value.length === 2) {\n            return value[1];\n        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {\n            return +value.coordinates[1];\n        } else {\n            return +value.lat;\n        }\n    };\n\n    var _getLng = function _getLng(value) {\n        if (Array.isArray(value) && value.length === 2) {\n            return value[0];\n        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {\n            return +value.coordinates[0];\n        } else {\n            return +value.lng;\n        }\n    };\n\n    var _validateCoords = function _validateCoords(coords) {\n        if (lHlp.isUndefined(coords)) {\n            return false;\n        }\n        if (lHlp.isArray(coords)) {\n            if (coords.length === 2 && lHlp.isNumber(coords[0]) && lHlp.isNumber(coords[1])) {\n                return true;\n            }\n        } else if (lHlp.isDefined(coords.type)) {\n            if (coords.type === 'Point' && lHlp.isArray(coords.coordinates) && coords.coordinates.length === 2 && lHlp.isNumber(coords.coordinates[0]) && lHlp.isNumber(coords.coordinates[1])) {\n                return true;\n            }\n        }\n\n        var ret = lIt.all(['lat', 'lng'], function (pos) {\n            return lHlp.isDefined(coords[pos]) && lHlp.isNumber(coords[pos]);\n        });\n        return ret;\n    };\n\n    var _getCoords = function _getCoords(value) {\n        if (!value || !_validateCoords(value)) {\n            return;\n        }\n        var p = null;\n        if (Array.isArray(value) && value.length === 2) {\n            p = new Point(value[1], value[0]);\n        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {\n            p = new Point(value.coordinates[1], value.coordinates[0]);\n        } else {\n            return value;\n        }\n        //note angular.merge is avail in angular 1.4.X we might want to fill it here\n        return angular.extend(value, p); //tap on lat, lng if it doesnt exist\n    };\n\n    return {\n        getLat: _getLat,\n        getLng: _getLng,\n        validateCoords: _validateCoords,\n        getCoords: _getCoords\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletHelpers', function ($q, $log, $timeout) {\n    var _errorHeader = '[ui-leaflet] ';\n    var _copy = angular.copy;\n    var _clone = _copy;\n    /*\n    For parsing paths to a field in an object\n     Example:\n    var obj = {\n        bike:{\n         1: 'hi'\n         2: 'foo'\n        }\n    };\n    _getObjectValue(obj,\"bike.1\") returns 'hi'\n    this is getPath in ui-gmap\n     */\n    var _getObjectValue = function _getObjectValue(object, pathStr) {\n        var obj;\n        if (!object || !angular.isObject(object)) return;\n        //if the key is not a sting then we already have the value\n        if (pathStr === null || !angular.isString(pathStr)) {\n            return pathStr;\n        }\n        obj = object;\n        pathStr.split('.').forEach(function (value) {\n            if (obj) {\n                obj = obj[value];\n            }\n        });\n        return obj;\n    };\n\n    /*\n     Object Array Notation\n     _getObjectArrayPath(\"bike.one.two\")\n     returns:\n     'bike[\"one\"][\"two\"]'\n     */\n    var _getObjectArrayPath = function _getObjectArrayPath(pathStr) {\n        return pathStr.split('.').reduce(function (previous, current) {\n            return previous + '[\"' + current + '\"]';\n        });\n    };\n\n    /* Object Dot Notation\n     _getObjectPath([\"bike\",\"one\",\"two\"])\n     returns:\n     \"bike.one.two\"\n     */\n    var _getObjectDotPath = function _getObjectDotPath(arrayOfStrings) {\n        return arrayOfStrings.reduce(function (previous, current) {\n            return previous + '.' + current;\n        });\n    };\n\n    function _obtainEffectiveMapId(d, mapId) {\n        var id, i;\n        if (!angular.isDefined(mapId)) {\n            if (Object.keys(d).length === 0) {\n                id = \"main\";\n            } else if (Object.keys(d).length >= 1) {\n                for (i in d) {\n                    if (d.hasOwnProperty(i)) {\n                        id = i;\n                    }\n                }\n            } else {\n                $log.error(_errorHeader + \"- You have more than 1 map on the DOM, you must provide the map ID to the leafletData.getXXX call\");\n            }\n        } else {\n            id = mapId;\n        }\n\n        return id;\n    }\n\n    function _getUnresolvedDefer(d, mapId) {\n        var id = _obtainEffectiveMapId(d, mapId),\n            defer;\n\n        if (!angular.isDefined(d[id]) || d[id].resolvedDefer === true) {\n            defer = $q.defer();\n            d[id] = {\n                defer: defer,\n                resolvedDefer: false\n            };\n        } else {\n            defer = d[id].defer;\n        }\n\n        return defer;\n    }\n\n    var _isDefined = function _isDefined(value) {\n        return angular.isDefined(value) && value !== null;\n    };\n    var _isUndefined = function _isUndefined(value) {\n        return !_isDefined(value);\n    };\n\n    // BEGIN DIRECT PORT FROM AngularJS code base\n\n    var SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\n\n    var MOZ_HACK_REGEXP = /^moz([A-Z])/;\n\n    var PREFIX_REGEXP = /^((?:x|data)[\\:\\-_])/i;\n\n    /**\n    Converts snake_case to camelCase.\n    Also there is special case for Moz prefix starting with upper case letter.\n    @param name Name to normalize\n     */\n\n    var camelCase = function camelCase(name) {\n        return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {\n            if (offset) {\n                return letter.toUpperCase();\n            } else {\n                return letter;\n            }\n        }).replace(MOZ_HACK_REGEXP, \"Moz$1\");\n    };\n\n    /**\n        Converts all accepted directives format into proper directive name.\n        @param name Name to normalize\n    */\n\n    var directiveNormalize = function directiveNormalize(name) {\n        return camelCase(name.replace(PREFIX_REGEXP, \"\"));\n    };\n    // END AngularJS port\n\n    var _watchTrapDelayMilliSec = 10;\n\n    var _modelChangeInDirective = function _modelChangeInDirective(trapObj, trapField, cbToExec) {\n        if (!trapObj) throw new Error(_errorHeader + 'trapObj is undefined');\n        if (!trapField) throw new Error(_errorHeader + 'trapField is undefined');\n\n        trapObj[trapField] = true;\n        var ret = cbToExec();\n        $timeout(function () {\n            trapObj[trapField] = false;\n        }, _watchTrapDelayMilliSec);\n        return ret;\n    };\n\n    return {\n        watchTrapDelayMilliSec: _watchTrapDelayMilliSec,\n        modelChangeInDirective: _modelChangeInDirective,\n        camelCase: camelCase,\n        directiveNormalize: directiveNormalize,\n        copy: _copy,\n        clone: _clone,\n        errorHeader: _errorHeader,\n        getObjectValue: _getObjectValue,\n        getObjectArrayPath: _getObjectArrayPath,\n        getObjectDotPath: _getObjectDotPath,\n        defaultTo: function defaultTo(val, _default) {\n            return _isDefined(val) ? val : _default;\n        },\n        //mainly for checking attributes of directives lets keep this minimal (on what we accept)\n        isTruthy: function isTruthy(val) {\n            return val === 'true' || val === true;\n        },\n        //Determine if a reference is {}\n        isEmpty: function isEmpty(value) {\n            return Object.keys(value).length === 0;\n        },\n\n        //Determine if a reference is undefined or {}\n        isUndefinedOrEmpty: function isUndefinedOrEmpty(value) {\n            return angular.isUndefined(value) || value === null || Object.keys(value).length === 0;\n        },\n\n        // Determine if a reference is defined\n        isDefined: _isDefined,\n        isUndefined: _isUndefined,\n        isNumber: angular.isNumber,\n        isString: angular.isString,\n        isArray: angular.isArray,\n        isObject: angular.isObject,\n        isFunction: angular.isFunction,\n        equals: angular.equals,\n\n        isValidCenter: function isValidCenter(center) {\n            return angular.isDefined(center) && angular.isNumber(center.lat) && angular.isNumber(center.lng) && angular.isNumber(center.zoom);\n        },\n\n        isValidPoint: function isValidPoint(point) {\n            if (!angular.isDefined(point)) {\n                return false;\n            }\n            if (angular.isArray(point)) {\n                return point.length === 2 && angular.isNumber(point[0]) && angular.isNumber(point[1]);\n            }\n            return angular.isNumber(point.lat) && angular.isNumber(point.lng);\n        },\n\n        isSameCenterOnMap: function isSameCenterOnMap(centerModel, map) {\n            var mapCenter = map.getCenter();\n            var zoom = map.getZoom();\n            if (centerModel.lat && centerModel.lng && mapCenter.lat.toFixed(4) === centerModel.lat.toFixed(4) && mapCenter.lng.toFixed(4) === centerModel.lng.toFixed(4) && zoom === centerModel.zoom) {\n                return true;\n            }\n            return false;\n        },\n\n        safeApply: function safeApply($scope, fn) {\n            var phase = $scope.$root.$$phase;\n            if (phase === '$apply' || phase === '$digest') {\n                $scope.$eval(fn);\n            } else {\n                $scope.$evalAsync(fn);\n            }\n        },\n\n        obtainEffectiveMapId: _obtainEffectiveMapId,\n\n        getDefer: function getDefer(d, mapId) {\n            var id = _obtainEffectiveMapId(d, mapId),\n                defer;\n            if (!angular.isDefined(d[id]) || d[id].resolvedDefer === false) {\n                defer = _getUnresolvedDefer(d, mapId);\n            } else {\n                defer = d[id].defer;\n            }\n            return defer;\n        },\n\n        getUnresolvedDefer: _getUnresolvedDefer,\n\n        setResolvedDefer: function setResolvedDefer(d, mapId) {\n            var id = _obtainEffectiveMapId(d, mapId);\n            d[id].resolvedDefer = true;\n        },\n\n        rangeIsSupported: function rangeIsSupported() {\n            var testrange = document.createElement('input');\n            testrange.setAttribute('type', 'range');\n            return testrange.type === 'range';\n        },\n\n        FullScreenControlPlugin: {\n            isLoaded: function isLoaded() {\n                return angular.isDefined(L.Control.Fullscreen);\n            }\n        },\n\n        MiniMapControlPlugin: {\n            isLoaded: function isLoaded() {\n                return angular.isDefined(L.Control.MiniMap);\n            }\n        },\n\n        AwesomeMarkersPlugin: {\n            isLoaded: function isLoaded() {\n                return angular.isDefined(L.AwesomeMarkers) && angular.isDefined(L.AwesomeMarkers.Icon);\n            },\n            is: function is(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.AwesomeMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function equal(iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        VectorMarkersPlugin: {\n            isLoaded: function isLoaded() {\n                return angular.isDefined(L.VectorMarkers) && angular.isDefined(L.VectorMarkers.Icon);\n            },\n            is: function is(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.VectorMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function equal(iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        DomMarkersPlugin: {\n            isLoaded: function isLoaded() {\n                if (angular.isDefined(L.DomMarkers) && angular.isDefined(L.DomMarkers.Icon)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function is(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.DomMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function equal(iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        PolylineDecoratorPlugin: {\n            isLoaded: function isLoaded() {\n                if (angular.isDefined(L.PolylineDecorator)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function is(decoration) {\n                if (this.isLoaded()) {\n                    return decoration instanceof L.PolylineDecorator;\n                } else {\n                    return false;\n                }\n            },\n            equal: function equal(decorationA, decorationB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(decorationA)) {\n                    return angular.equals(decorationA, decorationB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        MakiMarkersPlugin: {\n            isLoaded: function isLoaded() {\n                if (angular.isDefined(L.MakiMarkers) && angular.isDefined(L.MakiMarkers.Icon)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function is(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.MakiMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function equal(iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n        ExtraMarkersPlugin: {\n            isLoaded: function isLoaded() {\n                if (angular.isDefined(L.ExtraMarkers) && angular.isDefined(L.ExtraMarkers.Icon)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function is(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.ExtraMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function equal(iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n        LabelPlugin: {\n            isLoaded: function isLoaded() {\n                return angular.isDefined(L.Label);\n            },\n            is: function is(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.MarkerClusterGroup;\n                } else {\n                    return false;\n                }\n            }\n        },\n        MarkerClusterPlugin: {\n            isLoaded: function isLoaded() {\n                return angular.isDefined(L.MarkerClusterGroup);\n            },\n            is: function is(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.MarkerClusterGroup;\n                } else {\n                    return false;\n                }\n            }\n        },\n        GeoJSONPlugin: {\n            isLoaded: function isLoaded() {\n                return angular.isDefined(L.TileLayer.GeoJSON);\n            },\n            is: function is(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.TileLayer.GeoJSON;\n                } else {\n                    return false;\n                }\n            }\n        },\n        CartoDB: {\n            isLoaded: function isLoaded() {\n                return cartodb;\n            },\n            is: function is() /*layer*/{\n                return true;\n                /*\n                if (this.isLoaded()) {\n                    return layer instanceof L.TileLayer.GeoJSON;\n                } else {\n                    return false;\n                }*/\n            }\n        },\n        Leaflet: {\n            DivIcon: {\n                is: function is(icon) {\n                    return icon instanceof L.DivIcon;\n                },\n                equal: function equal(iconA, iconB) {\n                    if (this.is(iconA)) {\n                        return angular.equals(iconA, iconB);\n                    } else {\n                        return false;\n                    }\n                }\n            },\n            Icon: {\n                is: function is(icon) {\n                    return icon instanceof L.Icon;\n                },\n                equal: function equal(iconA, iconB) {\n                    if (this.is(iconA)) {\n                        return angular.equals(iconA, iconB);\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        /*\n         watchOptions - object to set deep nested watches and turn off watches all together\n         (rely on control / functional updates)\n         watchOptions - Object\n             type: string. //One of ['watch', 'watchCollection', 'watchDeep', null]\n             individual\n                 type: string\n         */\n        //legacy defaults\n        watchOptions: {\n            type: 'watchDeep',\n            individual: {\n                type: 'watchDeep'\n            }\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletIterators', function (leafletLogger, leafletHelpers) {\n\n  var lHlp = leafletHelpers,\n      errorHeader = leafletHelpers.errorHeader + 'leafletIterators: ';\n\n  //BEGIN COPY from underscore\n  var _keys = Object.keys;\n  var _isFunction = lHlp.isFunction;\n  var _isObject = lHlp.isObject;\n  var $log = leafletLogger;\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n  var _isArrayLike = function _isArrayLike(collection) {\n    var length = collection !== null && collection.length;\n    return lHlp.isNumber(length) && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Keep the identity function around for default iteratees.\n  var _identity = function _identity(value) {\n    return value;\n  };\n\n  var _property = function _property(key) {\n    return function (obj) {\n      return obj === null ? void 0 : obj[key];\n    };\n  };\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function optimizeCb(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount === null ? 3 : argCount) {\n      case 1:\n        return function (value) {\n          return func.call(context, value);\n        };\n      case 2:\n        return function (value, other) {\n          return func.call(context, value, other);\n        };\n      case 3:\n        return function (value, index, collection) {\n          return func.call(context, value, index, collection);\n        };\n      case 4:\n        return function (accumulator, value, index, collection) {\n          return func.call(context, accumulator, value, index, collection);\n        };\n    }\n    return function () {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function createAssigner(keysFunc, undefinedOnly) {\n    return function (obj) {\n      var length = arguments.length;\n      if (length < 2 || obj === null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  var _extendOwn,\n      _assign = null;\n  _extendOwn = _assign = createAssigner(_keys);\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  var _isMatch = function _isMatch(object, attrs) {\n    var keys = _keys(attrs),\n        length = keys.length;\n    if (object === null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  var _matcher,\n      _matches = null;\n  _matcher = _matches = function _matches(attrs) {\n    attrs = _extendOwn({}, attrs);\n    return function (obj) {\n      return _isMatch(obj, attrs);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result  either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function cb(value, context, argCount) {\n    if (value === null) return _identity;\n    if (_isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_isObject(value)) return _matcher(value);\n    return _property(value);\n  };\n\n  var _every,\n      _all = null;\n  _every = _all = function _all(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !_isArrayLike(obj) && _keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  //END COPY fron underscore\n\n  var _hasErrors = function _hasErrors(collection, cb, ignoreCollection, cbName) {\n    if (!ignoreCollection) {\n      if (!lHlp.isDefined(collection) || !lHlp.isDefined(cb)) {\n        return true;\n      }\n    }\n    if (!lHlp.isFunction(cb)) {\n      cbName = lHlp.defaultTo(cb, 'cb');\n      $log.error(errorHeader + cbName + ' is not a function');\n      return true;\n    }\n    return false;\n  };\n\n  var _iterate = function _iterate(collection, externalCb, internalCb) {\n    if (_hasErrors(undefined, internalCb, true, 'internalCb')) {\n      return;\n    }\n    if (!_hasErrors(collection, externalCb)) {\n      for (var key in collection) {\n        if (collection.hasOwnProperty(key)) {\n          internalCb(collection[key], key);\n        }\n      }\n    }\n  };\n\n  //see http://jsperf.com/iterators/3\n  //utilizing for in is way faster\n  var _each = function _each(collection, cb) {\n    _iterate(collection, cb, function (val, key) {\n      cb(val, key);\n    });\n  };\n\n  return {\n    each: _each,\n    forEach: _each,\n    every: _every,\n    all: _all\n  };\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletLayerHelpers', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletIterators) {\n    var Helpers = leafletHelpers;\n    var isString = leafletHelpers.isString;\n    var isObject = leafletHelpers.isObject;\n    var isArray = leafletHelpers.isArray;\n    var isDefined = leafletHelpers.isDefined;\n    var errorHeader = leafletHelpers.errorHeader;\n    var $it = leafletIterators;\n    var $log = leafletLogger;\n\n    var utfGridCreateLayer = function utfGridCreateLayer(params) {\n        if (!Helpers.UTFGridPlugin.isLoaded()) {\n            $log.error('[AngularJS - Leaflet] The UTFGrid plugin is not loaded.');\n            return;\n        }\n        var utfgrid = new L.UtfGrid(params.url, params.pluginOptions);\n\n        var toSend = {\n            model: params.$parent\n        };\n\n        // TODO Use event manager\n        utfgrid.on('mouseover', function (e) {\n            angular.extend(toSend, {\n                leafletEvent: e,\n                leafletObject: e.target\n            });\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseover', toSend);\n        });\n\n        utfgrid.on('mouseout', function (e) {\n            angular.extend(toSend, {\n                leafletEvent: e,\n                leafletObject: e.target\n            });\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseout', toSend);\n        });\n\n        utfgrid.on('click', function (e) {\n            angular.extend(toSend, {\n                leafletEvent: e,\n                leafletObject: e.target\n            });\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridClick', toSend);\n        });\n\n        utfgrid.on('mousemove', function (e) {\n            angular.extend(toSend, {\n                leafletEvent: e,\n                leafletObject: e.target\n            });\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridMousemove', toSend);\n        });\n\n        return utfgrid;\n    };\n\n    var layerTypes = {\n        xyz: {\n            mustHaveUrl: true,\n            createLayer: function createLayer(params) {\n                return L.tileLayer(params.url, params.options);\n            }\n        },\n        geoJSON: {\n            mustHaveUrl: true,\n            createLayer: function createLayer(params) {\n                if (!Helpers.GeoJSONPlugin.isLoaded()) {\n                    return;\n                }\n                return new L.TileLayer.GeoJSON(params.url, params.pluginOptions, params.options);\n            }\n        },\n        geoJSONShape: {\n            mustHaveUrl: false,\n            createLayer: function createLayer(params) {\n                return new L.GeoJSON(params.data, params.options);\n            }\n        },\n        geoJSONAwesomeMarker: {\n            mustHaveUrl: false,\n            createLayer: function createLayer(params) {\n                return new L.geoJson(params.data, {\n                    pointToLayer: function pointToLayer(feature, latlng) {\n                        return L.marker(latlng, { icon: L.AwesomeMarkers.icon(params.icon) });\n                    }\n                });\n            }\n        },\n        geoJSONVectorMarker: {\n            mustHaveUrl: false,\n            createLayer: function createLayer(params) {\n                return new L.geoJson(params.data, {\n                    pointToLayer: function pointToLayer(feature, latlng) {\n                        return L.marker(latlng, { icon: L.VectorMarkers.icon(params.icon) });\n                    }\n                });\n            }\n        },\n        cartodbTiles: {\n            mustHaveKey: true,\n            createLayer: function createLayer(params) {\n                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';\n                url += '/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';\n                return L.tileLayer(url, params.options);\n            }\n        },\n        cartodbUTFGrid: {\n            mustHaveKey: true,\n            mustHaveLayer: true,\n            createLayer: function createLayer(params) {\n                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';\n                params.url = url + '/api/v1/map/' + params.key + '/' + params.layer + '/{z}/{x}/{y}.grid.json';\n                return utfGridCreateLayer(params);\n            }\n        },\n        cartodbInteractive: {\n            mustHaveKey: true,\n            mustHaveLayer: true,\n            createLayer: function createLayer(params) {\n                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';\n                var tilesURL = url + '/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';\n                var tileLayer = L.tileLayer(tilesURL, params.options);\n                var layers = [tileLayer];\n\n                var addUtfLayer = function addUtfLayer(parent, params, layer) {\n                    var paramsCopy = angular.copy(params);\n                    paramsCopy.url = url + '/api/v1/map/' + paramsCopy.key + '/' + layer + '/{z}/{x}/{y}.grid.json';\n                    parent.push(utfGridCreateLayer(paramsCopy));\n                };\n\n                if (isArray(params.layer)) {\n                    for (var i = 0; i < params.layer.length; i++) {\n                        addUtfLayer(layers, params, params.layer[i]);\n                    }\n                } else {\n                    addUtfLayer(layers, params, params.layer);\n                }\n                return L.layerGroup(layers);\n            }\n        },\n        wms: {\n            mustHaveUrl: true,\n            createLayer: function createLayer(params) {\n                return L.tileLayer.wms(params.url, params.options);\n            }\n        },\n        wmts: {\n            mustHaveUrl: true,\n            createLayer: function createLayer(params) {\n                return L.tileLayer.wmts(params.url, params.options);\n            }\n        },\n        group: {\n            mustHaveUrl: false,\n            createLayer: function createLayer(params) {\n                var lyrs = [];\n                $it.each(params.options.layers, function (l) {\n                    lyrs.push(_createLayer(l));\n                });\n                params.options.loadedDefer = function () {\n                    var defers = [];\n                    if (isDefined(params.options.layers)) {\n                        for (var i = 0; i < params.options.layers.length; i++) {\n                            var d = params.options.layers[i].layerOptions.loadedDefer;\n                            if (isDefined(d)) {\n                                defers.push(d);\n                            }\n                        }\n                    }\n                    return defers;\n                };\n                return L.layerGroup(lyrs);\n            }\n        },\n        featureGroup: {\n            mustHaveUrl: false,\n            createLayer: function createLayer() {\n                return L.featureGroup();\n            }\n        },\n        markercluster: {\n            mustHaveUrl: false,\n            createLayer: function createLayer(params) {\n                if (!Helpers.MarkerClusterPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The markercluster plugin is not loaded.');\n                    return;\n                }\n                return new L.MarkerClusterGroup(params.options);\n            }\n        },\n        imageOverlay: {\n            mustHaveUrl: true,\n            mustHaveBounds: true,\n            createLayer: function createLayer(params) {\n                return L.imageOverlay(params.url, params.bounds, params.options);\n            }\n        },\n        iip: {\n            mustHaveUrl: true,\n            createLayer: function createLayer(params) {\n                return L.tileLayer.iip(params.url, params.options);\n            }\n        },\n\n        // This \"custom\" type is used to accept every layer that user want to define himself.\n        // We can wrap these custom layers like heatmap or yandex, but it means a lot of work/code to wrap the world,\n        // so we let user to define their own layer outside the directive,\n        // and pass it on \"createLayer\" result for next processes\n        custom: {\n            createLayer: function createLayer(params) {\n                if (params.layer instanceof L.Class) {\n                    return angular.copy(params.layer);\n                } else {\n                    $log.error('[AngularJS - Leaflet] A custom layer must be a leaflet Class');\n                }\n            }\n        },\n        cartodb: {\n            mustHaveUrl: true,\n            createLayer: function createLayer(params) {\n                return cartodb.createLayer(params.map, params.url);\n            }\n        }\n    };\n\n    function isValidLayerType(layerDefinition) {\n        // Check if the baselayer has a valid type\n        if (!isString(layerDefinition.type)) {\n            $log.error('[AngularJS - Leaflet] A layer must have a valid type defined.');\n            return false;\n        }\n\n        if (Object.keys(layerTypes).indexOf(layerDefinition.type) === -1) {\n            $log.error('[AngularJS - Leaflet] A layer must have a valid type: ' + Object.keys(layerTypes));\n            return false;\n        }\n\n        // Check if the layer must have an URL\n        if (layerTypes[layerDefinition.type].mustHaveUrl && !isString(layerDefinition.url)) {\n            $log.error('[AngularJS - Leaflet] A base layer must have an url');\n            return false;\n        }\n\n        if (layerTypes[layerDefinition.type].mustHaveData && !isDefined(layerDefinition.data)) {\n            $log.error('[AngularJS - Leaflet] The base layer must have a \"data\" array attribute');\n            return false;\n        }\n\n        if (layerTypes[layerDefinition.type].mustHaveLayer && !isDefined(layerDefinition.layer)) {\n            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have an layer defined');\n            return false;\n        }\n\n        if (layerTypes[layerDefinition.type].mustHaveBounds && !isDefined(layerDefinition.bounds)) {\n            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have bounds defined');\n            return false;\n        }\n\n        if (layerTypes[layerDefinition.type].mustHaveKey && !isDefined(layerDefinition.key)) {\n            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have key defined');\n            return false;\n        }\n        return true;\n    }\n\n    function _createLayer(layerDefinition) {\n        if (!isValidLayerType(layerDefinition)) {\n            return;\n        }\n\n        if (!isString(layerDefinition.name)) {\n            $log.error('[AngularJS - Leaflet] A base layer must have a name');\n            return;\n        }\n        if (!isObject(layerDefinition.layerParams)) {\n            layerDefinition.layerParams = {};\n        }\n        if (!isObject(layerDefinition.layerOptions)) {\n            layerDefinition.layerOptions = {};\n        }\n\n        // Mix the layer specific parameters with the general Leaflet options. Although this is an overhead\n        // the definition of a base layers is more 'clean' if the two types of parameters are differentiated\n        for (var attrname in layerDefinition.layerParams) {\n            layerDefinition.layerOptions[attrname] = layerDefinition.layerParams[attrname];\n        }\n\n        var params = {\n            url: layerDefinition.url,\n            data: layerDefinition.data,\n            options: layerDefinition.layerOptions,\n            layer: layerDefinition.layer,\n            icon: layerDefinition.icon,\n            type: layerDefinition.layerType,\n            bounds: layerDefinition.bounds,\n            key: layerDefinition.key,\n            apiKey: layerDefinition.apiKey,\n            pluginOptions: layerDefinition.pluginOptions,\n            user: layerDefinition.user,\n            $parent: layerDefinition\n        };\n\n        //TODO Add $watch to the layer properties\n        return layerTypes[layerDefinition.type].createLayer(params);\n    }\n\n    function safeAddLayer(map, layer) {\n        if (layer && typeof layer.addTo === 'function') {\n            layer.addTo(map);\n        } else {\n            map.addLayer(layer);\n        }\n    }\n\n    function safeRemoveLayer(map, layer, layerOptions) {\n        if (isDefined(layerOptions) && isDefined(layerOptions.loadedDefer)) {\n            if (angular.isFunction(layerOptions.loadedDefer)) {\n                var defers = layerOptions.loadedDefer();\n                $log.debug('Loaded Deferred', defers);\n                var count = defers.length;\n                if (count > 0) {\n                    var resolve = function resolve() {\n                        count--;\n                        if (count === 0) {\n                            map.removeLayer(layer);\n                        }\n                    };\n\n                    for (var i = 0; i < defers.length; i++) {\n                        defers[i].promise.then(resolve);\n                    }\n                } else {\n                    map.removeLayer(layer);\n                }\n            } else {\n                layerOptions.loadedDefer.promise.then(function () {\n                    map.removeLayer(layer);\n                });\n            }\n        } else {\n            map.removeLayer(layer);\n        }\n    }\n\n    var changeOpacityListener = function changeOpacityListener(op) {\n        return function (ly) {\n            if (isDefined(ly.setOpacity)) {\n                ly.setOpacity(op);\n            }\n        };\n    };\n\n    return {\n        createLayer: _createLayer,\n        layerTypes: layerTypes,\n        safeAddLayer: safeAddLayer,\n        safeRemoveLayer: safeRemoveLayer,\n        changeOpacityListener: changeOpacityListener\n    };\n});\n","'use strict';\n\nangular.module(\"ui-leaflet\").factory('leafletLegendHelpers', function ($http, $q, $log, leafletHelpers) {\n\tvar requestQueue = {},\n\t    isDefined = leafletHelpers.isDefined;\n\n\tvar _execNext = function _execNext(mapId) {\n\t\tvar queue = requestQueue[mapId];\n\t\tvar task = queue[0];\n\t\t$http(task.c).then(function (data) {\n\t\t\tqueue.shift();\n\t\t\ttask.d.resolve(data);\n\t\t\tif (queue.length > 0) {\n\t\t\t\t_execNext(mapId);\n\t\t\t}\n\t\t}, function (err) {\n\t\t\tqueue.shift();\n\t\t\ttask.d.reject(err);\n\t\t\tif (queue.length > 0) {\n\t\t\t\t_execNext(mapId);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar _updateLegend = function _updateLegend(div, legendData, type, url) {\n\t\tdiv.innerHTML = '';\n\t\tif (legendData.error) {\n\t\t\tdiv.innerHTML += '<div class=\"info-title alert alert-danger\">' + legendData.error.message + '</div>';\n\t\t} else {\n\t\t\tif (type === 'arcgis') {\n\t\t\t\tfor (var i = 0; i < legendData.layers.length; i++) {\n\t\t\t\t\tvar layer = legendData.layers[i];\n\t\t\t\t\tdiv.innerHTML += '<div class=\"info-title\" data-layerid=\"' + layer.layerId + '\">' + layer.layerName + '</div>';\n\t\t\t\t\tfor (var j = 0; j < layer.legend.length; j++) {\n\t\t\t\t\t\tvar leg = layer.legend[j];\n\t\t\t\t\t\tdiv.innerHTML += '<div class=\"inline\" data-layerid=\"' + layer.layerId + '\"><img src=\"data:' + leg.contentType + ';base64,' + leg.imageData + '\" /></div>' + '<div class=\"info-label\" data-layerid=\"' + layer.layerId + '\">' + leg.label + '</div>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'image') {\n\t\t\t\tdiv.innerHTML = '<img src=\"' + url + '\"/>';\n\t\t\t}\n\t\t}\n\t};\n\n\tvar _getOnAddLegend = function _getOnAddLegend(legendData, legendClass, type, url) {\n\t\treturn function () /*map*/{\n\t\t\tvar div = L.DomUtil.create('div', legendClass);\n\n\t\t\tif (!L.Browser.touch) {\n\t\t\t\tL.DomEvent.disableClickPropagation(div);\n\t\t\t\tL.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);\n\t\t\t} else {\n\t\t\t\tL.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);\n\t\t\t}\n\t\t\t_updateLegend(div, legendData, type, url);\n\t\t\treturn div;\n\t\t};\n\t};\n\n\tvar _getOnAddArrayLegend = function _getOnAddArrayLegend(legend, legendClass) {\n\t\treturn function () /*map*/{\n\t\t\tvar div = L.DomUtil.create('div', legendClass);\n\t\t\tfor (var i = 0; i < legend.colors.length; i++) {\n\t\t\t\tdiv.innerHTML += '<div class=\"outline\"><i style=\"background:' + legend.colors[i] + '\"></i></div>' + '<div class=\"info-label\">' + legend.labels[i] + '</div>';\n\t\t\t}\n\t\t\tif (!L.Browser.touch) {\n\t\t\t\tL.DomEvent.disableClickPropagation(div);\n\t\t\t\tL.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);\n\t\t\t} else {\n\t\t\t\tL.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);\n\t\t\t}\n\t\t\treturn div;\n\t\t};\n\t};\n\n\treturn {\n\t\tgetOnAddLegend: _getOnAddLegend,\n\t\tgetOnAddArrayLegend: _getOnAddArrayLegend,\n\t\tupdateLegend: _updateLegend,\n\t\taddLegendURL: function addLegendURL(mapId, config) {\n\t\t\tvar d = $q.defer();\n\t\t\tif (!isDefined(requestQueue[mapId])) {\n\t\t\t\trequestQueue[mapId] = [];\n\t\t\t}\n\t\t\trequestQueue[mapId].push({ c: config, d: d });\n\t\t\tif (requestQueue[mapId].length === 1) {\n\t\t\t\t_execNext(mapId);\n\t\t\t}\n\t\t\treturn d.promise;\n\t\t}\n\t};\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletMapDefaults', function ($q, leafletHelpers) {\n    function _getDefaults() {\n        return {\n            keyboard: true,\n            dragging: true,\n            worldCopyJump: false,\n            doubleClickZoom: true,\n            scrollWheelZoom: true,\n            tap: true,\n            touchZoom: true,\n            zoomControl: true,\n            zoomsliderControl: false,\n            zoomControlPosition: 'topleft',\n            attributionControl: true,\n            controls: {\n                layers: {\n                    visible: true,\n                    position: 'topright',\n                    collapsed: true\n                }\n            },\n            nominatim: {\n                server: ' http://nominatim.openstreetmap.org/search'\n            },\n            crs: L.CRS.EPSG3857,\n            tileLayer: '//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n            tileLayerOptions: {\n                attribution: '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n            },\n            path: {\n                weight: 10,\n                opacity: 1,\n                color: '#0000ff'\n            },\n            center: {\n                lat: 0,\n                lng: 0,\n                zoom: 1\n            },\n            trackResize: true\n        };\n    }\n\n    var isDefined = leafletHelpers.isDefined,\n        isObject = leafletHelpers.isObject,\n        obtainEffectiveMapId = leafletHelpers.obtainEffectiveMapId,\n        defaults = {};\n\n    // Get the _defaults dictionary, and override the properties defined by the user\n    return {\n        reset: function reset() {\n            defaults = {};\n        },\n        getDefaults: function getDefaults(scopeId) {\n            var mapId = obtainEffectiveMapId(defaults, scopeId);\n            return defaults[mapId];\n        },\n\n        getMapCreationDefaults: function getMapCreationDefaults(scopeId) {\n            var mapId = obtainEffectiveMapId(defaults, scopeId);\n            var d = defaults[mapId];\n\n            var mapDefaults = {\n                maxZoom: d.maxZoom,\n                keyboard: d.keyboard,\n                dragging: d.dragging,\n                zoomControl: d.zoomControl,\n                doubleClickZoom: d.doubleClickZoom,\n                scrollWheelZoom: d.scrollWheelZoom,\n                tap: d.tap,\n                touchZoom: d.touchZoom,\n                attributionControl: d.attributionControl,\n                worldCopyJump: d.worldCopyJump,\n                crs: d.crs,\n                trackResize: d.trackResize\n            };\n\n            if (isDefined(d.minZoom)) {\n                mapDefaults.minZoom = d.minZoom;\n            }\n\n            if (isDefined(d.zoomAnimation)) {\n                mapDefaults.zoomAnimation = d.zoomAnimation;\n            }\n\n            if (isDefined(d.fadeAnimation)) {\n                mapDefaults.fadeAnimation = d.fadeAnimation;\n            }\n\n            if (isDefined(d.markerZoomAnimation)) {\n                mapDefaults.markerZoomAnimation = d.markerZoomAnimation;\n            }\n\n            if (d.map) {\n                for (var option in d.map) {\n                    mapDefaults[option] = d.map[option];\n                }\n            }\n\n            return mapDefaults;\n        },\n\n        setDefaults: function setDefaults(userDefaults, scopeId) {\n            var newDefaults = _getDefaults();\n\n            if (isDefined(userDefaults)) {\n                newDefaults.doubleClickZoom = isDefined(userDefaults.doubleClickZoom) ? userDefaults.doubleClickZoom : newDefaults.doubleClickZoom;\n                newDefaults.scrollWheelZoom = isDefined(userDefaults.scrollWheelZoom) ? userDefaults.scrollWheelZoom : newDefaults.doubleClickZoom;\n                newDefaults.tap = isDefined(userDefaults.tap) ? userDefaults.tap : newDefaults.tap;\n                newDefaults.touchZoom = isDefined(userDefaults.touchZoom) ? userDefaults.touchZoom : newDefaults.doubleClickZoom;\n                newDefaults.zoomControl = isDefined(userDefaults.zoomControl) ? userDefaults.zoomControl : newDefaults.zoomControl;\n                newDefaults.zoomsliderControl = isDefined(userDefaults.zoomsliderControl) ? userDefaults.zoomsliderControl : newDefaults.zoomsliderControl;\n                newDefaults.attributionControl = isDefined(userDefaults.attributionControl) ? userDefaults.attributionControl : newDefaults.attributionControl;\n                newDefaults.tileLayer = isDefined(userDefaults.tileLayer) ? userDefaults.tileLayer : newDefaults.tileLayer;\n                newDefaults.zoomControlPosition = isDefined(userDefaults.zoomControlPosition) ? userDefaults.zoomControlPosition : newDefaults.zoomControlPosition;\n                newDefaults.keyboard = isDefined(userDefaults.keyboard) ? userDefaults.keyboard : newDefaults.keyboard;\n                newDefaults.dragging = isDefined(userDefaults.dragging) ? userDefaults.dragging : newDefaults.dragging;\n                newDefaults.trackResize = isDefined(userDefaults.trackResize) ? userDefaults.trackResize : newDefaults.trackResize;\n\n                if (isDefined(userDefaults.controls)) {\n                    angular.extend(newDefaults.controls, userDefaults.controls);\n                }\n\n                if (isObject(userDefaults.crs)) {\n                    newDefaults.crs = userDefaults.crs;\n                } else if (isDefined(L.CRS[userDefaults.crs])) {\n                    newDefaults.crs = L.CRS[userDefaults.crs];\n                }\n\n                if (isDefined(userDefaults.center)) {\n                    angular.copy(userDefaults.center, newDefaults.center);\n                }\n\n                if (isDefined(userDefaults.tileLayerOptions)) {\n                    angular.copy(userDefaults.tileLayerOptions, newDefaults.tileLayerOptions);\n                }\n\n                if (isDefined(userDefaults.maxZoom)) {\n                    newDefaults.maxZoom = userDefaults.maxZoom;\n                }\n\n                if (isDefined(userDefaults.minZoom)) {\n                    newDefaults.minZoom = userDefaults.minZoom;\n                }\n\n                if (isDefined(userDefaults.zoomAnimation)) {\n                    newDefaults.zoomAnimation = userDefaults.zoomAnimation;\n                }\n\n                if (isDefined(userDefaults.fadeAnimation)) {\n                    newDefaults.fadeAnimation = userDefaults.fadeAnimation;\n                }\n\n                if (isDefined(userDefaults.markerZoomAnimation)) {\n                    newDefaults.markerZoomAnimation = userDefaults.markerZoomAnimation;\n                }\n\n                if (isDefined(userDefaults.worldCopyJump)) {\n                    newDefaults.worldCopyJump = userDefaults.worldCopyJump;\n                }\n\n                if (isDefined(userDefaults.map)) {\n                    newDefaults.map = userDefaults.map;\n                }\n\n                if (isDefined(userDefaults.path)) {\n                    newDefaults.path = userDefaults.path;\n                }\n            }\n\n            var mapId = obtainEffectiveMapId(defaults, scopeId);\n            defaults[mapId] = newDefaults;\n            return newDefaults;\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletMarkersHelpers', function ($rootScope, $timeout, leafletHelpers, leafletLogger, $compile, leafletGeoJsonHelpers, leafletWatchHelpers) {\n    var isDefined = leafletHelpers.isDefined,\n        defaultTo = leafletHelpers.defaultTo,\n        MarkerClusterPlugin = leafletHelpers.MarkerClusterPlugin,\n        AwesomeMarkersPlugin = leafletHelpers.AwesomeMarkersPlugin,\n        VectorMarkersPlugin = leafletHelpers.VectorMarkersPlugin,\n        MakiMarkersPlugin = leafletHelpers.MakiMarkersPlugin,\n        ExtraMarkersPlugin = leafletHelpers.ExtraMarkersPlugin,\n        DomMarkersPlugin = leafletHelpers.DomMarkersPlugin,\n        safeApply = leafletHelpers.safeApply,\n        Helpers = leafletHelpers,\n        isString = leafletHelpers.isString,\n        isNumber = leafletHelpers.isNumber,\n        isObject = leafletHelpers.isObject,\n        groups = {},\n        geoHlp = leafletGeoJsonHelpers,\n        errorHeader = leafletHelpers.errorHeader,\n        maybeWatch = leafletWatchHelpers.maybeWatch,\n        $log = leafletLogger;\n\n    var _string = function _string(marker) {\n        //this exists since JSON.stringify barfs on cyclic\n        var retStr = '';\n        ['_icon', '_latlng', '_leaflet_id', '_map', '_shadow'].forEach(function (prop) {\n            retStr += prop + ': ' + defaultTo(marker[prop], 'undefined') + ' \\n';\n        });\n        return '[leafletMarker] : \\n' + retStr;\n    };\n    var _log = function _log(marker, useConsole) {\n        var logger = useConsole ? console : $log;\n        logger.debug(_string(marker));\n    };\n\n    var existDomContainer = function existDomContainer(groupName) {\n        return angular.element(groups[groupName]._map._container).parent().length > 0;\n    };\n\n    var createLeafletIcon = function createLeafletIcon(iconData) {\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'awesomeMarker') {\n            if (!AwesomeMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + ' The AwesomeMarkers Plugin is not loaded.');\n            }\n\n            return new L.AwesomeMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'vectorMarker') {\n            if (!VectorMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + ' The VectorMarkers Plugin is not loaded.');\n            }\n\n            return new L.VectorMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'makiMarker') {\n            if (!MakiMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + 'The MakiMarkers Plugin is not loaded.');\n            }\n\n            return new L.MakiMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'extraMarker') {\n            if (!ExtraMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + 'The ExtraMarkers Plugin is not loaded.');\n            }\n            return new L.ExtraMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'div') {\n            return new L.divIcon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'dom') {\n            if (!DomMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + 'The DomMarkers Plugin is not loaded.');\n            }\n            var markerScope = angular.isFunction(iconData.getMarkerScope) ? iconData.getMarkerScope().$new() : $rootScope,\n                template = $compile(iconData.template)(markerScope),\n                iconDataCopy = angular.copy(iconData);\n            iconDataCopy.ngElement = template;\n            iconDataCopy.element = template[0];\n            if (angular.isFunction(iconData.getMarkerScope)) iconDataCopy.scope = markerScope;\n            return new L.DomMarkers.icon(iconDataCopy);\n        }\n\n        // allow for any custom icon to be used... assumes the icon has already been initialized\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'icon') {\n            return iconData.icon;\n        }\n\n        var base64icon = \"data:image/png;base64,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\";\n        var base64shadow = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=\";\n\n        if (!isDefined(iconData) || !isDefined(iconData.iconUrl)) {\n            return new L.Icon.Default({\n                iconUrl: base64icon,\n                shadowUrl: base64shadow,\n                iconSize: [25, 41],\n                iconAnchor: [12, 41],\n                popupAnchor: [1, -34],\n                shadowSize: [41, 41]\n            });\n        }\n\n        return new L.Icon(iconData);\n    };\n\n    var _resetMarkerGroup = function _resetMarkerGroup(groupName) {\n        if (isDefined(groups[groupName])) {\n            delete groups[groupName];\n        }\n    };\n\n    var _resetMarkerGroups = function _resetMarkerGroups() {\n        groups = {};\n    };\n\n    var _resetUnusedMarkerGroups = function _resetUnusedMarkerGroups() {\n        for (var groupName in groups) {\n            if (!existDomContainer(groupName)) {\n                _resetMarkerGroup(groupName);\n            }\n        }\n    };\n\n    var _cleanDomIcon = function _cleanDomIcon(marker) {\n        if (marker.options.icon.options.ngElement) {\n            marker.options.icon.options.ngElement.remove();\n        }\n        if (marker.options.icon.options.scope) {\n            marker.options.icon.options.scope.$destroy();\n        }\n    };\n\n    var _deleteMarker = function _deleteMarker(marker, map, layers) {\n        marker.closePopup();\n\n        // if it's a dom icon, clean it\n        if (marker.options.icon && marker.options.icon.options && marker.options.icon.options.type === 'dom') {\n            _cleanDomIcon(marker);\n        }\n\n        // There is no easy way to know if a marker is added to a layer, so we search for it\n        // if there are overlays\n        if (isDefined(layers) && isDefined(layers.overlays)) {\n            for (var key in layers.overlays) {\n                if (layers.overlays[key] instanceof L.LayerGroup || layers.overlays[key] instanceof L.FeatureGroup) {\n                    if (layers.overlays[key].hasLayer(marker)) {\n                        layers.overlays[key].removeLayer(marker);\n                        return;\n                    }\n                }\n            }\n        }\n\n        if (isDefined(groups)) {\n            for (var groupKey in groups) {\n                if (groups[groupKey].hasLayer(marker)) {\n                    groups[groupKey].removeLayer(marker);\n                }\n            }\n        }\n\n        if (map.hasLayer(marker)) {\n            map.removeLayer(marker);\n        }\n    };\n\n    var adjustPopupPan = function adjustPopupPan(marker, map) {\n        var containerHeight = marker._popup._container.offsetHeight,\n            layerPos = new L.Point(marker._popup._containerLeft, -containerHeight - marker._popup._containerBottom),\n            containerPos = map.layerPointToContainerPoint(layerPos);\n        if (containerPos !== null) {\n            marker._popup._adjustPan();\n        }\n    };\n\n    var compilePopup = function compilePopup(marker, markerScope) {\n        $compile(marker._popup._contentNode)(markerScope);\n    };\n\n    var updatePopup = function updatePopup(marker, markerScope, map) {\n        //The innerText should be more than 1 once angular has compiled.\n        //We need to keep trying until angular has compiled before we _updateLayout and _updatePosition\n        //This should take care of any scenario , eg ngincludes, whatever.\n        //Is there a better way to check for this?\n        var innerText = marker._popup._contentNode.innerText || marker._popup._contentNode.textContent;\n        if (innerText.length < 1) {\n            $timeout(function () {\n                updatePopup(marker, markerScope, map);\n            });\n        }\n\n        //cause a reflow - this is also very important - if we don't do this then the widths are from before $compile\n        var reflow = marker._popup._contentNode.offsetWidth;\n\n        marker._popup._updateLayout();\n        marker._popup._updatePosition();\n\n        if (marker._popup.options.autoPan) {\n            adjustPopupPan(marker, map);\n        }\n\n        //using / returning reflow so jshint doesn't moan\n        return reflow;\n    };\n\n    var _manageOpenPopup = function _manageOpenPopup(marker, markerData, map) {\n        // The marker may provide a scope returning function used to compile the message\n        // default to $rootScope otherwise\n        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,\n            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;\n\n        if (compileMessage) {\n            if (!isDefined(marker._popup) || !isDefined(marker._popup._contentNode)) {\n                $log.error(errorHeader + 'Popup is invalid or does not have any content.');\n                return false;\n            }\n\n            compilePopup(marker, markerScope);\n            updatePopup(marker, markerData, map);\n        }\n    };\n\n    var _manageOpenLabel = function _manageOpenLabel(marker, markerData) {\n        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,\n            labelScope = angular.isFunction(markerData.getLabelScope) ? markerData.getLabelScope() : markerScope,\n            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;\n\n        if (Helpers.LabelPlugin.isLoaded() && isDefined(markerData.label)) {\n            if (isDefined(markerData.label.options) && markerData.label.options.noHide === true) {\n                marker.showLabel();\n            }\n            if (compileMessage && isDefined(marker.label)) {\n                $compile(marker.label._container)(labelScope);\n            }\n        }\n    };\n\n    var _updateMarker = function _updateMarker(markerData, oldMarkerData, marker, name, leafletScope, layers, map) {\n        if (!isDefined(oldMarkerData)) {\n            return;\n        }\n\n        // Update the lat-lng property (always present in marker properties)\n        if (!geoHlp.validateCoords(markerData)) {\n            $log.warn('There are problems with lat-lng data, please verify your marker model');\n            _deleteMarker(marker, map, layers);\n            return;\n        }\n\n        // watch is being initialized if old and new object is the same\n        var isInitializing = markerData === oldMarkerData;\n\n        // Update marker rotation\n        if (isDefined(markerData.iconAngle) && oldMarkerData.iconAngle !== markerData.iconAngle) {\n            marker.setIconAngle(markerData.iconAngle);\n        }\n\n        // It is possible that the layer has been removed or the layer marker does not exist\n        // Update the layer group if present or move it to the map if not\n        if (!isString(markerData.layer)) {\n            // There is no layer information, we move the marker to the map if it was in a layer group\n            if (isString(oldMarkerData.layer)) {\n                // Remove from the layer group that is supposed to be\n                if (isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {\n                    layers.overlays[oldMarkerData.layer].removeLayer(marker);\n                    marker.closePopup();\n                }\n                // Test if it is not on the map and add it\n                if (!map.hasLayer(marker)) {\n                    map.addLayer(marker);\n                }\n            }\n        }\n\n        if ((isNumber(markerData.opacity) || isNumber(parseFloat(markerData.opacity))) && markerData.opacity !== oldMarkerData.opacity) {\n            // There was a different opacity so we update it\n            marker.setOpacity(markerData.opacity);\n        }\n\n        if (isString(markerData.layer) && oldMarkerData.layer !== markerData.layer) {\n            // If it was on a layer group we have to remove it\n            if (isString(oldMarkerData.layer) && isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {\n                layers.overlays[oldMarkerData.layer].removeLayer(marker);\n            }\n            marker.closePopup();\n\n            // Remove it from the map in case the new layer is hidden or there is an error in the new layer\n            if (map.hasLayer(marker)) {\n                map.removeLayer(marker);\n            }\n\n            // The markerData.layer is defined so we add the marker to the layer if it is different from the old data\n            if (!isDefined(layers.overlays[markerData.layer])) {\n                $log.error(errorHeader + 'You must use a name of an existing layer');\n                return;\n            }\n            // Is a group layer?\n            var layerGroup = layers.overlays[markerData.layer];\n            if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {\n                $log.error(errorHeader + 'A marker can only be added to a layer of type \"group\" or \"featureGroup\"');\n                return;\n            }\n            // The marker goes to a correct layer group, so first of all we add it\n            layerGroup.addLayer(marker);\n            // The marker is automatically added to the map depending on the visibility\n            // of the layer, so we only have to open the popup if the marker is in the map\n            if (map.hasLayer(marker) && markerData.focus === true) {\n                marker.openPopup();\n            }\n        }\n\n        // Update the draggable property\n        if (markerData.draggable !== true && oldMarkerData.draggable === true && isDefined(marker.dragging)) {\n            marker.dragging.disable();\n        }\n\n        if (markerData.draggable === true && oldMarkerData.draggable !== true) {\n            // The markerData.draggable property must be true so we update if there wasn't a previous value or it wasn't true\n            if (marker.dragging) {\n                marker.dragging.enable();\n            } else {\n                if (L.Handler.MarkerDrag) {\n                    marker.dragging = new L.Handler.MarkerDrag(marker);\n                    marker.options.draggable = true;\n                    marker.dragging.enable();\n                }\n            }\n        }\n\n        // Update the icon property\n        if (!isObject(markerData.icon)) {\n            // If there is no icon property or it's not an object\n            if (isObject(oldMarkerData.icon)) {\n                if (oldMarkerData.icon.type === 'dom') {\n                    // clean previous icon if it's a dom one\n                    _cleanDomIcon(marker);\n                }\n                // If there was an icon before restore to the default\n                marker.setIcon(createLeafletIcon());\n                marker.closePopup();\n                marker.unbindPopup();\n                if (isString(markerData.message)) {\n                    marker.bindPopup(markerData.message, markerData.popupOptions);\n                }\n            }\n        }\n\n        if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {\n            var dragG = false;\n            if (marker.dragging) {\n                dragG = marker.dragging.enabled();\n            }\n            if (oldMarkerData.icon.type === 'dom') {\n                // clean previous icon if it's a dom one\n                _cleanDomIcon(marker);\n            }\n            marker.setIcon(createLeafletIcon(markerData.icon));\n            if (dragG) {\n                marker.dragging.enable();\n            }\n            marker.closePopup();\n            marker.unbindPopup();\n            if (isString(markerData.message)) {\n                marker.bindPopup(markerData.message, markerData.popupOptions);\n                // if marker has been already focused, reopen popup\n                if (map.hasLayer(marker) && markerData.focus === true) {\n                    marker.openPopup();\n                }\n            }\n        }\n\n        // Update the Popup message property\n        if (!isString(markerData.message) && isString(oldMarkerData.message)) {\n            marker.closePopup();\n            marker.unbindPopup();\n        }\n\n        // Update the label content or bind a new label if the old one has been removed.\n        if (Helpers.LabelPlugin.isLoaded()) {\n            if (isDefined(markerData.label) && isDefined(markerData.label.message)) {\n                if ('label' in oldMarkerData && 'message' in oldMarkerData.label && !angular.equals(markerData.label.message, oldMarkerData.label.message)) {\n                    marker.updateLabelContent(markerData.label.message);\n                } else if (!angular.isFunction(marker.getLabel) || angular.isFunction(marker.getLabel) && !isDefined(marker.getLabel())) {\n                    marker.bindLabel(markerData.label.message, markerData.label.options);\n                    _manageOpenLabel(marker, markerData);\n                } else {\n                    _manageOpenLabel(marker, markerData);\n                }\n            } else if (!('label' in markerData && !('message' in markerData.label))) {\n                if (angular.isFunction(marker.unbindLabel)) {\n                    marker.unbindLabel();\n                }\n            }\n        }\n\n        // There is some text in the popup, so we must show the text or update existing\n        if (isString(markerData.message) && !isString(oldMarkerData.message)) {\n            // There was no message before so we create it\n            marker.bindPopup(markerData.message, markerData.popupOptions);\n        }\n\n        if (isString(markerData.message) && isString(oldMarkerData.message) && markerData.message !== oldMarkerData.message) {\n            // There was a different previous message so we update it\n            marker.setPopupContent(markerData.message);\n        }\n\n        // Update the focus property\n        var updatedFocus = false;\n        if (markerData.focus !== true && oldMarkerData.focus === true) {\n            // If there was a focus property and was true we turn it off\n            marker.closePopup();\n            updatedFocus = true;\n        }\n\n        // The markerData.focus property must be true so we update if there wasn't a previous value or it wasn't true\n        if (markerData.focus === true && (!isDefined(oldMarkerData.focus) || oldMarkerData.focus === false) || isInitializing && markerData.focus === true) {\n            // Reopen the popup when focus is still true\n            marker.openPopup();\n            updatedFocus = true;\n        }\n\n        // zIndexOffset adjustment\n        if (oldMarkerData.zIndexOffset !== markerData.zIndexOffset) {\n            marker.setZIndexOffset(markerData.zIndexOffset);\n        }\n\n        var markerLatLng = marker.getLatLng();\n        var isCluster = isString(markerData.layer) && Helpers.MarkerClusterPlugin.is(layers.overlays[markerData.layer]);\n        // If the marker is in a cluster it has to be removed and added to the layer when the location is changed\n        if (isCluster) {\n            // The focus has changed even by a user click or programatically\n            if (updatedFocus) {\n                // We only have to update the location if it was changed programatically, because it was\n                // changed by a user drag the marker data has already been updated by the internal event\n                // listened by the directive\n                if (markerData.lat !== oldMarkerData.lat || markerData.lng !== oldMarkerData.lng) {\n                    layers.overlays[markerData.layer].removeLayer(marker);\n                    marker.setLatLng([markerData.lat, markerData.lng]);\n                    layers.overlays[markerData.layer].addLayer(marker);\n                }\n            } else {\n                // The marker has possibly moved. It can be moved by a user drag (marker location and data are equal but old\n                // data is diferent) or programatically (marker location and data are diferent)\n                if (markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng) {\n                    // The marker was moved by a user drag\n                    layers.overlays[markerData.layer].removeLayer(marker);\n                    marker.setLatLng([markerData.lat, markerData.lng]);\n                    layers.overlays[markerData.layer].addLayer(marker);\n                } else if (markerData.lat !== oldMarkerData.lat || markerData.lng !== oldMarkerData.lng) {\n                    // The marker was moved programatically\n                    layers.overlays[markerData.layer].removeLayer(marker);\n                    marker.setLatLng([markerData.lat, markerData.lng]);\n                    layers.overlays[markerData.layer].addLayer(marker);\n                } else if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {\n                    layers.overlays[markerData.layer].removeLayer(marker);\n                    layers.overlays[markerData.layer].addLayer(marker);\n                }\n            }\n        } else if (markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng) {\n            marker.setLatLng([markerData.lat, markerData.lng]);\n        }\n    };\n\n    var _getLayerModels = function _getLayerModels(models, layerName) {\n        if (!isDefined(models)) return;\n        if (layerName) return models[layerName];\n        return models;\n    };\n\n    var _getModelFromModels = function _getModelFromModels(models, id, layerName) {\n        if (!isDefined(models)) return;\n        if (!id) {\n            $log.error(errorHeader + 'marker id missing in getMarker');\n            return;\n        }\n        if (layerName) return models[layerName][id];\n\n        return models[id];\n    };\n    return {\n        resetMarkerGroup: _resetMarkerGroup,\n\n        resetMarkerGroups: _resetMarkerGroups,\n\n        resetUnusedMarkerGroups: _resetUnusedMarkerGroups,\n\n        deleteMarker: _deleteMarker,\n\n        manageOpenPopup: _manageOpenPopup,\n\n        manageOpenLabel: _manageOpenLabel,\n\n        createMarker: function createMarker(markerData) {\n            if (!isDefined(markerData) || !geoHlp.validateCoords(markerData)) {\n                $log.error(errorHeader + 'The marker definition is not valid.');\n                return;\n            }\n            var coords = geoHlp.getCoords(markerData);\n\n            if (!isDefined(coords)) {\n                $log.error(errorHeader + 'Unable to get coordinates from markerData.');\n                return;\n            }\n\n            var markerOptions = {\n                icon: createLeafletIcon(markerData.icon),\n                title: isDefined(markerData.title) ? markerData.title : '',\n                draggable: isDefined(markerData.draggable) ? markerData.draggable : false,\n                clickable: isDefined(markerData.clickable) ? markerData.clickable : true,\n                riseOnHover: isDefined(markerData.riseOnHover) ? markerData.riseOnHover : false,\n                zIndexOffset: isDefined(markerData.zIndexOffset) ? markerData.zIndexOffset : 0,\n                iconAngle: isDefined(markerData.iconAngle) ? markerData.iconAngle : 0\n            };\n            // Add any other options not added above to markerOptions\n            for (var markerDatum in markerData) {\n                if (markerData.hasOwnProperty(markerDatum) && !markerOptions.hasOwnProperty(markerDatum)) {\n                    markerOptions[markerDatum] = markerData[markerDatum];\n                }\n            }\n\n            var marker = new L.marker(coords, markerOptions);\n\n            if (!isString(markerData.message)) {\n                marker.unbindPopup();\n            }\n\n            return marker;\n        },\n\n        addMarkerToGroup: function addMarkerToGroup(marker, groupName, groupOptions, map) {\n            if (!isString(groupName)) {\n                $log.error(errorHeader + 'The marker group you have specified is invalid.');\n                return;\n            }\n\n            if (!MarkerClusterPlugin.isLoaded()) {\n                $log.error(errorHeader + \"The MarkerCluster plugin is not loaded.\");\n                return;\n            }\n            if (!isDefined(groups[groupName])) {\n                groups[groupName] = new L.MarkerClusterGroup(groupOptions);\n                map.addLayer(groups[groupName]);\n            }\n            groups[groupName].addLayer(marker);\n        },\n\n        listenMarkerEvents: function listenMarkerEvents(marker, markerData, leafletScope, watchType, map) {\n            marker.on(\"popupopen\", function () /* event */{\n                safeApply(leafletScope, function () {\n                    if (isDefined(marker._popup) || isDefined(marker._popup._contentNode)) {\n                        markerData.focus = true;\n                        _manageOpenPopup(marker, markerData, map); //needed since markerData is now a copy\n                    }\n                });\n            });\n            marker.on(\"popupclose\", function () /* event */{\n                safeApply(leafletScope, function () {\n                    markerData.focus = false;\n                });\n            });\n            marker.on(\"add\", function () /* event */{\n                safeApply(leafletScope, function () {\n                    if ('label' in markerData) _manageOpenLabel(marker, markerData);\n                });\n            });\n        },\n\n        updateMarker: _updateMarker,\n\n        addMarkerWatcher: function addMarkerWatcher(marker, name, leafletScope, layers, map, watchOptions) {\n            var markerWatchPath = Helpers.getObjectArrayPath(\"markers.\" + name);\n\n            maybeWatch(leafletScope, markerWatchPath, watchOptions, function (markerData, oldMarkerData, clearWatch) {\n                if (!isDefined(markerData)) {\n                    _deleteMarker(marker, map, layers);\n                    clearWatch();\n                    return;\n                }\n                _updateMarker(markerData, oldMarkerData, marker, name, leafletScope, layers, map);\n            });\n        },\n        string: _string,\n        log: _log,\n        getModelFromModels: _getModelFromModels,\n        getLayerModels: _getLayerModels\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletPathsHelpers', function ($rootScope, leafletLogger, leafletHelpers) {\n    var isDefined = leafletHelpers.isDefined,\n        isArray = leafletHelpers.isArray,\n        isNumber = leafletHelpers.isNumber,\n        isValidPoint = leafletHelpers.isValidPoint,\n        $log = leafletLogger;\n\n    var availableOptions = [\n    // Path options\n    'stroke', 'weight', 'color', 'opacity', 'fill', 'fillColor', 'fillOpacity', 'dashArray', 'lineCap', 'lineJoin', 'clickable', 'pointerEvents', 'className',\n\n    // Polyline options\n    'smoothFactor', 'noClip'];\n    function _convertToLeafletLatLngs(latlngs) {\n        return latlngs.filter(function (latlng) {\n            return isValidPoint(latlng);\n        }).map(function (latlng) {\n            return _convertToLeafletLatLng(latlng);\n        });\n    }\n\n    function _convertToLeafletLatLng(latlng) {\n        if (isArray(latlng)) {\n            return new L.LatLng(latlng[0], latlng[1]);\n        } else {\n            return new L.LatLng(latlng.lat, latlng.lng);\n        }\n    }\n\n    function _convertToLeafletMultiLatLngs(paths) {\n        return paths.map(function (latlngs) {\n            return _convertToLeafletLatLngs(latlngs);\n        });\n    }\n\n    function _getOptions(path, defaults) {\n        var options = {};\n        for (var i = 0; i < availableOptions.length; i++) {\n            var optionName = availableOptions[i];\n\n            if (isDefined(path[optionName])) {\n                options[optionName] = path[optionName];\n            } else if (isDefined(defaults.path[optionName])) {\n                options[optionName] = defaults.path[optionName];\n            }\n        }\n\n        return options;\n    }\n\n    var _updatePathOptions = function _updatePathOptions(path, data) {\n        var updatedStyle = {};\n        for (var i = 0; i < availableOptions.length; i++) {\n            var optionName = availableOptions[i];\n            if (isDefined(data[optionName])) {\n                updatedStyle[optionName] = data[optionName];\n            }\n        }\n        path.setStyle(data);\n    };\n\n    var _isValidPolyline = function _isValidPolyline(latlngs) {\n        if (!isArray(latlngs)) {\n            return false;\n        }\n        for (var i = 0; i < latlngs.length; i++) {\n            var point = latlngs[i];\n            if (!isValidPoint(point)) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    var pathTypes = {\n        polyline: {\n            isValid: function isValid(pathData) {\n                var latlngs = pathData.latlngs;\n                return _isValidPolyline(latlngs);\n            },\n            createPath: function createPath(options) {\n                return new L.Polyline([], options);\n            },\n            setPath: function setPath(path, data) {\n                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        },\n        multiPolyline: {\n            isValid: function isValid(pathData) {\n                var latlngs = pathData.latlngs;\n                if (!isArray(latlngs)) {\n                    return false;\n                }\n\n                for (var i in latlngs) {\n                    var polyline = latlngs[i];\n                    if (!_isValidPolyline(polyline)) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n            createPath: function createPath(options) {\n                return new L.multiPolyline([[[0, 0], [1, 1]]], options);\n            },\n            setPath: function setPath(path, data) {\n                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        },\n        polygon: {\n            isValid: function isValid(pathData) {\n                var latlngs = pathData.latlngs;\n                return _isValidPolyline(latlngs);\n            },\n            createPath: function createPath(options) {\n                return new L.Polygon([], options);\n            },\n            setPath: function setPath(path, data) {\n                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        },\n        multiPolygon: {\n            isValid: function isValid(pathData) {\n                var latlngs = pathData.latlngs;\n\n                if (!isArray(latlngs)) {\n                    return false;\n                }\n\n                for (var i in latlngs) {\n                    var polyline = latlngs[i];\n                    if (!_isValidPolyline(polyline)) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n            createPath: function createPath(options) {\n                return new L.MultiPolygon([[[0, 0], [1, 1], [0, 1]]], options);\n            },\n            setPath: function setPath(path, data) {\n                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        },\n        rectangle: {\n            isValid: function isValid(pathData) {\n                var latlngs = pathData.latlngs;\n\n                if (!isArray(latlngs) || latlngs.length !== 2) {\n                    return false;\n                }\n\n                for (var i in latlngs) {\n                    var point = latlngs[i];\n                    if (!isValidPoint(point)) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n            createPath: function createPath(options) {\n                return new L.Rectangle([[0, 0], [1, 1]], options);\n            },\n            setPath: function setPath(path, data) {\n                path.setBounds(new L.LatLngBounds(_convertToLeafletLatLngs(data.latlngs)));\n                _updatePathOptions(path, data);\n            }\n        },\n        circle: {\n            isValid: function isValid(pathData) {\n                var point = pathData.latlngs;\n                return isValidPoint(point) && isNumber(pathData.radius);\n            },\n            createPath: function createPath(options) {\n                return new L.Circle([0, 0], 1, options);\n            },\n            setPath: function setPath(path, data) {\n                path.setLatLng(_convertToLeafletLatLng(data.latlngs));\n                if (isDefined(data.radius)) {\n                    path.setRadius(data.radius);\n                }\n                _updatePathOptions(path, data);\n            }\n        },\n        circleMarker: {\n            isValid: function isValid(pathData) {\n                var point = pathData.latlngs;\n                return isValidPoint(point) && isNumber(pathData.radius);\n            },\n            createPath: function createPath(options) {\n                return new L.CircleMarker([0, 0], options);\n            },\n            setPath: function setPath(path, data) {\n                path.setLatLng(_convertToLeafletLatLng(data.latlngs));\n                if (isDefined(data.radius)) {\n                    path.setRadius(data.radius);\n                }\n                _updatePathOptions(path, data);\n            }\n        }\n    };\n\n    var _getPathData = function _getPathData(path) {\n        var pathData = {};\n        if (path.latlngs) {\n            pathData.latlngs = path.latlngs;\n        }\n\n        if (path.radius) {\n            pathData.radius = path.radius;\n        }\n\n        return pathData;\n    };\n\n    return {\n        setPathOptions: function setPathOptions(leafletPath, pathType, data) {\n            if (!isDefined(pathType)) {\n                pathType = \"polyline\";\n            }\n            pathTypes[pathType].setPath(leafletPath, data);\n        },\n        createPath: function createPath(name, path, defaults) {\n            if (!isDefined(path.type)) {\n                path.type = \"polyline\";\n            }\n            var options = _getOptions(path, defaults);\n            var pathData = _getPathData(path);\n\n            if (!pathTypes[path.type].isValid(pathData)) {\n                $log.error(\"[AngularJS - Leaflet] Invalid data passed to the \" + path.type + \" path\");\n                return;\n            }\n\n            return pathTypes[path.type].createPath(options);\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletWatchHelpers', function () {\n\n    var _maybe = function _maybe(scope, watchFunctionName, thingToWatchStr, watchOptions, initCb) {\n        var unWatch = scope[watchFunctionName](thingToWatchStr, function (newValue, oldValue) {\n            //make the unWatch function available to the callback as well.\n            initCb(newValue, oldValue, unWatch);\n            if (watchOptions.type === null) unWatch();\n        }, watchOptions.type === 'watchDeep');\n\n        return unWatch;\n    };\n\n    /*\n    @name: maybeWatch\n    @description: Utility to watch something once or forever.\n    @returns unWatch function\n    @param watchOptions - This object is used to determine the type of\n    watch used.\n    */\n    var _maybeWatch = function _maybeWatch(scope, thingToWatchStr, watchOptions, initCb) {\n        var watchMethod;\n\n        if (watchOptions.type === 'watchCollection') {\n            watchMethod = '$watchCollection';\n        } else {\n            watchMethod = '$watch';\n        }\n\n        return _maybe(scope, watchMethod, thingToWatchStr, watchOptions, initCb);\n    };\n\n    return {\n        maybeWatch: _maybeWatch\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').service('leafletLogger', function (nemSimpleLogger) {\n  return nemSimpleLogger.spawn();\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('nominatimService', function ($q, $http, leafletHelpers, leafletMapDefaults) {\n    var isDefined = leafletHelpers.isDefined;\n\n    return {\n        query: function query(address, mapId) {\n            var defaults = leafletMapDefaults.getDefaults(mapId);\n            var url = defaults.nominatim.server;\n            var df = $q.defer();\n\n            $http.get(url, { params: { format: 'json', limit: 1, q: address } }).success(function (data) {\n                if (data.length > 0 && isDefined(data[0].boundingbox)) {\n                    df.resolve(data[0]);\n                } else {\n                    df.reject('[Nominatim] Invalid address');\n                }\n            });\n\n            return df.promise;\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('bounds', function (leafletLogger, $timeout, $http, leafletHelpers, nominatimService, leafletBoundsHelpers) {\n    var $log = leafletLogger;\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: ['leaflet'],\n\n        link: function link(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined;\n            var createLeafletBounds = leafletBoundsHelpers.createLeafletBounds;\n            var leafletScope = controller[0].getLeafletScope();\n            var mapController = controller[0];\n            var errorHeader = leafletHelpers.errorHeader + ' [Bounds] ';\n\n            var emptyBounds = function emptyBounds(bounds) {\n                return bounds._southWest.lat === 0 && bounds._southWest.lng === 0 && bounds._northEast.lat === 0 && bounds._northEast.lng === 0;\n            };\n\n            mapController.getMap().then(function (map) {\n                leafletScope.$on('boundsChanged', function (event) {\n                    var scope = event.currentScope;\n                    var bounds = map.getBounds();\n\n                    if (emptyBounds(bounds) || scope.settingBoundsFromScope) {\n                        return;\n                    }\n                    scope.settingBoundsFromLeaflet = true;\n                    var newScopeBounds = {\n                        northEast: {\n                            lat: bounds._northEast.lat,\n                            lng: bounds._northEast.lng\n                        },\n                        southWest: {\n                            lat: bounds._southWest.lat,\n                            lng: bounds._southWest.lng\n                        },\n                        options: bounds.options\n                    };\n                    if (!angular.equals(scope.bounds, newScopeBounds)) {\n                        scope.bounds = newScopeBounds;\n                    }\n                    $timeout(function () {\n                        scope.settingBoundsFromLeaflet = false;\n                    });\n                });\n\n                var lastNominatimQuery;\n                leafletScope.$watch('bounds', function (bounds) {\n                    if (scope.settingBoundsFromLeaflet) return;\n                    if (isDefined(bounds.address) && bounds.address !== lastNominatimQuery) {\n                        scope.settingBoundsFromScope = true;\n                        nominatimService.query(bounds.address, attrs.id).then(function (data) {\n                            var b = data.boundingbox;\n                            var newBounds = [[b[0], b[2]], [b[1], b[3]]];\n                            map.fitBounds(newBounds);\n                        }, function (errMsg) {\n                            $log.error(errorHeader + ' ' + errMsg + '.');\n                        });\n                        lastNominatimQuery = bounds.address;\n                        $timeout(function () {\n                            scope.settingBoundsFromScope = false;\n                        });\n                        return;\n                    }\n\n                    var leafletBounds = createLeafletBounds(bounds);\n                    if (leafletBounds && !map.getBounds().equals(leafletBounds)) {\n                        scope.settingBoundsFromScope = true;\n                        map.fitBounds(leafletBounds, bounds.options);\n                        $timeout(function () {\n                            scope.settingBoundsFromScope = false;\n                        });\n                    }\n                }, true);\n            });\n        }\n    };\n});\n","'use strict';\n\nvar centerDirectiveTypes = ['center', 'lfCenter'],\n    centerDirectives = {};\n\ncenterDirectiveTypes.forEach(function (directiveName) {\n    centerDirectives[directiveName] = ['leafletLogger', '$q', '$location', '$timeout', 'leafletMapDefaults', 'leafletHelpers', 'leafletBoundsHelpers', 'leafletMapEvents', function (leafletLogger, $q, $location, $timeout, leafletMapDefaults, leafletHelpers, leafletBoundsHelpers, leafletMapEvents) {\n\n        var isDefined = leafletHelpers.isDefined,\n            isNumber = leafletHelpers.isNumber,\n            isSameCenterOnMap = leafletHelpers.isSameCenterOnMap,\n            safeApply = leafletHelpers.safeApply,\n            isValidCenter = leafletHelpers.isValidCenter,\n            isValidBounds = leafletBoundsHelpers.isValidBounds,\n            isUndefinedOrEmpty = leafletHelpers.isUndefinedOrEmpty,\n            errorHeader = leafletHelpers.errorHeader,\n            $log = leafletLogger;\n\n        var shouldInitializeMapWithBounds = function shouldInitializeMapWithBounds(bounds, center) {\n            return isDefined(bounds) && isValidBounds(bounds) && isUndefinedOrEmpty(center);\n        };\n\n        var _leafletCenter;\n        return {\n            restrict: \"A\",\n            scope: false,\n            replace: false,\n            require: 'leaflet',\n            controller: function controller() {\n                _leafletCenter = $q.defer();\n                this.getCenter = function () {\n                    return _leafletCenter.promise;\n                };\n            },\n            link: function link(scope, element, attrs, controller) {\n                var leafletScope = controller.getLeafletScope(),\n                    centerModel = leafletScope[directiveName];\n\n                controller.getMap().then(function (map) {\n                    var defaults = leafletMapDefaults.getDefaults(attrs.id);\n\n                    if (attrs[directiveName].search(\"-\") !== -1) {\n                        $log.error(errorHeader + ' The \"center\" variable can\\'t use a \"-\" on its key name: \"' + attrs[directiveName] + '\".');\n                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                        return;\n                    } else if (shouldInitializeMapWithBounds(leafletScope.bounds, centerModel)) {\n                        map.fitBounds(leafletBoundsHelpers.createLeafletBounds(leafletScope.bounds), leafletScope.bounds.options);\n                        centerModel = map.getCenter();\n                        safeApply(leafletScope, function (scope) {\n                            angular.extend(scope[directiveName], {\n                                lat: map.getCenter().lat,\n                                lng: map.getCenter().lng,\n                                zoom: map.getZoom(),\n                                autoDiscover: false\n                            });\n                        });\n                        safeApply(leafletScope, function (scope) {\n                            var mapBounds = map.getBounds();\n                            scope.bounds = {\n                                northEast: {\n                                    lat: mapBounds._northEast.lat,\n                                    lng: mapBounds._northEast.lng\n                                },\n                                southWest: {\n                                    lat: mapBounds._southWest.lat,\n                                    lng: mapBounds._southWest.lng\n                                }\n                            };\n                        });\n                    } else if (!isDefined(centerModel)) {\n                        $log.error(errorHeader + ' The \"center\" property is not defined in the main scope');\n                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                        return;\n                    } else if (!(isDefined(centerModel.lat) && isDefined(centerModel.lng)) && !isDefined(centerModel.autoDiscover)) {\n                        angular.copy(defaults.center, centerModel);\n                    }\n\n                    var urlCenterHash, mapReady;\n                    if (attrs.urlHashCenter === \"yes\") {\n                        var extractCenterFromUrl = function extractCenterFromUrl() {\n                            var search = $location.search();\n                            var centerParam;\n                            var centerKey = attrs.urlHashParam ? attrs.urlHashParam : 'c';\n                            if (isDefined(search[centerKey])) {\n                                var cParam = search[centerKey].split(\":\");\n                                if (cParam.length === 3) {\n                                    centerParam = {\n                                        lat: parseFloat(cParam[0]),\n                                        lng: parseFloat(cParam[1]),\n                                        zoom: parseInt(cParam[2], 10)\n                                    };\n                                }\n                            }\n                            return centerParam;\n                        };\n                        urlCenterHash = extractCenterFromUrl();\n\n                        leafletScope.$on('$locationChangeSuccess', function (event) {\n                            var scope = event.currentScope;\n                            //$log.debug(\"updated location...\");\n                            var urlCenter = extractCenterFromUrl();\n                            if (isDefined(urlCenter) && !isSameCenterOnMap(urlCenter, map)) {\n                                //$log.debug(\"updating center model...\", urlCenter);\n                                angular.extend(scope[directiveName], {\n                                    lat: urlCenter.lat,\n                                    lng: urlCenter.lng,\n                                    zoom: urlCenter.zoom\n                                });\n                            }\n                        });\n                    }\n\n                    leafletScope.$watch(directiveName, function (center) {\n                        if (leafletScope.settingCenterFromLeaflet) return;\n                        //$log.debug(\"updated center model...\");\n                        // The center from the URL has priority\n                        if (isDefined(urlCenterHash)) {\n                            angular.copy(urlCenterHash, center);\n                            urlCenterHash = undefined;\n                        }\n\n                        if (!isValidCenter(center) && center.autoDiscover !== true) {\n                            $log.warn(errorHeader + \" invalid 'center'\");\n                            //map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                            return;\n                        }\n\n                        if (center.autoDiscover === true) {\n                            if (!isNumber(center.zoom)) {\n                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                            }\n                            if (isNumber(center.zoom) && center.zoom > defaults.center.zoom) {\n                                map.locate({\n                                    setView: true,\n                                    maxZoom: center.zoom\n                                });\n                            } else if (isDefined(defaults.maxZoom)) {\n                                map.locate({\n                                    setView: true,\n                                    maxZoom: defaults.maxZoom\n                                });\n                            } else {\n                                map.locate({\n                                    setView: true\n                                });\n                            }\n                            return;\n                        }\n\n                        if (mapReady && isSameCenterOnMap(center, map)) {\n                            //$log.debug(\"no need to update map again.\");\n                            return;\n                        }\n\n                        //$log.debug(\"updating map center...\", center);\n                        leafletScope.settingCenterFromScope = true;\n                        map.setView([center.lat, center.lng], center.zoom);\n                        leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                        $timeout(function () {\n                            leafletScope.settingCenterFromScope = false;\n                            //$log.debug(\"allow center scope updates\");\n                        });\n                    }, true);\n\n                    map.whenReady(function () {\n                        mapReady = true;\n                    });\n\n                    map.on('moveend', function () /* event */{\n                        // Resolve the center after the first map position\n                        _leafletCenter.resolve();\n                        leafletMapEvents.notifyCenterUrlHashChanged(leafletScope, map, attrs, $location.search());\n                        //$log.debug(\"updated center on map...\");\n                        if (isSameCenterOnMap(centerModel, map) || leafletScope.settingCenterFromScope) {\n                            //$log.debug(\"same center in model, no need to update again.\");\n                            return;\n                        }\n                        leafletScope.settingCenterFromLeaflet = true;\n                        safeApply(leafletScope, function (scope) {\n                            if (!leafletScope.settingCenterFromScope) {\n                                //$log.debug(\"updating center model...\", map.getCenter(), map.getZoom());\n                                angular.extend(scope[directiveName], {\n                                    lat: map.getCenter().lat,\n                                    lng: map.getCenter().lng,\n                                    zoom: map.getZoom(),\n                                    autoDiscover: false\n                                });\n                            }\n                            leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                            $timeout(function () {\n                                leafletScope.settingCenterFromLeaflet = false;\n                            });\n                        });\n                    });\n\n                    if (centerModel.autoDiscover === true) {\n                        map.on('locationerror', function () {\n                            $log.warn(errorHeader + \" The Geolocation API is unauthorized on this page.\");\n                            if (isValidCenter(centerModel)) {\n                                map.setView([centerModel.lat, centerModel.lng], centerModel.zoom);\n                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                            } else {\n                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n    }];\n});\n\ncenterDirectiveTypes.forEach(function (dirType) {\n    angular.module('ui-leaflet').directive(dirType, centerDirectives[dirType]);\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('controls', function (leafletLogger, leafletHelpers, leafletControlHelpers) {\n    var $log = leafletLogger;\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: '?^leaflet',\n\n        link: function link(scope, element, attrs, controller) {\n            if (!controller) {\n                return;\n            }\n\n            var createControl = leafletControlHelpers.createControl;\n            var isValidControlType = leafletControlHelpers.isValidControlType;\n            var leafletScope = controller.getLeafletScope();\n            var isDefined = leafletHelpers.isDefined;\n            var isArray = leafletHelpers.isArray;\n            var leafletControls = {};\n            var errorHeader = leafletHelpers.errorHeader + ' [Controls] ';\n\n            scope.$on('$destroy', function () {\n                leafletControlHelpers.destroyMapLayersControl(scope.mapId);\n            });\n\n            controller.getMap().then(function (map) {\n\n                leafletScope.$watchCollection('controls', function (newControls) {\n\n                    // Delete controls from the array\n                    for (var name in leafletControls) {\n                        if (!isDefined(newControls[name])) {\n                            if (map.hasControl(leafletControls[name])) {\n                                map.removeControl(leafletControls[name]);\n                            }\n                            delete leafletControls[name];\n                        }\n                    }\n\n                    for (var newName in newControls) {\n                        var control;\n\n                        var controlType = isDefined(newControls[newName].type) ? newControls[newName].type : newName;\n\n                        if (!isValidControlType(controlType)) {\n                            $log.error(errorHeader + ' Invalid control type: ' + controlType + '.');\n                            return;\n                        }\n\n                        if (controlType !== 'custom') {\n                            control = createControl(controlType, newControls[newName]);\n                            map.addControl(control);\n                            leafletControls[newName] = control;\n                        } else {\n                            var customControlValue = newControls[newName];\n                            if (isArray(customControlValue)) {\n                                for (var i = 0; i < customControlValue.length; i++) {\n                                    var customControl = customControlValue[i];\n                                    map.addControl(customControl);\n                                    leafletControls[newName] = !isDefined(leafletControls[newName]) ? [customControl] : leafletControls[newName].concat([customControl]);\n                                }\n                            } else {\n                                map.addControl(customControlValue);\n                                leafletControls[newName] = customControlValue;\n                            }\n                        }\n                    }\n                });\n            });\n        }\n    };\n});\n","\"use strict\";\n\nangular.module('ui-leaflet').directive(\"decorations\", function (leafletLogger, leafletHelpers) {\n\tvar $log = leafletLogger;\n\treturn {\n\t\trestrict: \"A\",\n\t\tscope: false,\n\t\treplace: false,\n\t\trequire: 'leaflet',\n\n\t\tlink: function link(scope, element, attrs, controller) {\n\t\t\tvar leafletScope = controller.getLeafletScope(),\n\t\t\t    PolylineDecoratorPlugin = leafletHelpers.PolylineDecoratorPlugin,\n\t\t\t    isDefined = leafletHelpers.isDefined,\n\t\t\t    leafletDecorations = {};\n\n\t\t\t/* Creates an \"empty\" decoration with a set of coordinates, but no pattern. */\n\t\t\tfunction createDecoration(options) {\n\t\t\t\tif (isDefined(options) && isDefined(options.coordinates)) {\n\t\t\t\t\tif (!PolylineDecoratorPlugin.isLoaded()) {\n\t\t\t\t\t\t$log.error('[AngularJS - Leaflet] The PolylineDecorator Plugin is not loaded.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn L.polylineDecorator(options.coordinates);\n\t\t\t}\n\n\t\t\t/* Updates the path and the patterns for the provided decoration, and returns the decoration. */\n\t\t\tfunction setDecorationOptions(decoration, options) {\n\t\t\t\tif (isDefined(decoration) && isDefined(options)) {\n\t\t\t\t\tif (isDefined(options.coordinates) && isDefined(options.patterns)) {\n\t\t\t\t\t\tdecoration.setPaths(options.coordinates);\n\t\t\t\t\t\tdecoration.setPatterns(options.patterns);\n\t\t\t\t\t\treturn decoration;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontroller.getMap().then(function (map) {\n\t\t\t\tleafletScope.$watch(\"decorations\", function (newDecorations) {\n\t\t\t\t\tfor (var name in leafletDecorations) {\n\t\t\t\t\t\tif (!isDefined(newDecorations[name]) || !angular.equals(newDecorations[name], leafletDecorations)) {\n\t\t\t\t\t\t\tmap.removeLayer(leafletDecorations[name]);\n\t\t\t\t\t\t\tdelete leafletDecorations[name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var newName in newDecorations) {\n\t\t\t\t\t\tvar decorationData = newDecorations[newName],\n\t\t\t\t\t\t    newDecoration = createDecoration(decorationData);\n\n\t\t\t\t\t\tif (isDefined(newDecoration)) {\n\t\t\t\t\t\t\tleafletDecorations[newName] = newDecoration;\n\t\t\t\t\t\t\tmap.addLayer(newDecoration);\n\t\t\t\t\t\t\tsetDecorationOptions(newDecoration, decorationData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, true);\n\t\t\t});\n\t\t}\n\t};\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('eventBroadcast', function (leafletLogger, $rootScope, leafletHelpers, leafletMapEvents, leafletIterators) {\n    var $log = leafletLogger;\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function link(scope, element, attrs, controller) {\n            var isObject = leafletHelpers.isObject,\n                isDefined = leafletHelpers.isDefined,\n                leafletScope = controller.getLeafletScope(),\n                eventBroadcast = leafletScope.eventBroadcast,\n                availableMapEvents = leafletMapEvents.getAvailableMapEvents(),\n                addEvents = leafletMapEvents.addEvents;\n\n            controller.getMap().then(function (map) {\n\n                var mapEvents = [],\n                    logic = \"broadcast\";\n\n                // We have a possible valid object\n                if (!isDefined(eventBroadcast.map)) {\n                    // We do not have events enable/disable do we do nothing (all enabled by default)\n                    mapEvents = availableMapEvents;\n                } else if (!isObject(eventBroadcast.map)) {\n                    // Not a valid object\n                    $log.warn(\"[AngularJS - Leaflet] event-broadcast.map must be an object check your model.\");\n                } else {\n                    // We have a possible valid map object\n                    // Event propadation logic\n                    if (eventBroadcast.map.logic !== \"emit\" && eventBroadcast.map.logic !== \"broadcast\") {\n                        // This is an error\n                        $log.warn(\"[AngularJS - Leaflet] Available event propagation logic are: 'emit' or 'broadcast'.\");\n                    } else {\n                        logic = eventBroadcast.map.logic;\n                    }\n\n                    if (!(isObject(eventBroadcast.map.enable) && eventBroadcast.map.enable.length >= 0)) {\n                        $log.warn(\"[AngularJS - Leaflet] event-broadcast.map.enable must be an object check your model.\");\n                    } else {\n                        // Enable events\n                        leafletIterators.each(eventBroadcast.map.enable, function (eventName) {\n                            // Do we have already the event enabled?\n                            if (mapEvents.indexOf(eventName) === -1 && availableMapEvents.indexOf(eventName) !== -1) {\n                                mapEvents.push(eventName);\n                            }\n                        });\n                    }\n                }\n                // as long as the map is removed in the root leaflet directive we\n                // do not need ot clean up the events as leaflet does it itself\n                addEvents(map, attrs.id, mapEvents, \"eventName\", leafletScope, logic);\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('geojson', function ($timeout, leafletLogger, leafletData, leafletHelpers, leafletWatchHelpers, leafletDirectiveControlsHelpers, leafletIterators, leafletGeoJsonEvents) {\n    var _maybeWatch = leafletWatchHelpers.maybeWatch,\n        _defaultWatchOptions = leafletHelpers.watchOptions,\n        _extendDirectiveControls = leafletDirectiveControlsHelpers.extend,\n        hlp = leafletHelpers,\n        $it = leafletIterators,\n        watchTrap = { changeFromDirective: false };\n    // $log = leafletLogger;\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function link(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined,\n                leafletScope = controller.getLeafletScope(),\n                leafletGeoJSON = {},\n                _hasSetLeafletData = false;\n\n            controller.getMap().then(function (map) {\n                var watchOptions;\n                if (leafletScope.watchOptions && leafletScope.watchOptions.geojson) {\n                    watchOptions = leafletScope.watchOptions.geojson;\n                } else {\n                    watchOptions = _defaultWatchOptions;\n                }\n\n                var _hookUpEvents = function _hookUpEvents(geojson, maybeName) {\n                    var onEachFeature;\n\n                    if (angular.isFunction(geojson.onEachFeature)) {\n                        onEachFeature = geojson.onEachFeature;\n                    } else {\n                        onEachFeature = function onEachFeature(feature, layer) {\n                            if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(feature.properties.description)) {\n                                layer.bindLabel(feature.properties.description);\n                            }\n\n                            leafletGeoJsonEvents.bindEvents(attrs.id, layer, null, feature, leafletScope, maybeName, { resetStyleOnMouseout: geojson.resetStyleOnMouseout,\n                                mapId: attrs.id });\n                        };\n                    }\n                    return onEachFeature;\n                };\n\n                var isNested = hlp.isDefined(attrs.geojsonNested) && hlp.isTruthy(attrs.geojsonNested);\n\n                var _clean = function _clean() {\n                    if (!leafletGeoJSON) return;\n                    var _remove = function _remove(lObject) {\n                        if (isDefined(lObject) && map.hasLayer(lObject)) {\n                            map.removeLayer(lObject);\n                        }\n                    };\n                    if (isNested) {\n                        $it.each(leafletGeoJSON, function (lObject) {\n                            _remove(lObject);\n                        });\n                        return;\n                    }\n                    _remove(leafletGeoJSON);\n                };\n\n                var _addGeojson = function _addGeojson(geojson, maybeName) {\n\n                    if (!(isDefined(geojson) && isDefined(geojson.data))) {\n                        return;\n                    }\n                    var onEachFeature = _hookUpEvents(geojson, maybeName);\n\n                    if (!isDefined(geojson.options)) {\n                        hlp.modelChangeInDirective(watchTrap, \"changeFromDirective\", function () {\n                            geojson.options = {\n                                style: geojson.style,\n                                filter: geojson.filter,\n                                onEachFeature: onEachFeature,\n                                pointToLayer: geojson.pointToLayer\n                            };\n                        });\n                    }\n\n                    var lObject = L.geoJson(geojson.data, geojson.options);\n\n                    if (maybeName && hlp.isString(maybeName)) {\n                        leafletGeoJSON[maybeName] = lObject;\n                    } else {\n                        leafletGeoJSON = lObject;\n                    }\n\n                    lObject.addTo(map);\n\n                    if (!_hasSetLeafletData) {\n                        //only do this once and play with the same ref forever\n                        _hasSetLeafletData = true;\n                        leafletData.setGeoJSON(leafletGeoJSON, attrs.id);\n                    }\n                };\n\n                var _create = function _create(model) {\n                    _clean();\n                    if (isNested) {\n                        if (!model || !Object.keys(model).length) return;\n                        $it.each(model, function (m, name) {\n                            //name could be layerName and or groupName\n                            //for now it is not tied to a layer\n                            _addGeojson(m, name);\n                        });\n                        return;\n                    }\n                    _addGeojson(model);\n                };\n\n                _extendDirectiveControls(attrs.id, 'geojson', _create, _clean);\n\n                _maybeWatch(leafletScope, 'geojson', watchOptions, function (geojson) {\n                    if (watchTrap.changeFromDirective) return;\n                    _create(geojson);\n                });\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('layercontrol', function ($filter, leafletLogger, leafletData, leafletHelpers) {\n    var $log = leafletLogger;\n    return {\n        restrict: \"E\",\n        scope: {\n            icons: '=?',\n            autoHideOpacity: '=?', // Hide other opacity controls when one is activated.\n            showGroups: '=?', // Hide other opacity controls when one is activated.\n            title: '@',\n            baseTitle: '@',\n            overlaysTitle: '@'\n        },\n        replace: true,\n        transclude: false,\n        require: '^leaflet',\n        controller: function controller($scope, $element, $sce) {\n            $log.debug('[Angular Directive - Layers] layers', $scope, $element);\n            var safeApply = leafletHelpers.safeApply,\n                isDefined = leafletHelpers.isDefined;\n            angular.extend($scope, {\n                baselayer: '',\n                oldGroup: '',\n                layerProperties: {},\n                groupProperties: {},\n                rangeIsSupported: leafletHelpers.rangeIsSupported(),\n                changeBaseLayer: function changeBaseLayer(key, e) {\n                    leafletHelpers.safeApply($scope, function (scp) {\n                        scp.baselayer = key;\n                        leafletData.getMap().then(function (map) {\n                            leafletData.getLayers().then(function (leafletLayers) {\n                                if (map.hasLayer(leafletLayers.baselayers[key])) {\n                                    return;\n                                }\n                                for (var i in scp.layers.baselayers) {\n                                    scp.layers.baselayers[i].icon = scp.icons.unradio;\n                                    if (map.hasLayer(leafletLayers.baselayers[i])) {\n                                        map.removeLayer(leafletLayers.baselayers[i]);\n                                    }\n                                }\n                                map.addLayer(leafletLayers.baselayers[key]);\n                                scp.layers.baselayers[key].icon = $scope.icons.radio;\n                            });\n                        });\n                    });\n                    e.preventDefault();\n                },\n                moveLayer: function moveLayer(ly, newIndex, e) {\n                    var delta = Object.keys($scope.layers.baselayers).length;\n                    if (newIndex >= 1 + delta && newIndex <= $scope.overlaysArray.length + delta) {\n                        var oldLy;\n                        for (var key in $scope.layers.overlays) {\n                            if ($scope.layers.overlays[key].index === newIndex) {\n                                oldLy = $scope.layers.overlays[key];\n                                break;\n                            }\n                        }\n                        if (oldLy) {\n                            safeApply($scope, function () {\n                                oldLy.index = ly.index;\n                                ly.index = newIndex;\n                            });\n                        }\n                    }\n                    e.stopPropagation();\n                    e.preventDefault();\n                },\n                initIndex: function initIndex(layer, idx) {\n                    var delta = Object.keys($scope.layers.baselayers).length;\n                    layer.index = isDefined(layer.index) ? layer.index : idx + delta + 1;\n                },\n                initGroup: function initGroup(groupName) {\n                    $scope.groupProperties[groupName] = $scope.groupProperties[groupName] ? $scope.groupProperties[groupName] : {};\n                },\n                toggleOpacity: function toggleOpacity(e, layer) {\n                    if (layer.visible) {\n                        if ($scope.autoHideOpacity && !$scope.layerProperties[layer.name].opacityControl) {\n                            for (var k in $scope.layerProperties) {\n                                $scope.layerProperties[k].opacityControl = false;\n                            }\n                        }\n                        $scope.layerProperties[layer.name].opacityControl = !$scope.layerProperties[layer.name].opacityControl;\n                    }\n                    e.stopPropagation();\n                    e.preventDefault();\n                },\n                toggleLegend: function toggleLegend(layer) {\n                    $scope.layerProperties[layer.name].showLegend = !$scope.layerProperties[layer.name].showLegend;\n                },\n                showLegend: function showLegend(layer) {\n                    return layer.legend && $scope.layerProperties[layer.name].showLegend;\n                },\n                unsafeHTML: function unsafeHTML(html) {\n                    return $sce.trustAsHtml(html);\n                },\n                getOpacityIcon: function getOpacityIcon(layer) {\n                    return layer.visible && $scope.layerProperties[layer.name].opacityControl ? $scope.icons.close : $scope.icons.open;\n                },\n                getGroupIcon: function getGroupIcon(group) {\n                    return group.visible ? $scope.icons.check : $scope.icons.uncheck;\n                },\n                changeGroupVisibility: function changeGroupVisibility(groupName) {\n                    if (!isDefined($scope.groupProperties[groupName])) {\n                        return;\n                    }\n                    var visible = $scope.groupProperties[groupName].visible;\n                    for (var k in $scope.layers.overlays) {\n                        var layer = $scope.layers.overlays[k];\n                        if (layer.group === groupName) {\n                            layer.visible = visible;\n                        }\n                    }\n                }\n            });\n\n            var div = $element.get(0);\n            if (!L.Browser.touch) {\n                L.DomEvent.disableClickPropagation(div);\n                L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);\n            } else {\n                L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);\n            }\n        },\n        template: '<div class=\"angular-leaflet-control-layers\" ng-show=\"overlaysArray.length\">' + '<h4 ng-if=\"title\">{{ title }}</h4>' + '<div class=\"lf-baselayers\">' + '<h5 class=\"lf-title\" ng-if=\"baseTitle\">{{ baseTitle }}</h5>' + '<div class=\"lf-row\" ng-repeat=\"(key, layer) in baselayersArray\">' + '<label class=\"lf-icon-bl\" ng-click=\"changeBaseLayer(key, $event)\">' + '<input class=\"leaflet-control-layers-selector\" type=\"radio\" name=\"lf-radio\" ' + 'ng-show=\"false\" ng-checked=\"baselayer === key\" ng-value=\"key\" /> ' + '<i class=\"lf-icon lf-icon-radio\" ng-class=\"layer.icon\"></i>' + '<div class=\"lf-text\">{{layer.name}}</div>' + '</label>' + '</div>' + '</div>' + '<div class=\"lf-overlays\">' + '<h5 class=\"lf-title\" ng-if=\"overlaysTitle\">{{ overlaysTitle }}</h5>' + '<div class=\"lf-container\">' + '<div class=\"lf-row\" ng-repeat=\"layer in (o = (overlaysArray | orderBy:\\'index\\':order))\" ng-init=\"initIndex(layer, $index)\">' + '<label class=\"lf-icon-ol-group\" ng-if=\"showGroups &amp;&amp; layer.group &amp;&amp; layer.group != o[$index-1].group\">' + '<input class=\"lf-control-layers-selector\" type=\"checkbox\" ng-show=\"false\" ' + 'ng-change=\"changeGroupVisibility(layer.group)\" ng-model=\"groupProperties[layer.group].visible\"/> ' + '<i class=\"lf-icon lf-icon-check\" ng-class=\"getGroupIcon(groupProperties[layer.group])\"></i>' + '<div class=\"lf-text\">{{ layer.group }}</div>' + '</label>' + '<label class=\"lf-icon-ol\">' + '<input class=\"lf-control-layers-selector\" type=\"checkbox\" ng-show=\"false\" ng-model=\"layer.visible\"/> ' + '<i class=\"lf-icon lf-icon-check\" ng-class=\"layer.icon\"></i>' + '<div class=\"lf-text\">{{layer.name}}</div>' + '</label>' + '<div class=\"lf-icons\">' + '<i class=\"lf-icon lf-up\" ng-class=\"icons.up\" ng-click=\"moveLayer(layer, layer.index - orderNumber, $event)\"></i> ' + '<i class=\"lf-icon lf-down\" ng-class=\"icons.down\" ng-click=\"moveLayer(layer, layer.index + orderNumber, $event)\"></i> ' + '<i class=\"lf-icon lf-toggle-legend\" ng-class=\"icons.toggleLegend\" ng-if=\"layer.legend\" ng-click=\"toggleLegend(layer)\"></i> ' + '<i class=\"lf-icon lf-open\" ng-class=\"getOpacityIcon(layer)\" ng-click=\"toggleOpacity($event, layer)\"></i>' + '</div>' + '<div class=\"lf-legend\" ng-if=\"showLegend(layer)\" ng-bind-html=\"unsafeHTML(layer.legend)\"></div>' + '<div class=\"lf-opacity clearfix\" ng-if=\"layer.visible &amp;&amp; layerProperties[layer.name].opacityControl\">' + '<label ng-if=\"rangeIsSupported\" class=\"pull-left\" style=\"width: 50%\">0</label>' + '<label ng-if=\"rangeIsSupported\" class=\"pull-left text-right\" style=\"width: 50%\">100</label>' + '<input ng-if=\"rangeIsSupported\" class=\"clearfix\" type=\"range\" min=\"0\" max=\"1\" step=\"0.05\" ' + 'class=\"lf-opacity-control\" ng-model=\"layerProperties[layer.name].layerOptions.opacity\"/>' + '<h6 ng-if=\"!rangeIsSupported\">Range is not supported in this browser</h6>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>',\n        link: function link(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined,\n                leafletScope = controller.getLeafletScope(),\n                layers = leafletScope.layers;\n\n            scope.$watch('icons', function () {\n                var defaultIcons = {\n                    uncheck: 'fa fa-square-o',\n                    check: 'fa fa-check-square-o',\n                    radio: 'fa fa-dot-circle-o',\n                    unradio: 'fa fa-circle-o',\n                    up: 'fa fa-angle-up',\n                    down: 'fa fa-angle-down',\n                    open: 'fa fa-angle-double-down',\n                    close: 'fa fa-angle-double-up',\n                    toggleLegend: 'fa fa-pencil-square-o'\n                };\n                if (isDefined(scope.icons)) {\n                    angular.extend(defaultIcons, scope.icons);\n                    angular.extend(scope.icons, defaultIcons);\n                } else {\n                    scope.icons = defaultIcons;\n                }\n            });\n\n            // Setting layer stack order.\n            attrs.order = isDefined(attrs.order) && (attrs.order === 'normal' || attrs.order === 'reverse') ? attrs.order : 'normal';\n            scope.order = attrs.order === 'normal';\n            scope.orderNumber = attrs.order === 'normal' ? -1 : 1;\n\n            scope.layers = layers;\n            controller.getMap().then(function (map) {\n                leafletScope.$watch('layers.baselayers', function (newBaseLayers) {\n                    var baselayersArray = {};\n                    leafletData.getLayers().then(function (leafletLayers) {\n                        var key;\n                        for (key in newBaseLayers) {\n                            var layer = newBaseLayers[key];\n                            layer.icon = scope.icons[map.hasLayer(leafletLayers.baselayers[key]) ? 'radio' : 'unradio'];\n                            baselayersArray[key] = layer;\n                        }\n                        scope.baselayersArray = baselayersArray;\n                    });\n                });\n\n                leafletScope.$watch('layers.overlays', function (newOverlayLayers) {\n                    var overlaysArray = [];\n                    var groupVisibleCount = {};\n                    leafletData.getLayers().then(function () {\n                        var key;\n                        for (key in newOverlayLayers) {\n                            var layer = newOverlayLayers[key];\n                            layer.icon = scope.icons[layer.visible ? 'check' : 'uncheck'];\n                            overlaysArray.push(layer);\n\n                            if (!isDefined(scope.layerProperties[layer.name])) {\n                                if (isDefined(layer.layerOptions.opacity)) {\n                                    layer.layerOptions.opacity = 1;\n                                }\n                                scope.layerProperties[layer.name] = {\n                                    opacityControl: false,\n                                    showLegend: true,\n                                    layerOptions: layer.layerOptions\n                                };\n                            }\n                            if (isDefined(layer.group)) {\n                                if (!isDefined(scope.groupProperties[layer.group])) {\n                                    scope.groupProperties[layer.group] = {\n                                        visible: false\n                                    };\n                                }\n                                groupVisibleCount[layer.group] = isDefined(groupVisibleCount[layer.group]) ? groupVisibleCount[layer.group] : {\n                                    count: 0,\n                                    visibles: 0\n                                };\n                                groupVisibleCount[layer.group].count++;\n                                if (layer.visible) {\n                                    groupVisibleCount[layer.group].visibles++;\n                                }\n                            }\n                            /*\n                            if(isDefined(layer.index) && leafletLayers.overlays[key].setZIndex) {\n                                leafletLayers.overlays[key].setZIndex(newOverlayLayers[key].index);\n                            }\n                            */\n                        }\n\n                        for (key in groupVisibleCount) {\n                            scope.groupProperties[key].visible = groupVisibleCount[key].visibles === groupVisibleCount[key].count;\n                        }\n                        scope.overlaysArray = overlaysArray;\n                    });\n                }, true);\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('layers', function (leafletLogger, $q, leafletData, leafletHelpers, leafletLayerHelpers, leafletControlHelpers) {\n    // var $log = leafletLogger;\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n        controller: function controller($scope) {\n            $scope._leafletLayers = $q.defer();\n            this.getLayers = function () {\n                return $scope._leafletLayers.promise;\n            };\n        },\n        link: function link(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined,\n                leafletLayers = {},\n                leafletScope = controller.getLeafletScope(),\n                layers = leafletScope.layers,\n                createLayer = leafletLayerHelpers.createLayer,\n                safeAddLayer = leafletLayerHelpers.safeAddLayer,\n                safeRemoveLayer = leafletLayerHelpers.safeRemoveLayer,\n                changeOpacityListener = leafletLayerHelpers.changeOpacityListener,\n                updateLayersControl = leafletControlHelpers.updateLayersControl,\n                isLayersControlVisible = false;\n\n            scope.$on('$destroy', function () {\n                leafletControlHelpers.destroyMapLayersControl(scope.mapId);\n            });\n\n            controller.getMap().then(function (map) {\n\n                // We have baselayers to add to the map\n                scope._leafletLayers.resolve(leafletLayers);\n                leafletData.setLayers(leafletLayers, attrs.id);\n\n                leafletLayers.baselayers = {};\n                leafletLayers.overlays = {};\n\n                var mapId = attrs.id;\n\n                // Setup all baselayers definitions\n                var oneVisibleLayer = false;\n                for (var layerName in layers.baselayers) {\n                    var newBaseLayer = createLayer(layers.baselayers[layerName]);\n                    if (!isDefined(newBaseLayer)) {\n                        delete layers.baselayers[layerName];\n                        continue;\n                    }\n                    leafletLayers.baselayers[layerName] = newBaseLayer;\n                    // Only add the visible layer to the map, layer control manages the addition to the map\n                    // of layers in its control\n                    if (layers.baselayers[layerName].top === true) {\n                        safeAddLayer(map, leafletLayers.baselayers[layerName]);\n                        oneVisibleLayer = true;\n                    }\n                }\n\n                // If there is no visible layer add first to the map\n                if (!oneVisibleLayer && Object.keys(leafletLayers.baselayers).length > 0) {\n                    safeAddLayer(map, leafletLayers.baselayers[Object.keys(layers.baselayers)[0]]);\n                }\n\n                // Setup the Overlays\n                for (layerName in layers.overlays) {\n                    if (layers.overlays[layerName].type === 'cartodb') {}\n                    var newOverlayLayer = createLayer(layers.overlays[layerName]);\n                    if (!isDefined(newOverlayLayer)) {\n                        delete layers.overlays[layerName];\n                        continue;\n                    }\n                    leafletLayers.overlays[layerName] = newOverlayLayer;\n                    // Only add the visible overlays to the map\n                    if (layers.overlays[layerName].visible === true) {\n                        safeAddLayer(map, leafletLayers.overlays[layerName]);\n                    }\n                }\n\n                // Watch for the base layers\n                leafletScope.$watch('layers.baselayers', function (newBaseLayers, oldBaseLayers) {\n                    if (angular.equals(newBaseLayers, oldBaseLayers)) {\n                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);\n                        return true;\n                    }\n                    // Delete layers from the array\n                    for (var name in leafletLayers.baselayers) {\n                        if (!isDefined(newBaseLayers[name]) || newBaseLayers[name].doRefresh) {\n                            // Remove from the map if it's on it\n                            if (map.hasLayer(leafletLayers.baselayers[name])) {\n                                map.removeLayer(leafletLayers.baselayers[name]);\n                            }\n                            delete leafletLayers.baselayers[name];\n\n                            if (newBaseLayers[name] && newBaseLayers[name].doRefresh) {\n                                newBaseLayers[name].doRefresh = false;\n                            }\n                        }\n                    }\n                    // add new layers\n                    for (var newName in newBaseLayers) {\n                        if (!isDefined(leafletLayers.baselayers[newName])) {\n                            var testBaseLayer = createLayer(newBaseLayers[newName]);\n                            if (isDefined(testBaseLayer)) {\n                                leafletLayers.baselayers[newName] = testBaseLayer;\n                                // Only add the visible layer to the map\n                                if (newBaseLayers[newName].top === true) {\n                                    safeAddLayer(map, leafletLayers.baselayers[newName]);\n                                }\n                            }\n                        } else {\n                            if (newBaseLayers[newName].top === true && !map.hasLayer(leafletLayers.baselayers[newName])) {\n                                safeAddLayer(map, leafletLayers.baselayers[newName]);\n                            } else if (newBaseLayers[newName].top === false && map.hasLayer(leafletLayers.baselayers[newName])) {\n                                map.removeLayer(leafletLayers.baselayers[newName]);\n                            }\n                        }\n                    }\n\n                    //we have layers, so we need to make, at least, one active\n                    var found = false;\n                    // search for an active layer\n                    for (var key in leafletLayers.baselayers) {\n                        if (map.hasLayer(leafletLayers.baselayers[key])) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    // If there is no active layer make one active\n                    if (!found && Object.keys(leafletLayers.baselayers).length > 0) {\n                        safeAddLayer(map, leafletLayers.baselayers[Object.keys(leafletLayers.baselayers)[0]]);\n                    }\n\n                    // Only show the layers switch selector control if we have more than one baselayer + overlay\n                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);\n                }, true);\n\n                // Watch for the overlay layers\n                leafletScope.$watch('layers.overlays', function (newOverlayLayers, oldOverlayLayers) {\n                    if (angular.equals(newOverlayLayers, oldOverlayLayers)) {\n                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);\n                        return true;\n                    }\n\n                    // Delete layers from the array\n                    for (var name in leafletLayers.overlays) {\n                        if (!isDefined(newOverlayLayers[name]) || newOverlayLayers[name].doRefresh) {\n                            // Remove from the map if it's on it\n                            if (map.hasLayer(leafletLayers.overlays[name])) {\n                                // Safe remove when ArcGIS layers is loading.\n                                var options = isDefined(newOverlayLayers[name]) ? newOverlayLayers[name].layerOptions : null;\n                                safeRemoveLayer(map, leafletLayers.overlays[name], options);\n                            }\n                            // TODO: Depending on the layer type we will have to delete what's included on it\n                            delete leafletLayers.overlays[name];\n\n                            if (newOverlayLayers[name] && newOverlayLayers[name].doRefresh) {\n                                newOverlayLayers[name].doRefresh = false;\n                            }\n                        }\n                    }\n\n                    // add new overlays\n                    for (var newName in newOverlayLayers) {\n                        if (!isDefined(leafletLayers.overlays[newName])) {\n                            var testOverlayLayer = createLayer(newOverlayLayers[newName]);\n                            if (!isDefined(testOverlayLayer)) {\n                                // If the layer creation fails, continue to the next overlay\n                                continue;\n                            }\n                            leafletLayers.overlays[newName] = testOverlayLayer;\n                            if (newOverlayLayers[newName].visible === true) {\n                                safeAddLayer(map, leafletLayers.overlays[newName]);\n                            }\n\n                            if (isDefined(newOverlayLayers[newName].index) && leafletLayers.overlays[newName].setZIndex) {\n                                leafletLayers.overlays[newName].setZIndex(newOverlayLayers[newName].index);\n                            }\n                        } else {\n                            // check for the .visible property to hide/show overLayers\n                            if (newOverlayLayers[newName].visible && !map.hasLayer(leafletLayers.overlays[newName])) {\n                                safeAddLayer(map, leafletLayers.overlays[newName]);\n                            } else if (newOverlayLayers[newName].visible === false && map.hasLayer(leafletLayers.overlays[newName])) {\n                                // Safe remove when ArcGIS layers is loading.\n                                safeRemoveLayer(map, leafletLayers.overlays[newName], newOverlayLayers[newName].layerOptions);\n                            }\n\n                            // check for the .layerOptions.opacity property has changed.\n                            var ly = leafletLayers.overlays[newName];\n                            if (map.hasLayer(leafletLayers.overlays[newName])) {\n                                if (newOverlayLayers[newName].layerOptions.opacity !== oldOverlayLayers[newName].layerOptions.opacity) {\n\n                                    if (isDefined(ly.setOpacity)) {\n                                        ly.setOpacity(newOverlayLayers[newName].layerOptions.opacity);\n                                    }\n                                    if (isDefined(ly.getLayers) && isDefined(ly.eachLayer)) {\n                                        ly.eachLayer(changeOpacityListener(newOverlayLayers[newName].layerOptions.opacity));\n                                    }\n                                }\n\n                                if (isDefined(newOverlayLayers[newName].index) && ly.setZIndex && newOverlayLayers[newName].index !== oldOverlayLayers[newName].index) {\n                                    ly.setZIndex(newOverlayLayers[newName].index);\n                                }\n                            }\n                        }\n\n                        //refresh heatmap data if present\n                        if (newOverlayLayers[newName].visible && map._loaded && newOverlayLayers[newName].data && newOverlayLayers[newName].type === \"heatmap\") {\n                            leafletLayers.overlays[newName].setData(newOverlayLayers[newName].data);\n                            leafletLayers.overlays[newName].update();\n                        }\n                    }\n\n                    // Only add the layers switch selector control if we have more than one baselayer + overlay\n                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);\n                }, true);\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module(\"ui-leaflet\").directive('legend', function (leafletLogger, $http, $timeout, leafletHelpers, leafletLegendHelpers) {\n    var $log = leafletLogger,\n        errorHeader = leafletHelpers.errorHeader + ' [Legend] ';\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n        transclude: false,\n\n        link: function link(scope, element, attrs, controller) {\n\n            var isArray = leafletHelpers.isArray,\n                isString = leafletHelpers.isString,\n                isDefined = leafletHelpers.isDefined,\n                isFunction = leafletHelpers.isFunction,\n                leafletScope = controller.getLeafletScope(),\n                legend = leafletScope.legend;\n\n            var legendClass;\n            var position;\n            var leafletLegend;\n            var type;\n\n            leafletScope.$watch('legend', function (newLegend) {\n\n                if (isDefined(newLegend)) {\n                    legendClass = newLegend.legendClass ? newLegend.legendClass : \"legend\";\n                    position = newLegend.position || 'bottomright';\n                    // default to arcgis\n                    type = newLegend.type || 'arcgis';\n                }\n            }, true);\n\n            var createLegend = function createLegend(map, legendData, newURL) {\n                if (legendData && legendData.layers && legendData.layers.length > 0) {\n                    if (isDefined(leafletLegend)) {\n                        leafletLegendHelpers.updateLegend(leafletLegend.getContainer(), legendData, type, newURL);\n                    } else {\n                        leafletLegend = L.control({\n                            position: position\n                        });\n                        leafletLegend.onAdd = leafletLegendHelpers.getOnAddLegend(legendData, legendClass, type, newURL);\n                        leafletLegend.addTo(map);\n                    }\n\n                    if (isDefined(legend.loadedData) && isFunction(legend.loadedData)) {\n                        legend.loadedData();\n                    }\n                }\n            };\n\n            controller.getMap().then(function (map) {\n                leafletScope.$watch('legend', function (newLegend) {\n                    if (!isDefined(newLegend)) {\n                        if (isDefined(leafletLegend)) {\n                            leafletLegend.removeFrom(map);\n                            leafletLegend = null;\n                        }\n\n                        return;\n                    }\n\n                    if (!isDefined(newLegend.url) && type === 'arcgis' && (!isArray(newLegend.colors) || !isArray(newLegend.labels) || newLegend.colors.length !== newLegend.labels.length)) {\n                        $log.warn(errorHeader + \" legend.colors and legend.labels must be set.\");\n                        return;\n                    }\n\n                    if (isDefined(newLegend.url)) {\n                        $log.info(errorHeader + \" loading legend service.\");\n                        return;\n                    }\n\n                    if (isDefined(leafletLegend)) {\n                        leafletLegend.removeFrom(map);\n                        leafletLegend = null;\n                    }\n\n                    leafletLegend = L.control({\n                        position: position\n                    });\n\n                    if (type === 'arcgis') {\n                        leafletLegend.onAdd = leafletLegendHelpers.getOnAddArrayLegend(newLegend, legendClass);\n                    }\n                    leafletLegend.addTo(map);\n                });\n\n                leafletScope.$watch('legend.url', function (newURL) {\n                    if (!isDefined(newURL)) {\n                        return;\n                    }\n\n                    if (!isArray(newURL) && !isString(newURL)) {\n                        $log.warn(errorHeader + \" legend.url must be an array or string.\");\n                        return;\n                    }\n\n                    var urls = isString(newURL) ? [newURL] : newURL;\n\n                    var legendData;\n                    var onResult = function onResult(idx, url) {\n                        return function (ld) {\n                            if (isDefined(ld.data.error)) {\n                                $log.warn(errorHeader + 'Error loadin legend from: ' + url, ld.data.error.message);\n                            } else {\n                                if (legendData && legendData.layers && legendData.layers.length > 0) {\n                                    legendData.layers = legendData.layers.concat(ld.data.layers);\n                                } else {\n                                    legendData = ld.data;\n                                }\n                            }\n\n                            if (idx === urls.length - 1) {\n                                createLegend(map, legendData, newURL);\n                            }\n                        };\n                    };\n                    var onError = function onError(err) {\n                        $log.warn(errorHeader + ' legend.url not loaded.', err);\n                    };\n\n                    for (var i = 0; i < urls.length; i++) {\n                        leafletLegendHelpers.addLegendURL(attrs.id, {\n                            url: urls[i],\n                            method: 'GET'\n                        }).then(onResult(i)).catch(onError);\n                    }\n                });\n\n                leafletScope.$watch('legend.legendData', function (legendData) {\n                    $log.debug('legendData', legendData);\n                    if (isDefined(leafletScope.legend.url) || !isDefined(legendData)) {\n                        return;\n                    }\n\n                    createLegend(map, legendData);\n                }, true);\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('markers', function (leafletLogger, $rootScope, $q, leafletData, leafletHelpers, leafletMapDefaults, leafletMarkersHelpers, leafletMarkerEvents, leafletIterators, leafletWatchHelpers, leafletDirectiveControlsHelpers) {\n    //less terse vars to helpers\n    var isDefined = leafletHelpers.isDefined,\n        errorHeader = leafletHelpers.errorHeader,\n        Helpers = leafletHelpers,\n        isString = leafletHelpers.isString,\n        addMarkerWatcher = leafletMarkersHelpers.addMarkerWatcher,\n        updateMarker = leafletMarkersHelpers.updateMarker,\n        listenMarkerEvents = leafletMarkersHelpers.listenMarkerEvents,\n        addMarkerToGroup = leafletMarkersHelpers.addMarkerToGroup,\n        createMarker = leafletMarkersHelpers.createMarker,\n        deleteMarker = leafletMarkersHelpers.deleteMarker,\n        getModelFromModels = leafletMarkersHelpers.getModelFromModels,\n        getLayerModels = leafletMarkersHelpers.getLayerModels,\n        resetUnusedMarkerGroups = leafletMarkersHelpers.resetUnusedMarkerGroups,\n        $it = leafletIterators,\n        _defaultWatchOptions = leafletHelpers.watchOptions,\n        maybeWatch = leafletWatchHelpers.maybeWatch,\n        extendDirectiveControls = leafletDirectiveControlsHelpers.extend,\n        $log = leafletLogger,\n        watchTrap = { changeFromDirective: false };\n\n    var _getLMarker = function _getLMarker(leafletMarkers, name, maybeLayerName) {\n        if (!Object.keys(leafletMarkers).length) return;\n        if (maybeLayerName && isString(maybeLayerName)) {\n            if (!leafletMarkers[maybeLayerName] || !Object.keys(leafletMarkers[maybeLayerName]).length) return;\n            return leafletMarkers[maybeLayerName][name];\n        }\n        return leafletMarkers[name];\n    };\n\n    var _setLMarker = function _setLMarker(lObject, leafletMarkers, name, maybeLayerName) {\n        if (maybeLayerName && isString(maybeLayerName)) {\n            if (!isDefined(leafletMarkers[maybeLayerName])) leafletMarkers[maybeLayerName] = {};\n            leafletMarkers[maybeLayerName][name] = lObject;\n        } else leafletMarkers[name] = lObject;\n        return lObject;\n    };\n\n    var _maybeAddMarkerToLayer = function _maybeAddMarkerToLayer(layerName, layers, model, marker, watchType, map) {\n\n        if (!isString(layerName)) {\n            $log.error(errorHeader + ' A layername must be a string');\n            return false;\n        }\n\n        if (!isDefined(layers)) {\n            $log.error(errorHeader + ' You must add layers to the directive if the markers are going to use this functionality.');\n            return false;\n        }\n\n        if (!isDefined(layers.overlays) || !isDefined(layers.overlays[layerName])) {\n            $log.error(errorHeader + ' A marker can only be added to a layer of type \"group\"');\n            return false;\n        }\n        var layerGroup = layers.overlays[layerName];\n        if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {\n            $log.error(errorHeader + ' Adding a marker to an overlay needs a overlay of the type \"group\" or \"featureGroup\"');\n            return false;\n        }\n\n        // The marker goes to a correct layer group, so first of all we add it\n        layerGroup.addLayer(marker);\n\n        // The marker is automatically added to the map depending on the visibility\n        // of the layer, so we only have to open the popup if the marker is in the map\n        if (watchType === null && map.hasLayer(marker) && model.focus === true) {\n            marker.openPopup();\n        }\n        return true;\n    };\n    //TODO: move to leafletMarkersHelpers??? or make a new class/function file (leafletMarkersHelpers is large already)\n    var _addMarkers = function _addMarkers(mapId, markersToRender, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, maybeLayerName, skips) {\n        $it.each(markersToRender, function (model, newName) {\n            if (skips[newName]) return;\n\n            if (newName.search(\"-\") !== -1) {\n                $log.error('The marker can\\'t use a \"-\" on his key name: \"' + newName + '\".');\n                return;\n            }\n\n            var pathToMarker = Helpers.getObjectDotPath(maybeLayerName ? [maybeLayerName, newName] : [newName]);\n            var maybeLMarker = _getLMarker(leafletMarkers, newName, maybeLayerName);\n            Helpers.modelChangeInDirective(watchTrap, \"changeFromDirective\", function () {\n                if (!isDefined(maybeLMarker)) {\n\n                    var marker = createMarker(model);\n                    var layerName = (model ? model.layer : undefined) || maybeLayerName; //original way takes pref\n                    if (!isDefined(marker)) {\n                        $log.error(errorHeader + ' Received invalid data on the marker ' + newName + '.');\n                        return;\n                    }\n                    _setLMarker(marker, leafletMarkers, newName, maybeLayerName);\n\n                    // Bind message\n                    if (isDefined(model.message)) {\n                        marker.bindPopup(model.message, model.popupOptions);\n                    }\n\n                    // Add the marker to a cluster group if needed\n                    if (isDefined(model.group)) {\n                        var groupOptions = isDefined(model.groupOption) ? model.groupOption : null;\n                        addMarkerToGroup(marker, model.group, groupOptions, map);\n                    }\n\n                    // Show label if defined\n                    if (Helpers.LabelPlugin.isLoaded() && isDefined(model.label) && isDefined(model.label.message)) {\n                        marker.bindLabel(model.label.message, model.label.options);\n                    }\n\n                    // Check if the marker should be added to a layer\n                    if (isDefined(model) && (isDefined(model.layer) || isDefined(maybeLayerName))) {\n\n                        var pass = _maybeAddMarkerToLayer(layerName, layers, model, marker, watchOptions.individual.type, map);\n                        if (!pass) return; //something went wrong move on in the loop\n                    } else if (!isDefined(model.group)) {\n                        // We do not have a layer attr, so the marker goes to the map layer\n                        map.addLayer(marker);\n                        if (watchOptions.individual.type === null && model.focus === true) {\n                            marker.openPopup();\n                        }\n                    }\n\n                    if (watchOptions.individual.type !== null) {\n                        addMarkerWatcher(marker, pathToMarker, leafletScope, layers, map, watchOptions.individual);\n                    }\n\n                    listenMarkerEvents(marker, model, leafletScope, watchOptions.individual.type, map);\n                    leafletMarkerEvents.bindEvents(mapId, marker, pathToMarker, model, leafletScope, layerName);\n                } else {\n                    var oldModel = getModelFromModels(oldModels, newName, maybeLayerName);\n                    updateMarker(model, oldModel, maybeLMarker, pathToMarker, leafletScope, layers, map);\n                }\n            });\n        });\n    };\n    var _seeWhatWeAlreadyHave = function _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, isEqual, cb) {\n        var hasLogged = false,\n            equals = false,\n            oldMarker,\n            newMarker;\n\n        var doCheckOldModel = isDefined(oldMarkerModels);\n        for (var name in lMarkers) {\n            if (!hasLogged) {\n                $log.debug(errorHeader + \"[markers] destroy: \");\n                hasLogged = true;\n            }\n\n            if (doCheckOldModel) {\n                //might want to make the option (in watch options) to disable deep checking\n                //ie the options to only check !== (reference check) instead of angular.equals (slow)\n                newMarker = markerModels[name];\n                oldMarker = oldMarkerModels[name];\n                equals = isEqual && angular.equals(newMarker, oldMarker);\n            }\n            if (!isDefined(markerModels) || !Object.keys(markerModels).length || !isDefined(markerModels[name]) || !Object.keys(markerModels[name]).length || equals) {\n                if (cb && Helpers.isFunction(cb)) cb(newMarker, oldMarker, name);\n            }\n        }\n    };\n    var _destroy = function _destroy(markerModels, oldMarkerModels, lMarkers, map, layers) {\n        _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, false, function (newMarker, oldMarker, lMarkerName) {\n            $log.debug(errorHeader + '[marker] is deleting marker: ' + lMarkerName);\n            deleteMarker(lMarkers[lMarkerName], map, layers);\n            delete lMarkers[lMarkerName];\n        });\n    };\n\n    var _getNewModelsToSkipp = function _getNewModelsToSkipp(newModels, oldModels, lMarkers) {\n        var skips = {};\n        _seeWhatWeAlreadyHave(newModels, oldModels, lMarkers, true, function (newMarker, oldMarker, lMarkerName) {\n            $log.debug(errorHeader + '[marker] is already rendered, marker: ' + lMarkerName);\n            skips[lMarkerName] = newMarker;\n        });\n        return skips;\n    };\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: ['leaflet', '?layers'],\n\n        link: function link(scope, element, attrs, controller) {\n            var mapController = controller[0],\n                leafletScope = mapController.getLeafletScope();\n\n            mapController.getMap().then(function (map) {\n                var leafletMarkers = {},\n                    getLayers;\n\n                // If the layers attribute is used, we must wait until the layers are created\n                if (isDefined(controller[1])) {\n                    getLayers = controller[1].getLayers;\n                } else {\n                    getLayers = function getLayers() {\n                        var deferred = $q.defer();\n                        deferred.resolve();\n                        return deferred.promise;\n                    };\n                }\n\n                var watchOptions;\n                if (leafletScope.watchOptions && leafletScope.watchOptions.markers) {\n                    watchOptions = leafletScope.watchOptions.markers;\n                } else {\n                    watchOptions = _defaultWatchOptions;\n                }\n\n                var isNested = isDefined(attrs.markersNested) && Helpers.isTruthy(attrs.markersNested);\n\n                getLayers().then(function (layers) {\n                    var _clean = function _clean(models, oldModels) {\n                        resetUnusedMarkerGroups();\n                        if (isNested) {\n                            $it.each(models, function (markerToMaybeDel, layerName) {\n                                var oldLayerModels = getLayerModels(oldModels, layerName);\n                                _destroy(markerToMaybeDel, oldLayerModels, leafletMarkers[layerName], map, layers);\n                            });\n                            return;\n                        }\n                        _destroy(models, oldModels, leafletMarkers, map, layers);\n                    };\n\n                    var _create = function _create(models, oldModels) {\n                        _clean(models, oldModels);\n                        var skips = null;\n                        if (isNested) {\n                            $it.each(models, function (markersToAdd, layerName) {\n                                var oldLayerModels = getLayerModels(oldModels, layerName);\n                                var newlayerModels = getLayerModels(models, layerName);\n                                skips = _getNewModelsToSkipp(newlayerModels, oldLayerModels, leafletMarkers[layerName]);\n                                _addMarkers(attrs.id, markersToAdd, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, layerName, skips);\n                            });\n                            return;\n                        }\n                        skips = _getNewModelsToSkipp(models, oldModels, leafletMarkers);\n                        _addMarkers(attrs.id, models, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, undefined, skips);\n                    };\n                    extendDirectiveControls(attrs.id, 'markers', _create, _clean);\n                    leafletData.setMarkers(leafletMarkers, attrs.id);\n\n                    maybeWatch(leafletScope, 'markers', watchOptions, function (newMarkers, oldMarkers) {\n                        if (watchTrap.changeFromDirective) return;\n                        _create(newMarkers, oldMarkers);\n                    });\n                    scope.$on('$destroy', function () {\n                        _destroy(leafletScope.markers, {}, leafletMarkers, map, layers);\n                    });\n                });\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('maxbounds', function (leafletLogger, leafletMapDefaults, leafletBoundsHelpers, leafletHelpers) {\n    // var $log = leafletLogger;\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function link(scope, element, attrs, controller) {\n            var leafletScope = controller.getLeafletScope(),\n                isValidBounds = leafletBoundsHelpers.isValidBounds,\n                isNumber = leafletHelpers.isNumber;\n\n            controller.getMap().then(function (map) {\n                leafletScope.$watch(\"maxbounds\", function (maxbounds) {\n                    if (!isValidBounds(maxbounds)) {\n                        // Unset any previous maxbounds\n                        map.setMaxBounds();\n                        return;\n                    }\n\n                    var leafletBounds = leafletBoundsHelpers.createLeafletBounds(maxbounds);\n                    if (isNumber(maxbounds.pad)) {\n                        leafletBounds = leafletBounds.pad(maxbounds.pad);\n                    }\n\n                    map.setMaxBounds(leafletBounds);\n                    if (!attrs.center && !attrs.lfCenter) {\n                        map.fitBounds(leafletBounds);\n                    }\n                });\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('paths', function (leafletLogger, $q, leafletData, leafletMapDefaults, leafletHelpers, leafletPathsHelpers, leafletPathEvents, leafletWatchHelpers) {\n    var $log = leafletLogger;\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: ['leaflet', '?layers'],\n\n        link: function link(scope, element, attrs, controller) {\n            var mapController = controller[0],\n                isDefined = leafletHelpers.isDefined,\n                isString = leafletHelpers.isString,\n                leafletScope = mapController.getLeafletScope(),\n                paths = leafletScope.paths,\n                createPath = leafletPathsHelpers.createPath,\n                bindPathEvents = leafletPathEvents.bindPathEvents,\n                setPathOptions = leafletPathsHelpers.setPathOptions,\n                maybeWatch = leafletWatchHelpers.maybeWatch;\n\n            mapController.getMap().then(function (map) {\n                var defaults = leafletMapDefaults.getDefaults(attrs.id),\n                    getLayers;\n\n                // If the layers attribute is used, we must wait until the layers are created\n                if (isDefined(controller[1])) {\n                    getLayers = controller[1].getLayers;\n                } else {\n                    getLayers = function getLayers() {\n                        var deferred = $q.defer();\n                        deferred.resolve();\n                        return deferred.promise;\n                    };\n                }\n\n                if (!isDefined(paths)) {\n                    return;\n                }\n\n                //legacy behaviour does a watch collection on the paths\n                var _legacyWatchOptions = {\n                    type: 'watchCollection',\n                    individual: {\n                        type: 'watchDeep'\n                    }\n                };\n\n                var watchOptions;\n                if (leafletScope.watchOptions && leafletScope.watchOptions.paths) {\n                    watchOptions = leafletScope.watchOptions.paths;\n                } else {\n                    watchOptions = _legacyWatchOptions;\n                }\n\n                getLayers().then(function (layers) {\n\n                    var leafletPaths = {};\n                    leafletData.setPaths(leafletPaths, attrs.id);\n\n                    // Function for listening every single path once created\n                    var watchPathFn = function watchPathFn(leafletPath, name, watchOptions) {\n                        var pathWatchPath = \"paths[\\\"\" + name + \"\\\"]\";\n\n                        maybeWatch(leafletScope, pathWatchPath, watchOptions, function (pathData, old, clearWatch) {\n                            if (!isDefined(pathData)) {\n                                if (isDefined(old.layer)) {\n                                    for (var i in layers.overlays) {\n                                        var overlay = layers.overlays[i];\n                                        overlay.removeLayer(leafletPath);\n                                    }\n                                }\n                                map.removeLayer(leafletPath);\n                                clearWatch();\n                                return;\n                            }\n                            setPathOptions(leafletPath, pathData.type, pathData);\n                        });\n                    };\n\n                    var _clean = function _clean(newPaths) {\n                        // Delete paths (by name) from the array\n                        for (var name in leafletPaths) {\n                            if (!isDefined(newPaths[name])) {\n                                map.removeLayer(leafletPaths[name]);\n                                delete leafletPaths[name];\n                            }\n                        }\n                    };\n\n                    var _create = function _create(newPaths) {\n                        _clean(newPaths);\n                        // Create the new paths\n                        for (var newName in newPaths) {\n                            if (newName.search('\\\\$') === 0) {\n                                continue;\n                            }\n                            if (newName.search(\"-\") !== -1) {\n                                $log.error('[AngularJS - Leaflet] The path name \"' + newName + '\" is not valid. It must not include \"-\" and a number.');\n                                continue;\n                            }\n\n                            if (!isDefined(leafletPaths[newName])) {\n                                var pathData = newPaths[newName];\n                                var newPath = createPath(newName, newPaths[newName], defaults);\n\n                                // bind popup if defined\n                                if (isDefined(newPath) && isDefined(pathData.message)) {\n                                    newPath.bindPopup(pathData.message, pathData.popupOptions);\n                                }\n\n                                // Show label if defined\n                                if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(pathData.label) && isDefined(pathData.label.message)) {\n                                    newPath.bindLabel(pathData.label.message, pathData.label.options);\n                                }\n\n                                // Check if the marker should be added to a layer\n                                if (isDefined(pathData) && isDefined(pathData.layer)) {\n\n                                    if (!isString(pathData.layer)) {\n                                        $log.error('[AngularJS - Leaflet] A layername must be a string');\n                                        continue;\n                                    }\n                                    if (!isDefined(layers)) {\n                                        $log.error('[AngularJS - Leaflet] You must add layers to the directive if the markers are going to use this functionality.');\n                                        continue;\n                                    }\n\n                                    if (!isDefined(layers.overlays) || !isDefined(layers.overlays[pathData.layer])) {\n                                        $log.error('[AngularJS - Leaflet] A path can only be added to a layer of type \"group\"');\n                                        continue;\n                                    }\n                                    var layerGroup = layers.overlays[pathData.layer];\n                                    if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {\n                                        $log.error('[AngularJS - Leaflet] Adding a path to an overlay needs a overlay of the type \"group\" or \"featureGroup\"');\n                                        continue;\n                                    }\n\n                                    // Listen for changes on the new path\n                                    leafletPaths[newName] = newPath;\n                                    // The path goes to a correct layer group, so first of all we add it\n                                    layerGroup.addLayer(newPath);\n\n                                    if (watchOptions.individual.type !== null) {\n                                        watchPathFn(newPath, newName, watchOptions.individual);\n                                    } else {\n                                        setPathOptions(newPath, pathData.type, pathData);\n                                    }\n                                } else if (isDefined(newPath)) {\n                                    // Listen for changes on the new path\n                                    leafletPaths[newName] = newPath;\n                                    map.addLayer(newPath);\n\n                                    if (watchOptions.individual.type !== null) {\n                                        watchPathFn(newPath, newName, watchOptions.individual);\n                                    } else {\n                                        setPathOptions(newPath, pathData.type, pathData);\n                                    }\n                                }\n\n                                bindPathEvents(attrs.id, newPath, newName, pathData, leafletScope);\n                            }\n                        }\n                    };\n\n                    maybeWatch(leafletScope, 'paths', watchOptions, function (newPaths) {\n                        _create(newPaths);\n                    });\n                });\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('tiles', function (leafletLogger, leafletData, leafletMapDefaults, leafletHelpers) {\n    var $log = leafletLogger;\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function link(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined,\n                leafletScope = controller.getLeafletScope(),\n                tiles = leafletScope.tiles;\n\n            if (!isDefined(tiles) || !isDefined(tiles.url)) {\n                $log.warn(\"[AngularJS - Leaflet] The 'tiles' definition doesn't have the 'url' property.\");\n                return;\n            }\n\n            controller.getMap().then(function (map) {\n                var defaults = leafletMapDefaults.getDefaults(attrs.id);\n                var tileLayerObj;\n                leafletScope.$watch(\"tiles\", function (tiles) {\n                    var tileLayerOptions = defaults.tileLayerOptions;\n                    var tileLayerUrl = defaults.tileLayer;\n\n                    // If no valid tiles are in the scope, remove the last layer\n                    if (!isDefined(tiles.url) && isDefined(tileLayerObj)) {\n                        map.removeLayer(tileLayerObj);\n                        return;\n                    }\n\n                    // No leafletTiles object defined yet\n                    if (!isDefined(tileLayerObj)) {\n                        if (isDefined(tiles.options)) {\n                            angular.copy(tiles.options, tileLayerOptions);\n                        }\n\n                        if (isDefined(tiles.url)) {\n                            tileLayerUrl = tiles.url;\n                        }\n\n                        tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);\n                        tileLayerObj.addTo(map);\n                        leafletData.setTiles(tileLayerObj, attrs.id);\n                        return;\n                    }\n\n                    // If the options of the tilelayer is changed, we need to redraw the layer\n                    if (isDefined(tiles.url) && isDefined(tiles.options) && !angular.equals(tiles.options, tileLayerOptions)) {\n                        map.removeLayer(tileLayerObj);\n                        tileLayerOptions = defaults.tileLayerOptions;\n                        angular.copy(tiles.options, tileLayerOptions);\n                        tileLayerUrl = tiles.url;\n                        tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);\n                        tileLayerObj.addTo(map);\n                        leafletData.setTiles(tileLayerObj, attrs.id);\n                        return;\n                    }\n\n                    // Only the URL of the layer is changed, update the tiles object\n                    if (isDefined(tiles.url)) {\n                        tileLayerObj.setUrl(tiles.url);\n                    }\n                }, true);\n            });\n        }\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').directive('watchOptions', ['$log', '$rootScope', '$q', 'leafletData', 'leafletHelpers', function (leafletLogger, $rootScope, $q, leafletData, leafletHelpers) {\n\n    var isDefined = leafletHelpers.isDefined,\n        errorHeader = leafletHelpers.errorHeader,\n        isObject = leafletHelpers.isObject,\n        $log = leafletLogger;\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: ['leaflet'],\n\n        link: function link(scope, element, attrs, controller) {\n            var mapController = controller[0],\n                leafletScope = mapController.getLeafletScope();\n\n            var _isValidWatchType = function _isValidWatchType(type) {\n                return type === 'watch' || type === 'watchCollection' || type === 'watchDeep' || type === null;\n            };\n\n            if (isDefined(leafletScope.watchOptions) && isObject(leafletScope.watchOptions)) {\n                angular.forEach(['markers', 'geojson', 'paths'], function (name) {\n                    if (isDefined(leafletScope.watchOptions[name])) {\n                        if (!_isValidWatchType(leafletScope.watchOptions[name].type)) {\n                            $log.error(errorHeader + ' watchOptions.' + name + '.type is not a valid type.');\n                        }\n                        if (isDefined(leafletScope.watchOptions[name].individual)) {\n                            if (!_isValidWatchType(leafletScope.watchOptions[name].individual.type)) {\n                                $log.error(errorHeader + ' watchOptions.' + name + '.individual.type is not a valid type.');\n                            }\n                        } else {\n                            $log.error(errorHeader + ' watchOptions.' + name + '.type.individual must be defined.');\n                        }\n                    }\n                });\n            }\n        }\n    };\n}]);\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletEventsHelpersFactory', function ($rootScope, $q, leafletLogger, leafletHelpers) {\n    var safeApply = leafletHelpers.safeApply,\n        isDefined = leafletHelpers.isDefined,\n        isObject = leafletHelpers.isObject,\n        isArray = leafletHelpers.isArray,\n        errorHeader = leafletHelpers.errorHeader,\n        $log = leafletLogger;\n\n    var EventsHelper = function EventsHelper(rootBroadcastName, lObjectType) {\n        this.rootBroadcastName = rootBroadcastName;\n        $log.debug(\"leafletEventsHelpersFactory: lObjectType: \" + lObjectType + \"rootBroadcastName: \" + rootBroadcastName);\n        //used to path/key out certain properties based on the type , \"markers\", \"geojson\"\n        this.lObjectType = lObjectType;\n    };\n\n    EventsHelper.prototype.getAvailableEvents = function () {\n        return [];\n    };\n\n    /*\n     argument: name: Note this can be a single string or dot notation\n     Example:\n     markerModel : {\n     m1: { lat:_, lon: _}\n     }\n     //would yield name of\n     name = \"m1\"\n      If nested:\n     markerModel : {\n     cars: {\n     m1: { lat:_, lon: _}\n     }\n     }\n     //would yield name of\n     name = \"cars.m1\"\n     */\n    EventsHelper.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {\n        var _this = this;\n\n        maybeMapId = maybeMapId || '';\n        if (maybeMapId) maybeMapId = '.' + maybeMapId;\n\n        return function (e) {\n            var broadcastName = _this.rootBroadcastName + maybeMapId + '.' + eventName;\n            $log.debug(broadcastName);\n            _this.fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName, extra);\n        };\n    };\n\n    EventsHelper.prototype.fire = function (scope, broadcastName, logic, event, lObject, model, modelName, layerName, extra) {\n        // Safely broadcast the event\n        safeApply(scope, function () {\n            var toSend = {\n                leafletEvent: event,\n                leafletObject: lObject,\n                modelName: modelName,\n                model: model\n            };\n            if (isDefined(layerName)) angular.extend(toSend, { layerName: layerName });\n\n            if (logic === \"emit\") {\n                scope.$emit(broadcastName, toSend);\n            } else {\n                $rootScope.$broadcast(broadcastName, toSend);\n            }\n        });\n    };\n\n    EventsHelper.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName, extra) {\n        var events = [];\n        var logic = 'emit';\n        var _this = this;\n\n        if (!isDefined(leafletScope.eventBroadcast)) {\n            // Backward compatibility, if no event-broadcast attribute, all events are broadcasted\n            events = this.getAvailableEvents();\n        } else if (!isObject(leafletScope.eventBroadcast)) {\n            // Not a valid object\n            $log.error(errorHeader + \"event-broadcast must be an object check your model.\");\n        } else {\n            // We have a possible valid object\n            if (!isDefined(leafletScope.eventBroadcast[_this.lObjectType])) {\n                // We do not have events enable/disable do we do nothing (all enabled by default)\n                events = this.getAvailableEvents();\n            } else if (!isObject(leafletScope.eventBroadcast[_this.lObjectType])) {\n                // Not a valid object\n                $log.warn(errorHeader + 'event-broadcast.' + [_this.lObjectType] + ' must be an object check your model.');\n            } else {\n                // We have a possible valid map object\n                // Event propadation logic\n                if (isDefined(leafletScope.eventBroadcast[this.lObjectType].logic)) {\n                    // We take care of possible propagation logic\n                    if (leafletScope.eventBroadcast[_this.lObjectType].logic !== \"emit\" && leafletScope.eventBroadcast[_this.lObjectType].logic !== \"broadcast\") $log.warn(errorHeader + \"Available event propagation logic are: 'emit' or 'broadcast'.\");\n                }\n                // Enable / Disable\n                var eventsEnable = false,\n                    eventsDisable = false;\n                if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].enable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].enable)) eventsEnable = true;\n                if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].disable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].disable)) eventsDisable = true;\n\n                if (eventsEnable && eventsDisable) {\n                    // Both are active, this is an error\n                    $log.warn(errorHeader + \"can not enable and disable events at the same time\");\n                } else if (!eventsEnable && !eventsDisable) {\n                    // Both are inactive, this is an error\n                    $log.warn(errorHeader + \"must enable or disable events\");\n                } else {\n                    // At this point the object is OK, lets enable or disable events\n                    if (eventsEnable) {\n                        // Enable events\n                        leafletScope.eventBroadcast[this.lObjectType].enable.forEach(function (eventName) {\n                            // Do we have already the event enabled?\n                            if (events.indexOf(eventName) !== -1) {\n                                // Repeated event, this is an error\n                                $log.warn(errorHeader + \"This event \" + eventName + \" is already enabled\");\n                            } else {\n                                // Does the event exists?\n                                if (_this.getAvailableEvents().indexOf(eventName) === -1) {\n                                    // The event does not exists, this is an error\n                                    $log.warn(errorHeader + \"This event \" + eventName + \" does not exist\");\n                                } else {\n                                    // All ok enable the event\n                                    events.push(eventName);\n                                }\n                            }\n                        });\n                    } else {\n                        // Disable events\n                        events = this.getAvailableEvents();\n                        leafletScope.eventBroadcast[_this.lObjectType].disable.forEach(function (eventName) {\n                            var index = events.indexOf(eventName);\n                            if (index === -1) {\n                                // The event does not exist\n                                $log.warn(errorHeader + \"This event \" + eventName + \" does not exist or has been already disabled\");\n                            } else {\n                                events.splice(index, 1);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        events.forEach(function (eventName) {\n            lObject.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra));\n        });\n        return logic;\n    };\n\n    return EventsHelper;\n}).service('leafletEventsHelpers', function (leafletEventsHelpersFactory) {\n    return new leafletEventsHelpersFactory();\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletGeoJsonEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory, leafletData) {\n    var safeApply = leafletHelpers.safeApply,\n        EventsHelper = leafletEventsHelpersFactory;\n    // $log = leafletLogger;\n\n    var GeoJsonEvents = function GeoJsonEvents() {\n        EventsHelper.call(this, 'leafletDirectiveGeoJson', 'geojson');\n    };\n\n    GeoJsonEvents.prototype = new EventsHelper();\n\n    GeoJsonEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {\n        var base = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName),\n            _this = this;\n\n        return function (e) {\n            if (eventName === 'mouseout') {\n                if (extra.resetStyleOnMouseout) {\n                    leafletData.getGeoJSON(extra.mapId).then(function (leafletGeoJSON) {\n                        //this is broken on nested needs to traverse or user layerName (nested)\n                        var lobj = layerName ? leafletGeoJSON[layerName] : leafletGeoJSON;\n                        lobj.resetStyle(e.target);\n                    });\n                }\n                safeApply(leafletScope, function () {\n                    $rootScope.$broadcast(_this.rootBroadcastName + '.mouseout', e);\n                });\n            }\n            base(e); //common\n        };\n    };\n\n    GeoJsonEvents.prototype.getAvailableEvents = function () {\n        return ['click', 'dblclick', 'mouseover', 'mouseout'];\n    };\n\n    return new GeoJsonEvents();\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletLabelEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory) {\n    var Helpers = leafletHelpers,\n        EventsHelper = leafletEventsHelpersFactory;\n    //$log = leafletLogger;\n\n    var LabelEvents = function LabelEvents() {\n        EventsHelper.call(this, 'leafletDirectiveLabel', 'markers');\n    };\n    LabelEvents.prototype = new EventsHelper();\n\n    LabelEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n        var markerName = name.replace('markers.', '');\n        return EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, markerName, model, layerName);\n    };\n\n    LabelEvents.prototype.getAvailableEvents = function () {\n        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\n    };\n\n    LabelEvents.prototype.genEvents = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n        var _this = this;\n        var labelEvents = this.getAvailableEvents();\n        var scopeWatchName = Helpers.getObjectArrayPath(\"markers.\" + name);\n        labelEvents.forEach(function (eventName) {\n            lObject.label.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject.label, scopeWatchName, model, layerName));\n        });\n    };\n\n    LabelEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {};\n\n    return new LabelEvents();\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletMapEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpers, leafletIterators) {\n    var isDefined = leafletHelpers.isDefined,\n        fire = leafletEventsHelpers.fire;\n\n    var _getAvailableMapEvents = function _getAvailableMapEvents() {\n        return ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'contextmenu', 'focus', 'blur', 'preclick', 'load', 'unload', 'viewreset', 'movestart', 'move', 'moveend', 'dragstart', 'drag', 'dragend', 'zoomstart', 'zoomanim', 'zoomend', 'zoomlevelschange', 'resize', 'autopanstart', 'layeradd', 'layerremove', 'baselayerchange', 'overlayadd', 'overlayremove', 'locationfound', 'locationerror', 'popupopen', 'popupclose', 'draw:created', 'draw:edited', 'draw:deleted', 'draw:drawstart', 'draw:drawstop', 'draw:editstart', 'draw:editstop', 'draw:deletestart', 'draw:deletestop'];\n    };\n\n    var _genDispatchMapEvent = function _genDispatchMapEvent(scope, eventName, logic, maybeMapId) {\n        if (maybeMapId) {\n            maybeMapId = maybeMapId + '.';\n        }\n        return function (e) {\n            // Put together broadcast name\n            var broadcastName = 'leafletDirectiveMap.' + maybeMapId + eventName;\n            leafletLogger.debug(broadcastName);\n            // Safely broadcast the event\n            fire(scope, broadcastName, logic, e, e.target, scope);\n        };\n    };\n\n    var _notifyCenterChangedToBounds = function _notifyCenterChangedToBounds(scope) {\n        scope.$broadcast(\"boundsChanged\");\n    };\n\n    var _notifyCenterUrlHashChanged = function _notifyCenterUrlHashChanged(scope, map, attrs, search) {\n        if (!isDefined(attrs.urlHashCenter)) {\n            return;\n        }\n        var center = map.getCenter();\n        var centerUrlHash = center.lat.toFixed(4) + \":\" + center.lng.toFixed(4) + \":\" + map.getZoom();\n        if (!isDefined(search.c) || search.c !== centerUrlHash) {\n            //$log.debug(\"notified new center...\");\n            scope.$emit(\"centerUrlHash\", centerUrlHash);\n        }\n    };\n\n    var _addEvents = function _addEvents(map, mapId, mapEvents, contextName, scope, logic) {\n        leafletIterators.each(mapEvents, function (eventName) {\n            var context = {};\n            context[contextName] = eventName;\n            if (!mapId) {\n                mapId = map._container.id || '';\n            }\n\n            map.on(eventName, _genDispatchMapEvent(scope, eventName, logic, mapId), context);\n        });\n    };\n\n    return {\n        getAvailableMapEvents: _getAvailableMapEvents,\n        genDispatchMapEvent: _genDispatchMapEvent,\n        notifyCenterChangedToBounds: _notifyCenterChangedToBounds,\n        notifyCenterUrlHashChanged: _notifyCenterUrlHashChanged,\n        addEvents: _addEvents\n    };\n});\n","'use strict';\n\nangular.module('ui-leaflet').factory('leafletMarkerEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory, leafletLabelEvents) {\n    var safeApply = leafletHelpers.safeApply,\n        isDefined = leafletHelpers.isDefined,\n        Helpers = leafletHelpers,\n        lblHelp = leafletLabelEvents,\n        EventsHelper = leafletEventsHelpersFactory,\n        $log = leafletLogger;\n\n    var MarkerEvents = function MarkerEvents() {\n        EventsHelper.call(this, 'leafletDirectiveMarker', 'markers');\n    };\n\n    MarkerEvents.prototype = new EventsHelper();\n\n    MarkerEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n        var handle = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName);\n        return function (e) {\n            // Broadcast old marker click name for backwards compatibility\n            if (eventName === \"click\") {\n                safeApply(leafletScope, function () {\n                    $rootScope.$broadcast('leafletDirectiveMarkersClick', name);\n                });\n            } else if (eventName === 'dragend') {\n                safeApply(leafletScope, function () {\n                    model.lat = lObject.getLatLng().lat;\n                    model.lng = lObject.getLatLng().lng;\n                });\n                if (model.message && model.focus === true) {\n                    lObject.openPopup();\n                }\n            }\n            handle(e); //common\n        };\n    };\n\n    MarkerEvents.prototype.getAvailableEvents = function () {\n        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu', 'dragstart', 'drag', 'dragend', 'move', 'remove', 'popupopen', 'popupclose', 'touchend', 'touchstart', 'touchmove', 'touchcancel', 'touchleave'];\n    };\n\n    MarkerEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {\n        var logic = EventsHelper.prototype.bindEvents.call(this, maybeMapId, lObject, name, model, leafletScope, layerName);\n\n        if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {\n            lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model, layerName);\n        }\n    };\n\n    return new MarkerEvents();\n});\n","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nangular.module('ui-leaflet').factory('leafletPathEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletLabelEvents, leafletEventsHelpers) {\n    var isDefined = leafletHelpers.isDefined,\n        isObject = leafletHelpers.isObject,\n        Helpers = leafletHelpers,\n        errorHeader = leafletHelpers.errorHeader,\n        lblHelp = leafletLabelEvents,\n        fire = leafletEventsHelpers.fire,\n        $log = leafletLogger;\n\n    /*\n    TODO (nmccready) This EventsHelper needs to be derrived from leafletEventsHelpers to elminate copy and paste code.\n    */\n\n    var _genDispatchPathEvent = function _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n        maybeMapId = maybeMapId || '';\n\n        if (maybeMapId) maybeMapId = '.' + maybeMapId;\n\n        return function (e) {\n            var broadcastName = 'leafletDirectivePath' + maybeMapId + '.' + eventName;\n            $log.debug(broadcastName);\n            fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName);\n        };\n    };\n\n    var _bindPathEvents = function _bindPathEvents(maybeMapId, lObject, name, model, leafletScope) {\n        var pathEvents = [],\n            i,\n            eventName,\n            logic = \"broadcast\";\n\n        if (!isDefined(leafletScope.eventBroadcast)) {\n            // Backward compatibility, if no event-broadcast attribute, all events are broadcasted\n            pathEvents = _getAvailablePathEvents();\n        } else if (!isObject(leafletScope.eventBroadcast)) {\n            // Not a valid object\n            $log.error(errorHeader + \"event-broadcast must be an object check your model.\");\n        } else {\n            // We have a possible valid object\n            if (!isDefined(leafletScope.eventBroadcast.path)) {\n                // We do not have events enable/disable do we do nothing (all enabled by default)\n                pathEvents = _getAvailablePathEvents();\n            } else if (isObject(leafletScope.eventBroadcast.paths)) {\n                // Not a valid object\n                $log.warn(errorHeader + \"event-broadcast.path must be an object check your model.\");\n            } else {\n                // We have a possible valid map object\n                // Event propadation logic\n                if (leafletScope.eventBroadcast.path.logic !== undefined && leafletScope.eventBroadcast.path.logic !== null) {\n                    // We take care of possible propagation logic\n                    if (leafletScope.eventBroadcast.path.logic !== \"emit\" && leafletScope.eventBroadcast.path.logic !== \"broadcast\") {\n                        // This is an error\n                        $log.warn(errorHeader + \"Available event propagation logic are: 'emit' or 'broadcast'.\");\n                    } else if (leafletScope.eventBroadcast.path.logic === \"emit\") {\n                        logic = \"emit\";\n                    }\n                }\n                // Enable / Disable\n                var pathEventsEnable = false,\n                    pathEventsDisable = false;\n                if (leafletScope.eventBroadcast.path.enable !== undefined && leafletScope.eventBroadcast.path.enable !== null) {\n                    if (_typeof(leafletScope.eventBroadcast.path.enable) === 'object') {\n                        pathEventsEnable = true;\n                    }\n                }\n                if (leafletScope.eventBroadcast.path.disable !== undefined && leafletScope.eventBroadcast.path.disable !== null) {\n                    if (_typeof(leafletScope.eventBroadcast.path.disable) === 'object') {\n                        pathEventsDisable = true;\n                    }\n                }\n                if (pathEventsEnable && pathEventsDisable) {\n                    // Both are active, this is an error\n                    $log.warn(errorHeader + \"can not enable and disable events at the same time\");\n                } else if (!pathEventsEnable && !pathEventsDisable) {\n                    // Both are inactive, this is an error\n                    $log.warn(errorHeader + \"must enable or disable events\");\n                } else {\n                    // At this point the path object is OK, lets enable or disable events\n                    if (pathEventsEnable) {\n                        // Enable events\n                        for (i = 0; i < leafletScope.eventBroadcast.path.enable.length; i++) {\n                            eventName = leafletScope.eventBroadcast.path.enable[i];\n                            // Do we have already the event enabled?\n                            if (pathEvents.indexOf(eventName) !== -1) {\n                                // Repeated event, this is an error\n                                $log.warn(errorHeader + \"This event \" + eventName + \" is already enabled\");\n                            } else {\n                                // Does the event exists?\n                                if (_getAvailablePathEvents().indexOf(eventName) === -1) {\n                                    // The event does not exists, this is an error\n                                    $log.warn(errorHeader + \"This event \" + eventName + \" does not exist\");\n                                } else {\n                                    // All ok enable the event\n                                    pathEvents.push(eventName);\n                                }\n                            }\n                        }\n                    } else {\n                        // Disable events\n                        pathEvents = _getAvailablePathEvents();\n                        for (i = 0; i < leafletScope.eventBroadcast.path.disable.length; i++) {\n                            eventName = leafletScope.eventBroadcast.path.disable[i];\n                            var index = pathEvents.indexOf(eventName);\n                            if (index === -1) {\n                                // The event does not exist\n                                $log.warn(errorHeader + \"This event \" + eventName + \" does not exist or has been already disabled\");\n                            } else {\n                                pathEvents.splice(index, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for (i = 0; i < pathEvents.length; i++) {\n            eventName = pathEvents[i];\n            lObject.on(eventName, _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, pathEvents, name));\n        }\n\n        if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {\n            lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model);\n        }\n    };\n\n    var _getAvailablePathEvents = function _getAvailablePathEvents() {\n        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu', 'add', 'remove', 'popupopen', 'popupclose'];\n    };\n\n    return {\n        getAvailablePathEvents: _getAvailablePathEvents,\n        bindPathEvents: _bindPathEvents\n    };\n});\n"]}
\ No newline at end of file
Index: home/partial/dataMap/dataMap.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- home/partial/dataMap/dataMap.js	(revision 25eea5333ab01c6d75fbbdd60df446ad600e0d90)
+++ home/partial/dataMap/dataMap.js	(revision )
@@ -26,30 +26,63 @@
         var currentDataPoint = 0;
         var dataPointHash = [];
 
+        var littleton = L.marker([39.61, -105.02]).bindPopup('This is Littleton, CO.'),
+            denver    = L.marker([39.74, -104.99]).bindPopup('This is Denver, CO.'),
+            aurora    = L.marker([39.73, -104.8]).bindPopup('This is Aurora, CO.'),
+            golden    = L.marker([39.77, -105.23]).bindPopup('This is Golden, CO.');
+
+        var GSLayer = [];
+        for (var i = 0; i <$scope.GSLs.length-1; i++){
+           GSLayer.push(L.circle([parseFloat($scope.GSLs[i].lat), parseFloat($scope.GSLs[i].long)], 80, {"color": "#0000ff"}));
+        }
+        var gasStations = L.layerGroup(GSLayer);
+
+        var cities = L.layerGroup([littleton, denver, aurora, golden]);
+
+        var grayscale = L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v10/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiYmR1bGFuIiwiYSI6ImNpemZzOTYyYTAwbncycW5ueWYyaHkyeTkifQ.Iotxd_KBWcont6Hggmal1g', {
+            id: 'mapid',
+            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="http://mapbox.com">Mapbox</a>'
+        });
+
+        var map = L.map('mapid', {
+            center: [39.73, -104.99],
+            zoom: 10,
+            layers: [grayscale, cities, gasStations]
+        });
+
+        var baseMaps = {
+            "Grayscale": grayscale
+        };
+
+        var overlayMaps = {
+            "Cities": cities,
+            "Gas_Stations" : gasStations
+        };
+
+        L.control.layers(baseMaps, overlayMaps).addTo(map);
+
+        setTimeout(function () {
+            // map.removeLayer(cities);
+        },10000)
+
+/*
+
+        The real code
+
         var mymap = L.map('mapid').setView([centralCoordinates.lat, centralCoordinates.long], 13);
         L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v10/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiYmR1bGFuIiwiYSI6ImNpemZzOTYyYTAwbncycW5ueWYyaHkyeTkifQ.Iotxd_KBWcont6Hggmal1g', {
             attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="http://mapbox.com">Mapbox</a>',
             maxZoom: 18
         }).addTo(mymap);
 
-        // var marker = L.marker([centralCoordinates.lat, centralCoordinates.long]).addTo(mymap);
-        L.circle([centralCoordinates.lat, centralCoordinates.long], 200, {"color": "#FF5500"}).addTo(mymap);
+        var marker = L.marker([centralCoordinates.lat, centralCoordinates.long]).addTo(mymap);
+        var center = L.circle([centralCoordinates.lat, centralCoordinates.long], 200, {"color": "#FF5500"}).addTo(mymap);
+        var layerGroupPrime = L.layerGroup([center])
 
-        // for (var i = 0; i <$scope.GSLs.length; i++){
-        //     L.circle([parseInt($scope.GSLs[i].lat), parseInt($scope.GSLs[i].long)], 80, {"color": "#00FF57"}).addTo(mymap);
-        // }
 
 
-        $scope.mapCheckBoxes = {
-            commute_routes : false,
-            service_stations : false,
-            stops_lt_30 : false,
-            parking : false,
-            existing_chargers : false,
-            poi : false,
-            stops_gt_30 : false,
-            sugg_char_station_location : false
-        };
+*/
+
 
         $scope.changeDataPointModel = function (dataPoint) {
             if ($scope.mapCheckBoxes[dataPoint] === true){
Index: bower_components/ui-leaflet/dist/ui-leaflet_dev_mapped.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bower_components/ui-leaflet/dist/ui-leaflet_dev_mapped.js	(revision )
+++ bower_components/ui-leaflet/dist/ui-leaflet_dev_mapped.js	(revision )
@@ -0,0 +1,5190 @@
+/*!
+*  ui-leaflet 2.0.0 2016-10-04
+*  ui-leaflet - An AngularJS directive to easily interact with Leaflet maps
+*  git: https://github.com/angular-ui/ui-leaflet
+*/
+(function(angular){
+'use strict';
+'use strict';
+
+angular.module('ui-leaflet', ['nemLogging']).directive('leaflet', function ($q, leafletData, leafletMapDefaults, leafletHelpers, leafletMapEvents) {
+    return {
+        restrict: "EA",
+        replace: true,
+        scope: {
+            center: '=',
+            lfCenter: '=',
+            defaults: '=',
+            maxbounds: '=',
+            bounds: '=',
+            markers: '=',
+            legend: '=',
+            geojson: '=',
+            paths: '=',
+            tiles: '=',
+            layers: '=',
+            controls: '=',
+            decorations: '=',
+            eventBroadcast: '=',
+            watchOptions: '=',
+            id: '@'
+        },
+        transclude: true,
+        template: '<div class="angular-leaflet-map"><div ng-transclude></div></div>',
+        controller: function controller($scope) {
+            this._leafletMap = $q.defer();
+            this.getMap = function () {
+                return this._leafletMap.promise;
+            };
+
+            this.getLeafletScope = function () {
+                return $scope;
+            };
+        },
+
+        link: function link(scope, element, attrs, ctrl) {
+            var isDefined = leafletHelpers.isDefined,
+                defaults = leafletMapDefaults.setDefaults(scope.defaults, attrs.id),
+                mapEvents = leafletMapEvents.getAvailableMapEvents(),
+                addEvents = leafletMapEvents.addEvents;
+
+            scope.mapId = attrs.id;
+            leafletData.setDirectiveControls({}, attrs.id);
+
+            // Set width and height utility functions
+            function updateWidth() {
+                if (isNaN(attrs.width)) {
+                    element.css('width', attrs.width);
+                } else {
+                    element.css('width', attrs.width + 'px');
+                }
+            }
+
+            function updateHeight() {
+                if (isNaN(attrs.height)) {
+                    element.css('height', attrs.height);
+                } else {
+                    element.css('height', attrs.height + 'px');
+                }
+            }
+
+            // Create the Leaflet Map Object with the options
+            var map = new L.Map(element[0], leafletMapDefaults.getMapCreationDefaults(attrs.id));
+            ctrl._leafletMap.resolve(map);
+
+            // If the width attribute defined update css
+            // Then watch if bound property changes and update css
+            if (isDefined(attrs.width)) {
+                updateWidth();
+
+                scope.$watch(function () {
+                    return element[0].getAttribute('width');
+                }, function () {
+                    updateWidth();
+                    map.invalidateSize();
+                });
+            }
+
+            // If the height attribute defined update css
+            // Then watch if bound property changes and update css
+            if (isDefined(attrs.height)) {
+                updateHeight();
+
+                scope.$watch(function () {
+                    return element[0].getAttribute('height');
+                }, function () {
+                    updateHeight();
+                    map.invalidateSize();
+                });
+            }
+
+            if (!isDefined(attrs.center) && !isDefined(attrs.lfCenter)) {
+                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+            }
+
+            // If no layers nor tiles defined, set the default tileLayer
+            if (!isDefined(attrs.tiles) && !isDefined(attrs.layers)) {
+                var tileLayerObj = L.tileLayer(defaults.tileLayer, defaults.tileLayerOptions);
+                tileLayerObj.addTo(map);
+                leafletData.setTiles(tileLayerObj, attrs.id);
+            }
+
+            // Set zoom control configuration
+            if (isDefined(map.zoomControl) && isDefined(defaults.zoomControlPosition)) {
+                map.zoomControl.setPosition(defaults.zoomControlPosition);
+            }
+
+            if (isDefined(map.zoomControl) && defaults.zoomControl === false) {
+                map.zoomControl.removeFrom(map);
+            }
+
+            if (isDefined(map.zoomsliderControl) && isDefined(defaults.zoomsliderControl) && defaults.zoomsliderControl === false) {
+                map.zoomsliderControl.removeFrom(map);
+            }
+
+            // if no event-broadcast attribute, all events are broadcasted
+            if (!isDefined(attrs.eventBroadcast)) {
+                var logic = "broadcast";
+                addEvents(map, attrs.id, mapEvents, "eventName", scope, logic);
+            }
+
+            // Resolve the map object to the promises
+            map.whenReady(function () {
+                leafletData.setMap(map, attrs.id);
+            });
+
+            scope.$on('$destroy', function () {
+                leafletMapDefaults.reset();
+                map.remove();
+                leafletData.unresolveMap(attrs.id);
+            });
+
+            //Handle request to invalidate the map size
+            //Up scope using $scope.$emit('invalidateSize')
+            //Down scope using $scope.$broadcast('invalidateSize')
+            scope.$on('invalidateSize', function () {
+                map.invalidateSize();
+            });
+        }
+    };
+});
+
+'use strict';
+
+(function () {
+    angular.module('ui-leaflet').factory('eventManager', [function () {
+        var EventManager = function EventManager() {
+            this.listeners = {};
+        };
+
+        EventManager.prototype = {
+            addEventListener: function addEventListener(type, callback, scope) {
+                var args = [];
+                var numOfArgs = arguments.length;
+                for (var i = 0; i < numOfArgs; i++) {
+                    args.push(arguments[i]);
+                }
+                args = args.length > 3 ? args.splice(3, args.length - 1) : [];
+                if (typeof this.listeners[type] !== "undefined") {
+                    this.listeners[type].push({ scope: scope, callback: callback, args: args });
+                } else {
+                    this.listeners[type] = [{ scope: scope, callback: callback, args: args }];
+                }
+            },
+            removeEventListener: function removeEventListener(type, callback, scope) {
+                if (typeof this.listeners[type] !== "undefined") {
+                    var numOfCallbacks = this.listeners[type].length;
+                    var newArray = [];
+                    for (var i = 0; i < numOfCallbacks; i++) {
+                        var listener = this.listeners[type][i];
+                        if (listener.scope === scope && listener.callback === callback) {} else {
+                            newArray.push(listener);
+                        }
+                    }
+                    this.listeners[type] = newArray;
+                }
+            },
+            hasEventListener: function hasEventListener(type, callback, scope) {
+                if (typeof this.listeners[type] !== "undefined") {
+                    var numOfCallbacks = this.listeners[type].length;
+                    if (callback === undefined && scope === undefined) {
+                        return numOfCallbacks > 0;
+                    }
+                    for (var i = 0; i < numOfCallbacks; i++) {
+                        var listener = this.listeners[type][i];
+                        if ((scope ? listener.scope === scope : true) && listener.callback === callback) {
+                            return true;
+                        }
+                    }
+                }
+                return false;
+            },
+            dispatch: function dispatch(type, target) {
+                var numOfListeners = 0;
+                var event = {
+                    type: type,
+                    target: target
+                };
+                var args = [];
+                var numOfArgs = arguments.length;
+                for (var i = 0; i < numOfArgs; i++) {
+                    args.push(arguments[i]);
+                }
+                args = args.length > 2 ? args.splice(2, args.length - 1) : [];
+                args = [event].concat(args);
+                if (typeof this.listeners[type] !== "undefined") {
+                    var numOfCallbacks = this.listeners[type].length;
+                    for (var x = 0; x < numOfCallbacks; x++) {
+                        var listener = this.listeners[type][x];
+                        if (listener && listener.callback) {
+                            var concatArgs = args.concat(listener.args);
+                            listener.callback.apply(listener.scope, concatArgs);
+                            numOfListeners += 1;
+                        }
+                    }
+                }
+            },
+            getEvents: function getEvents() {
+                var str = "";
+                for (var type in this.listeners) {
+                    var numOfCallbacks = this.listeners[type].length;
+                    for (var i = 0; i < numOfCallbacks; i++) {
+                        var listener = this.listeners[type][i];
+                        str += listener.scope && listener.scope.className ? listener.scope.className : "anonymous";
+                        str += " listen for '" + type + "'\n";
+                    }
+                }
+                return str;
+            }
+        };
+        return EventManager;
+    }]).service('eventManager', function (EventManager) {
+        return new EventManager();
+    });
+})();
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletBoundsHelpers', function (leafletLogger, leafletHelpers) {
+
+    var isArray = leafletHelpers.isArray,
+        isNumber = leafletHelpers.isNumber,
+        isFunction = leafletHelpers.isFunction,
+        isDefined = leafletHelpers.isDefined,
+        $log = leafletLogger;
+
+    function _isValidBounds(bounds) {
+        return angular.isDefined(bounds) && angular.isDefined(bounds.southWest) && angular.isDefined(bounds.northEast) && angular.isNumber(bounds.southWest.lat) && angular.isNumber(bounds.southWest.lng) && angular.isNumber(bounds.northEast.lat) && angular.isNumber(bounds.northEast.lng);
+    }
+
+    return {
+        createLeafletBounds: function createLeafletBounds(bounds) {
+            if (_isValidBounds(bounds)) {
+                return L.latLngBounds([bounds.southWest.lat, bounds.southWest.lng], [bounds.northEast.lat, bounds.northEast.lng]);
+            }
+        },
+
+        isValidBounds: _isValidBounds,
+
+        createBoundsFromArray: function createBoundsFromArray(boundsArray) {
+            if (!(isArray(boundsArray) && boundsArray.length === 2 && isArray(boundsArray[0]) && isArray(boundsArray[1]) && boundsArray[0].length === 2 && boundsArray[1].length === 2 && isNumber(boundsArray[0][0]) && isNumber(boundsArray[0][1]) && isNumber(boundsArray[1][0]) && isNumber(boundsArray[1][1]))) {
+                $log.error("[AngularJS - Leaflet] The bounds array is not valid.");
+                return;
+            }
+
+            return {
+                northEast: {
+                    lat: boundsArray[0][0],
+                    lng: boundsArray[0][1]
+                },
+                southWest: {
+                    lat: boundsArray[1][0],
+                    lng: boundsArray[1][1]
+                }
+            };
+        },
+
+        createBoundsFromLeaflet: function createBoundsFromLeaflet(lfBounds) {
+            if (!(isDefined(lfBounds) && isFunction(lfBounds.getNorthEast) && isFunction(lfBounds.getSouthWest))) {
+                $log.error("[AngularJS - Leaflet] The leaflet bounds is not valid object.");
+                return;
+            }
+
+            var northEast = lfBounds.getNorthEast(),
+                southWest = lfBounds.getSouthWest();
+
+            return {
+                northEast: {
+                    lat: northEast.lat,
+                    lng: northEast.lng
+                },
+                southWest: {
+                    lat: southWest.lat,
+                    lng: southWest.lng
+                }
+            };
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletControlHelpers', function ($rootScope, leafletLogger, leafletHelpers, leafletLayerHelpers, leafletMapDefaults) {
+    var isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        createLayer = leafletLayerHelpers.createLayer,
+        _controls = {},
+        errorHeader = leafletHelpers.errorHeader + ' [Controls] ',
+        $log = leafletLogger;
+
+    var _controlLayersMustBeVisible = function _controlLayersMustBeVisible(baselayers, overlays, mapId) {
+        var defaults = leafletMapDefaults.getDefaults(mapId);
+        if (!defaults.controls.layers.visible) {
+            return false;
+        }
+
+        var atLeastOneControlItemMustBeShown = false;
+
+        if (isObject(baselayers)) {
+            Object.keys(baselayers).forEach(function (key) {
+                var layer = baselayers[key];
+                if (!isDefined(layer.layerOptions) || layer.layerOptions.showOnSelector !== false) {
+                    atLeastOneControlItemMustBeShown = true;
+                }
+            });
+        }
+
+        if (isObject(overlays)) {
+            Object.keys(overlays).forEach(function (key) {
+                var layer = overlays[key];
+                if (!isDefined(layer.layerParams) || layer.layerParams.showOnSelector !== false) {
+                    atLeastOneControlItemMustBeShown = true;
+                }
+            });
+        }
+
+        return atLeastOneControlItemMustBeShown;
+    };
+
+    var _createLayersControl = function _createLayersControl(mapId) {
+        var defaults = leafletMapDefaults.getDefaults(mapId);
+        var controlOptions = {
+            collapsed: defaults.controls.layers.collapsed,
+            position: defaults.controls.layers.position,
+            autoZIndex: false
+        };
+
+        angular.extend(controlOptions, defaults.controls.layers.options);
+
+        var control;
+        if (defaults.controls.layers && isDefined(defaults.controls.layers.control)) {
+            control = defaults.controls.layers.control.apply(this, [[], [], controlOptions]);
+        } else {
+            control = new L.control.layers([], [], controlOptions);
+        }
+
+        return control;
+    };
+
+    var controlTypes = {
+        draw: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.Draw)) {
+                    $log.error(errorHeader + ' Draw plugin is not loaded.');
+                    return false;
+                }
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.Control.Draw(params);
+            }
+        },
+        scale: {
+            isPluginLoaded: function isPluginLoaded() {
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.control.scale(params);
+            }
+        },
+        fullscreen: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.Fullscreen)) {
+                    $log.error(errorHeader + ' Fullscreen plugin is not loaded.');
+                    return false;
+                }
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.Control.Fullscreen(params);
+            }
+        },
+        search: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.Search)) {
+                    $log.error(errorHeader + ' Search plugin is not loaded.');
+                    return false;
+                }
+                return true;
+            },
+            checkValidParams: function checkValidParams() /* params */{
+                return true;
+            },
+            createControl: function createControl(params) {
+                return new L.Control.Search(params);
+            }
+        },
+        custom: {},
+        minimap: {
+            isPluginLoaded: function isPluginLoaded() {
+                if (!angular.isDefined(L.Control.MiniMap)) {
+                    $log.error(errorHeader + ' Minimap plugin is not loaded.');
+                    return false;
+                }
+
+                return true;
+            },
+            checkValidParams: function checkValidParams(params) {
+                if (!isDefined(params.layer)) {
+                    $log.warn(errorHeader + ' minimap "layer" option should be defined.');
+                    return false;
+                }
+                return true;
+            },
+            createControl: function createControl(params) {
+                var layer = createLayer(params.layer);
+
+                if (!isDefined(layer)) {
+                    $log.warn(errorHeader + ' minimap control "layer" could not be created.');
+                    return;
+                }
+
+                return new L.Control.MiniMap(layer, params);
+            }
+        }
+    };
+
+    return {
+        layersControlMustBeVisible: _controlLayersMustBeVisible,
+
+        isValidControlType: function isValidControlType(type) {
+            return Object.keys(controlTypes).indexOf(type) !== -1;
+        },
+
+        createControl: function createControl(type, params) {
+            if (!controlTypes[type].checkValidParams(params)) {
+                return;
+            }
+
+            return controlTypes[type].createControl(params);
+        },
+
+        updateLayersControl: function updateLayersControl(map, mapId, loaded, baselayers, overlays, leafletLayers) {
+            var i;
+            var _layersControl = _controls[mapId];
+            var mustBeLoaded = _controlLayersMustBeVisible(baselayers, overlays, mapId);
+
+            if (isDefined(_layersControl) && loaded) {
+                for (i in leafletLayers.baselayers) {
+                    _layersControl.removeLayer(leafletLayers.baselayers[i]);
+                }
+                for (i in leafletLayers.overlays) {
+                    _layersControl.removeLayer(leafletLayers.overlays[i]);
+                }
+                map.removeControl(_layersControl);
+                delete _controls[mapId];
+            }
+
+            if (mustBeLoaded) {
+                _layersControl = _createLayersControl(mapId);
+                _controls[mapId] = _layersControl;
+                for (i in baselayers) {
+                    var hideOnSelector = isDefined(baselayers[i].layerOptions) && baselayers[i].layerOptions.showOnSelector === false;
+                    if (!hideOnSelector && isDefined(leafletLayers.baselayers[i])) {
+                        _layersControl.addBaseLayer(leafletLayers.baselayers[i], baselayers[i].name);
+                    }
+                }
+                for (i in overlays) {
+                    var hideOverlayOnSelector = isDefined(overlays[i].layerParams) && overlays[i].layerParams.showOnSelector === false;
+                    if (!hideOverlayOnSelector && isDefined(leafletLayers.overlays[i])) {
+                        _layersControl.addOverlay(leafletLayers.overlays[i], overlays[i].name);
+                    }
+                }
+
+                map.addControl(_layersControl);
+            }
+            return mustBeLoaded;
+        },
+
+        destroyMapLayersControl: function destroyMapLayersControl(mapId) {
+            delete _controls[mapId];
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletData', function (leafletLogger, $q, leafletHelpers) {
+    var getDefer = leafletHelpers.getDefer,
+        getUnresolvedDefer = leafletHelpers.getUnresolvedDefer,
+        setResolvedDefer = leafletHelpers.setResolvedDefer;
+    // $log = leafletLogger;
+
+    var _private = {};
+    var self = this;
+
+    var upperFirst = function upperFirst(string) {
+        return string.charAt(0).toUpperCase() + string.slice(1);
+    };
+
+    var _privateItems = ['map', 'tiles', 'layers', 'paths', 'markers', 'geoJSON', 'UTFGrid', //odd ball on naming convention keeping to not break
+    'decorations', 'directiveControls'];
+
+    //init
+    _privateItems.forEach(function (itemName) {
+        _private[itemName] = {};
+    });
+
+    this.unresolveMap = function (scopeId) {
+        var id = leafletHelpers.obtainEffectiveMapId(_private.map, scopeId);
+        _privateItems.forEach(function (itemName) {
+            _private[itemName][id] = undefined;
+        });
+    };
+
+    //int repetitive stuff (get and sets)
+    _privateItems.forEach(function (itemName) {
+        var name = upperFirst(itemName);
+        self['set' + name] = function (lObject, scopeId) {
+            var defer = getUnresolvedDefer(_private[itemName], scopeId);
+            defer.resolve(lObject);
+            setResolvedDefer(_private[itemName], scopeId);
+        };
+
+        self['get' + name] = function (scopeId) {
+            var defer = getDefer(_private[itemName], scopeId);
+            return defer.promise;
+        };
+    });
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletDirectiveControlsHelpers', function (leafletLogger, leafletData, leafletHelpers) {
+    var _isDefined = leafletHelpers.isDefined,
+        _isString = leafletHelpers.isString,
+        _isObject = leafletHelpers.isObject,
+        _mainErrorHeader = leafletHelpers.errorHeader,
+        $log = leafletLogger;
+
+    var _errorHeader = _mainErrorHeader + '[leafletDirectiveControlsHelpers';
+
+    var _extend = function _extend(id, thingToAddName, createFn, cleanFn) {
+        var _fnHeader = _errorHeader + '.extend] ';
+        var extender = {};
+        if (!_isDefined(thingToAddName)) {
+            $log.error(_fnHeader + 'thingToAddName cannot be undefined');
+            return;
+        }
+
+        if (_isString(thingToAddName) && _isDefined(createFn) && _isDefined(cleanFn)) {
+            extender[thingToAddName] = {
+                create: createFn,
+                clean: cleanFn
+            };
+        } else if (_isObject(thingToAddName) && !_isDefined(createFn) && !_isDefined(cleanFn)) {
+            extender = thingToAddName;
+        } else {
+            $log.error(_fnHeader + 'incorrect arguments');
+            return;
+        }
+
+        //add external control to create / destroy markers without a watch
+        leafletData.getDirectiveControls().then(function (controls) {
+            angular.extend(controls, extender);
+            leafletData.setDirectiveControls(controls, id);
+        });
+    };
+
+    return {
+        extend: _extend
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletGeoJsonHelpers', function (leafletHelpers, leafletIterators) {
+    var lHlp = leafletHelpers,
+        lIt = leafletIterators;
+    var Point = function Point(lat, lng) {
+        this.lat = lat;
+        this.lng = lng;
+        return this;
+    };
+
+    var _getLat = function _getLat(value) {
+        if (Array.isArray(value) && value.length === 2) {
+            return value[1];
+        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {
+            return +value.coordinates[1];
+        } else {
+            return +value.lat;
+        }
+    };
+
+    var _getLng = function _getLng(value) {
+        if (Array.isArray(value) && value.length === 2) {
+            return value[0];
+        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {
+            return +value.coordinates[0];
+        } else {
+            return +value.lng;
+        }
+    };
+
+    var _validateCoords = function _validateCoords(coords) {
+        if (lHlp.isUndefined(coords)) {
+            return false;
+        }
+        if (lHlp.isArray(coords)) {
+            if (coords.length === 2 && lHlp.isNumber(coords[0]) && lHlp.isNumber(coords[1])) {
+                return true;
+            }
+        } else if (lHlp.isDefined(coords.type)) {
+            if (coords.type === 'Point' && lHlp.isArray(coords.coordinates) && coords.coordinates.length === 2 && lHlp.isNumber(coords.coordinates[0]) && lHlp.isNumber(coords.coordinates[1])) {
+                return true;
+            }
+        }
+
+        var ret = lIt.all(['lat', 'lng'], function (pos) {
+            return lHlp.isDefined(coords[pos]) && lHlp.isNumber(coords[pos]);
+        });
+        return ret;
+    };
+
+    var _getCoords = function _getCoords(value) {
+        if (!value || !_validateCoords(value)) {
+            return;
+        }
+        var p = null;
+        if (Array.isArray(value) && value.length === 2) {
+            p = new Point(value[1], value[0]);
+        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {
+            p = new Point(value.coordinates[1], value.coordinates[0]);
+        } else {
+            return value;
+        }
+        //note angular.merge is avail in angular 1.4.X we might want to fill it here
+        return angular.extend(value, p); //tap on lat, lng if it doesnt exist
+    };
+
+    return {
+        getLat: _getLat,
+        getLng: _getLng,
+        validateCoords: _validateCoords,
+        getCoords: _getCoords
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletHelpers', function ($q, $log, $timeout) {
+    var _errorHeader = '[ui-leaflet] ';
+    var _copy = angular.copy;
+    var _clone = _copy;
+    /*
+    For parsing paths to a field in an object
+     Example:
+    var obj = {
+        bike:{
+         1: 'hi'
+         2: 'foo'
+        }
+    };
+    _getObjectValue(obj,"bike.1") returns 'hi'
+    this is getPath in ui-gmap
+     */
+    var _getObjectValue = function _getObjectValue(object, pathStr) {
+        var obj;
+        if (!object || !angular.isObject(object)) return;
+        //if the key is not a sting then we already have the value
+        if (pathStr === null || !angular.isString(pathStr)) {
+            return pathStr;
+        }
+        obj = object;
+        pathStr.split('.').forEach(function (value) {
+            if (obj) {
+                obj = obj[value];
+            }
+        });
+        return obj;
+    };
+
+    /*
+     Object Array Notation
+     _getObjectArrayPath("bike.one.two")
+     returns:
+     'bike["one"]["two"]'
+     */
+    var _getObjectArrayPath = function _getObjectArrayPath(pathStr) {
+        return pathStr.split('.').reduce(function (previous, current) {
+            return previous + '["' + current + '"]';
+        });
+    };
+
+    /* Object Dot Notation
+     _getObjectPath(["bike","one","two"])
+     returns:
+     "bike.one.two"
+     */
+    var _getObjectDotPath = function _getObjectDotPath(arrayOfStrings) {
+        return arrayOfStrings.reduce(function (previous, current) {
+            return previous + '.' + current;
+        });
+    };
+
+    function _obtainEffectiveMapId(d, mapId) {
+        var id, i;
+        if (!angular.isDefined(mapId)) {
+            if (Object.keys(d).length === 0) {
+                id = "main";
+            } else if (Object.keys(d).length >= 1) {
+                for (i in d) {
+                    if (d.hasOwnProperty(i)) {
+                        id = i;
+                    }
+                }
+            } else {
+                $log.error(_errorHeader + "- You have more than 1 map on the DOM, you must provide the map ID to the leafletData.getXXX call");
+            }
+        } else {
+            id = mapId;
+        }
+
+        return id;
+    }
+
+    function _getUnresolvedDefer(d, mapId) {
+        var id = _obtainEffectiveMapId(d, mapId),
+            defer;
+
+        if (!angular.isDefined(d[id]) || d[id].resolvedDefer === true) {
+            defer = $q.defer();
+            d[id] = {
+                defer: defer,
+                resolvedDefer: false
+            };
+        } else {
+            defer = d[id].defer;
+        }
+
+        return defer;
+    }
+
+    var _isDefined = function _isDefined(value) {
+        return angular.isDefined(value) && value !== null;
+    };
+    var _isUndefined = function _isUndefined(value) {
+        return !_isDefined(value);
+    };
+
+    // BEGIN DIRECT PORT FROM AngularJS code base
+
+    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
+
+    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
+
+    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
+
+    /**
+    Converts snake_case to camelCase.
+    Also there is special case for Moz prefix starting with upper case letter.
+    @param name Name to normalize
+     */
+
+    var camelCase = function camelCase(name) {
+        return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
+            if (offset) {
+                return letter.toUpperCase();
+            } else {
+                return letter;
+            }
+        }).replace(MOZ_HACK_REGEXP, "Moz$1");
+    };
+
+    /**
+        Converts all accepted directives format into proper directive name.
+        @param name Name to normalize
+    */
+
+    var directiveNormalize = function directiveNormalize(name) {
+        return camelCase(name.replace(PREFIX_REGEXP, ""));
+    };
+    // END AngularJS port
+
+    var _watchTrapDelayMilliSec = 10;
+
+    var _modelChangeInDirective = function _modelChangeInDirective(trapObj, trapField, cbToExec) {
+        if (!trapObj) throw new Error(_errorHeader + 'trapObj is undefined');
+        if (!trapField) throw new Error(_errorHeader + 'trapField is undefined');
+
+        trapObj[trapField] = true;
+        var ret = cbToExec();
+        $timeout(function () {
+            trapObj[trapField] = false;
+        }, _watchTrapDelayMilliSec);
+        return ret;
+    };
+
+    return {
+        watchTrapDelayMilliSec: _watchTrapDelayMilliSec,
+        modelChangeInDirective: _modelChangeInDirective,
+        camelCase: camelCase,
+        directiveNormalize: directiveNormalize,
+        copy: _copy,
+        clone: _clone,
+        errorHeader: _errorHeader,
+        getObjectValue: _getObjectValue,
+        getObjectArrayPath: _getObjectArrayPath,
+        getObjectDotPath: _getObjectDotPath,
+        defaultTo: function defaultTo(val, _default) {
+            return _isDefined(val) ? val : _default;
+        },
+        //mainly for checking attributes of directives lets keep this minimal (on what we accept)
+        isTruthy: function isTruthy(val) {
+            return val === 'true' || val === true;
+        },
+        //Determine if a reference is {}
+        isEmpty: function isEmpty(value) {
+            return Object.keys(value).length === 0;
+        },
+
+        //Determine if a reference is undefined or {}
+        isUndefinedOrEmpty: function isUndefinedOrEmpty(value) {
+            return angular.isUndefined(value) || value === null || Object.keys(value).length === 0;
+        },
+
+        // Determine if a reference is defined
+        isDefined: _isDefined,
+        isUndefined: _isUndefined,
+        isNumber: angular.isNumber,
+        isString: angular.isString,
+        isArray: angular.isArray,
+        isObject: angular.isObject,
+        isFunction: angular.isFunction,
+        equals: angular.equals,
+
+        isValidCenter: function isValidCenter(center) {
+            return angular.isDefined(center) && angular.isNumber(center.lat) && angular.isNumber(center.lng) && angular.isNumber(center.zoom);
+        },
+
+        isValidPoint: function isValidPoint(point) {
+            if (!angular.isDefined(point)) {
+                return false;
+            }
+            if (angular.isArray(point)) {
+                return point.length === 2 && angular.isNumber(point[0]) && angular.isNumber(point[1]);
+            }
+            return angular.isNumber(point.lat) && angular.isNumber(point.lng);
+        },
+
+        isSameCenterOnMap: function isSameCenterOnMap(centerModel, map) {
+            var mapCenter = map.getCenter();
+            var zoom = map.getZoom();
+            if (centerModel.lat && centerModel.lng && mapCenter.lat.toFixed(4) === centerModel.lat.toFixed(4) && mapCenter.lng.toFixed(4) === centerModel.lng.toFixed(4) && zoom === centerModel.zoom) {
+                return true;
+            }
+            return false;
+        },
+
+        safeApply: function safeApply($scope, fn) {
+            var phase = $scope.$root.$$phase;
+            if (phase === '$apply' || phase === '$digest') {
+                $scope.$eval(fn);
+            } else {
+                $scope.$evalAsync(fn);
+            }
+        },
+
+        obtainEffectiveMapId: _obtainEffectiveMapId,
+
+        getDefer: function getDefer(d, mapId) {
+            var id = _obtainEffectiveMapId(d, mapId),
+                defer;
+            if (!angular.isDefined(d[id]) || d[id].resolvedDefer === false) {
+                defer = _getUnresolvedDefer(d, mapId);
+            } else {
+                defer = d[id].defer;
+            }
+            return defer;
+        },
+
+        getUnresolvedDefer: _getUnresolvedDefer,
+
+        setResolvedDefer: function setResolvedDefer(d, mapId) {
+            var id = _obtainEffectiveMapId(d, mapId);
+            d[id].resolvedDefer = true;
+        },
+
+        rangeIsSupported: function rangeIsSupported() {
+            var testrange = document.createElement('input');
+            testrange.setAttribute('type', 'range');
+            return testrange.type === 'range';
+        },
+
+        FullScreenControlPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.Control.Fullscreen);
+            }
+        },
+
+        MiniMapControlPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.Control.MiniMap);
+            }
+        },
+
+        AwesomeMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.AwesomeMarkers) && angular.isDefined(L.AwesomeMarkers.Icon);
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.AwesomeMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        VectorMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.VectorMarkers) && angular.isDefined(L.VectorMarkers.Icon);
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.VectorMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        DomMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.DomMarkers) && angular.isDefined(L.DomMarkers.Icon)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.DomMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        PolylineDecoratorPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.PolylineDecorator)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(decoration) {
+                if (this.isLoaded()) {
+                    return decoration instanceof L.PolylineDecorator;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(decorationA, decorationB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(decorationA)) {
+                    return angular.equals(decorationA, decorationB);
+                } else {
+                    return false;
+                }
+            }
+        },
+
+        MakiMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.MakiMarkers) && angular.isDefined(L.MakiMarkers.Icon)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.MakiMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+        ExtraMarkersPlugin: {
+            isLoaded: function isLoaded() {
+                if (angular.isDefined(L.ExtraMarkers) && angular.isDefined(L.ExtraMarkers.Icon)) {
+                    return true;
+                } else {
+                    return false;
+                }
+            },
+            is: function is(icon) {
+                if (this.isLoaded()) {
+                    return icon instanceof L.ExtraMarkers.Icon;
+                } else {
+                    return false;
+                }
+            },
+            equal: function equal(iconA, iconB) {
+                if (!this.isLoaded()) {
+                    return false;
+                }
+                if (this.is(iconA)) {
+                    return angular.equals(iconA, iconB);
+                } else {
+                    return false;
+                }
+            }
+        },
+        LabelPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.Label);
+            },
+            is: function is(layer) {
+                if (this.isLoaded()) {
+                    return layer instanceof L.MarkerClusterGroup;
+                } else {
+                    return false;
+                }
+            }
+        },
+        MarkerClusterPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.MarkerClusterGroup);
+            },
+            is: function is(layer) {
+                if (this.isLoaded()) {
+                    return layer instanceof L.MarkerClusterGroup;
+                } else {
+                    return false;
+                }
+            }
+        },
+        GeoJSONPlugin: {
+            isLoaded: function isLoaded() {
+                return angular.isDefined(L.TileLayer.GeoJSON);
+            },
+            is: function is(layer) {
+                if (this.isLoaded()) {
+                    return layer instanceof L.TileLayer.GeoJSON;
+                } else {
+                    return false;
+                }
+            }
+        },
+        CartoDB: {
+            isLoaded: function isLoaded() {
+                return cartodb;
+            },
+            is: function is() /*layer*/{
+                return true;
+                /*
+                if (this.isLoaded()) {
+                    return layer instanceof L.TileLayer.GeoJSON;
+                } else {
+                    return false;
+                }*/
+            }
+        },
+        Leaflet: {
+            DivIcon: {
+                is: function is(icon) {
+                    return icon instanceof L.DivIcon;
+                },
+                equal: function equal(iconA, iconB) {
+                    if (this.is(iconA)) {
+                        return angular.equals(iconA, iconB);
+                    } else {
+                        return false;
+                    }
+                }
+            },
+            Icon: {
+                is: function is(icon) {
+                    return icon instanceof L.Icon;
+                },
+                equal: function equal(iconA, iconB) {
+                    if (this.is(iconA)) {
+                        return angular.equals(iconA, iconB);
+                    } else {
+                        return false;
+                    }
+                }
+            }
+        },
+        /*
+         watchOptions - object to set deep nested watches and turn off watches all together
+         (rely on control / functional updates)
+         watchOptions - Object
+             type: string. //One of ['watch', 'watchCollection', 'watchDeep', null]
+             individual
+                 type: string
+         */
+        //legacy defaults
+        watchOptions: {
+            type: 'watchDeep',
+            individual: {
+                type: 'watchDeep'
+            }
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletIterators', function (leafletLogger, leafletHelpers) {
+
+  var lHlp = leafletHelpers,
+      errorHeader = leafletHelpers.errorHeader + 'leafletIterators: ';
+
+  //BEGIN COPY from underscore
+  var _keys = Object.keys;
+  var _isFunction = lHlp.isFunction;
+  var _isObject = lHlp.isObject;
+  var $log = leafletLogger;
+
+  // Helper for collection methods to determine whether a collection
+  // should be iterated as an array or as an object
+  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
+  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
+
+  var _isArrayLike = function _isArrayLike(collection) {
+    var length = collection !== null && collection.length;
+    return lHlp.isNumber(length) && length >= 0 && length <= MAX_ARRAY_INDEX;
+  };
+
+  // Keep the identity function around for default iteratees.
+  var _identity = function _identity(value) {
+    return value;
+  };
+
+  var _property = function _property(key) {
+    return function (obj) {
+      return obj === null ? void 0 : obj[key];
+    };
+  };
+
+  // Internal function that returns an efficient (for current engines) version
+  // of the passed-in callback, to be repeatedly applied in other Underscore
+  // functions.
+  var optimizeCb = function optimizeCb(func, context, argCount) {
+    if (context === void 0) return func;
+    switch (argCount === null ? 3 : argCount) {
+      case 1:
+        return function (value) {
+          return func.call(context, value);
+        };
+      case 2:
+        return function (value, other) {
+          return func.call(context, value, other);
+        };
+      case 3:
+        return function (value, index, collection) {
+          return func.call(context, value, index, collection);
+        };
+      case 4:
+        return function (accumulator, value, index, collection) {
+          return func.call(context, accumulator, value, index, collection);
+        };
+    }
+    return function () {
+      return func.apply(context, arguments);
+    };
+  };
+
+  // An internal function for creating assigner functions.
+  var createAssigner = function createAssigner(keysFunc, undefinedOnly) {
+    return function (obj) {
+      var length = arguments.length;
+      if (length < 2 || obj === null) return obj;
+      for (var index = 1; index < length; index++) {
+        var source = arguments[index],
+            keys = keysFunc(source),
+            l = keys.length;
+        for (var i = 0; i < l; i++) {
+          var key = keys[i];
+          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
+        }
+      }
+      return obj;
+    };
+  };
+
+  // Assigns a given object with all the own properties in the passed-in object(s)
+  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
+  var _extendOwn,
+      _assign = null;
+  _extendOwn = _assign = createAssigner(_keys);
+
+  // Returns whether an object has a given set of `key:value` pairs.
+  var _isMatch = function _isMatch(object, attrs) {
+    var keys = _keys(attrs),
+        length = keys.length;
+    if (object === null) return !length;
+    var obj = Object(object);
+    for (var i = 0; i < length; i++) {
+      var key = keys[i];
+      if (attrs[key] !== obj[key] || !(key in obj)) return false;
+    }
+    return true;
+  };
+
+  // Returns a predicate for checking whether an object has a given set of
+  // `key:value` pairs.
+  var _matcher,
+      _matches = null;
+  _matcher = _matches = function _matches(attrs) {
+    attrs = _extendOwn({}, attrs);
+    return function (obj) {
+      return _isMatch(obj, attrs);
+    };
+  };
+
+  // A mostly-internal function to generate callbacks that can be applied
+  // to each element in a collection, returning the desired result  either
+  // identity, an arbitrary callback, a property matcher, or a property accessor.
+  var cb = function cb(value, context, argCount) {
+    if (value === null) return _identity;
+    if (_isFunction(value)) return optimizeCb(value, context, argCount);
+    if (_isObject(value)) return _matcher(value);
+    return _property(value);
+  };
+
+  var _every,
+      _all = null;
+  _every = _all = function _all(obj, predicate, context) {
+    predicate = cb(predicate, context);
+    var keys = !_isArrayLike(obj) && _keys(obj),
+        length = (keys || obj).length;
+    for (var index = 0; index < length; index++) {
+      var currentKey = keys ? keys[index] : index;
+      if (!predicate(obj[currentKey], currentKey, obj)) return false;
+    }
+    return true;
+  };
+
+  //END COPY fron underscore
+
+  var _hasErrors = function _hasErrors(collection, cb, ignoreCollection, cbName) {
+    if (!ignoreCollection) {
+      if (!lHlp.isDefined(collection) || !lHlp.isDefined(cb)) {
+        return true;
+      }
+    }
+    if (!lHlp.isFunction(cb)) {
+      cbName = lHlp.defaultTo(cb, 'cb');
+      $log.error(errorHeader + cbName + ' is not a function');
+      return true;
+    }
+    return false;
+  };
+
+  var _iterate = function _iterate(collection, externalCb, internalCb) {
+    if (_hasErrors(undefined, internalCb, true, 'internalCb')) {
+      return;
+    }
+    if (!_hasErrors(collection, externalCb)) {
+      for (var key in collection) {
+        if (collection.hasOwnProperty(key)) {
+          internalCb(collection[key], key);
+        }
+      }
+    }
+  };
+
+  //see http://jsperf.com/iterators/3
+  //utilizing for in is way faster
+  var _each = function _each(collection, cb) {
+    _iterate(collection, cb, function (val, key) {
+      cb(val, key);
+    });
+  };
+
+  return {
+    each: _each,
+    forEach: _each,
+    every: _every,
+    all: _all
+  };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletLayerHelpers', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletIterators) {
+    var Helpers = leafletHelpers;
+    var isString = leafletHelpers.isString;
+    var isObject = leafletHelpers.isObject;
+    var isArray = leafletHelpers.isArray;
+    var isDefined = leafletHelpers.isDefined;
+    var errorHeader = leafletHelpers.errorHeader;
+    var $it = leafletIterators;
+    var $log = leafletLogger;
+
+    var utfGridCreateLayer = function utfGridCreateLayer(params) {
+        if (!Helpers.UTFGridPlugin.isLoaded()) {
+            $log.error('[AngularJS - Leaflet] The UTFGrid plugin is not loaded.');
+            return;
+        }
+        var utfgrid = new L.UtfGrid(params.url, params.pluginOptions);
+
+        var toSend = {
+            model: params.$parent
+        };
+
+        // TODO Use event manager
+        utfgrid.on('mouseover', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseover', toSend);
+        });
+
+        utfgrid.on('mouseout', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseout', toSend);
+        });
+
+        utfgrid.on('click', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridClick', toSend);
+        });
+
+        utfgrid.on('mousemove', function (e) {
+            angular.extend(toSend, {
+                leafletEvent: e,
+                leafletObject: e.target
+            });
+            $rootScope.$broadcast('leafletDirectiveMap.utfgridMousemove', toSend);
+        });
+
+        return utfgrid;
+    };
+
+    var layerTypes = {
+        xyz: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer(params.url, params.options);
+            }
+        },
+        geoJSON: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                if (!Helpers.GeoJSONPlugin.isLoaded()) {
+                    return;
+                }
+                return new L.TileLayer.GeoJSON(params.url, params.pluginOptions, params.options);
+            }
+        },
+        geoJSONShape: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                return new L.GeoJSON(params.data, params.options);
+            }
+        },
+        geoJSONAwesomeMarker: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                return new L.geoJson(params.data, {
+                    pointToLayer: function pointToLayer(feature, latlng) {
+                        return L.marker(latlng, { icon: L.AwesomeMarkers.icon(params.icon) });
+                    }
+                });
+            }
+        },
+        geoJSONVectorMarker: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                return new L.geoJson(params.data, {
+                    pointToLayer: function pointToLayer(feature, latlng) {
+                        return L.marker(latlng, { icon: L.VectorMarkers.icon(params.icon) });
+                    }
+                });
+            }
+        },
+        cartodbTiles: {
+            mustHaveKey: true,
+            createLayer: function createLayer(params) {
+                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';
+                url += '/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';
+                return L.tileLayer(url, params.options);
+            }
+        },
+        cartodbUTFGrid: {
+            mustHaveKey: true,
+            mustHaveLayer: true,
+            createLayer: function createLayer(params) {
+                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';
+                params.url = url + '/api/v1/map/' + params.key + '/' + params.layer + '/{z}/{x}/{y}.grid.json';
+                return utfGridCreateLayer(params);
+            }
+        },
+        cartodbInteractive: {
+            mustHaveKey: true,
+            mustHaveLayer: true,
+            createLayer: function createLayer(params) {
+                var url = isDefined(params.url) ? params.url + '/' + params.user : '//' + params.user + '.cartodb.com';
+                var tilesURL = url + '/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';
+                var tileLayer = L.tileLayer(tilesURL, params.options);
+                var layers = [tileLayer];
+
+                var addUtfLayer = function addUtfLayer(parent, params, layer) {
+                    var paramsCopy = angular.copy(params);
+                    paramsCopy.url = url + '/api/v1/map/' + paramsCopy.key + '/' + layer + '/{z}/{x}/{y}.grid.json';
+                    parent.push(utfGridCreateLayer(paramsCopy));
+                };
+
+                if (isArray(params.layer)) {
+                    for (var i = 0; i < params.layer.length; i++) {
+                        addUtfLayer(layers, params, params.layer[i]);
+                    }
+                } else {
+                    addUtfLayer(layers, params, params.layer);
+                }
+                return L.layerGroup(layers);
+            }
+        },
+        wms: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer.wms(params.url, params.options);
+            }
+        },
+        wmts: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer.wmts(params.url, params.options);
+            }
+        },
+        group: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                var lyrs = [];
+                $it.each(params.options.layers, function (l) {
+                    lyrs.push(_createLayer(l));
+                });
+                params.options.loadedDefer = function () {
+                    var defers = [];
+                    if (isDefined(params.options.layers)) {
+                        for (var i = 0; i < params.options.layers.length; i++) {
+                            var d = params.options.layers[i].layerOptions.loadedDefer;
+                            if (isDefined(d)) {
+                                defers.push(d);
+                            }
+                        }
+                    }
+                    return defers;
+                };
+                return L.layerGroup(lyrs);
+            }
+        },
+        featureGroup: {
+            mustHaveUrl: false,
+            createLayer: function createLayer() {
+                return L.featureGroup();
+            }
+        },
+        markercluster: {
+            mustHaveUrl: false,
+            createLayer: function createLayer(params) {
+                if (!Helpers.MarkerClusterPlugin.isLoaded()) {
+                    $log.warn(errorHeader + ' The markercluster plugin is not loaded.');
+                    return;
+                }
+                return new L.MarkerClusterGroup(params.options);
+            }
+        },
+        imageOverlay: {
+            mustHaveUrl: true,
+            mustHaveBounds: true,
+            createLayer: function createLayer(params) {
+                return L.imageOverlay(params.url, params.bounds, params.options);
+            }
+        },
+        iip: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return L.tileLayer.iip(params.url, params.options);
+            }
+        },
+
+        // This "custom" type is used to accept every layer that user want to define himself.
+        // We can wrap these custom layers like heatmap or yandex, but it means a lot of work/code to wrap the world,
+        // so we let user to define their own layer outside the directive,
+        // and pass it on "createLayer" result for next processes
+        custom: {
+            createLayer: function createLayer(params) {
+                if (params.layer instanceof L.Class) {
+                    return angular.copy(params.layer);
+                } else {
+                    $log.error('[AngularJS - Leaflet] A custom layer must be a leaflet Class');
+                }
+            }
+        },
+        cartodb: {
+            mustHaveUrl: true,
+            createLayer: function createLayer(params) {
+                return cartodb.createLayer(params.map, params.url);
+            }
+        }
+    };
+
+    function isValidLayerType(layerDefinition) {
+        // Check if the baselayer has a valid type
+        if (!isString(layerDefinition.type)) {
+            $log.error('[AngularJS - Leaflet] A layer must have a valid type defined.');
+            return false;
+        }
+
+        if (Object.keys(layerTypes).indexOf(layerDefinition.type) === -1) {
+            $log.error('[AngularJS - Leaflet] A layer must have a valid type: ' + Object.keys(layerTypes));
+            return false;
+        }
+
+        // Check if the layer must have an URL
+        if (layerTypes[layerDefinition.type].mustHaveUrl && !isString(layerDefinition.url)) {
+            $log.error('[AngularJS - Leaflet] A base layer must have an url');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveData && !isDefined(layerDefinition.data)) {
+            $log.error('[AngularJS - Leaflet] The base layer must have a "data" array attribute');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveLayer && !isDefined(layerDefinition.layer)) {
+            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have an layer defined');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveBounds && !isDefined(layerDefinition.bounds)) {
+            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have bounds defined');
+            return false;
+        }
+
+        if (layerTypes[layerDefinition.type].mustHaveKey && !isDefined(layerDefinition.key)) {
+            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have key defined');
+            return false;
+        }
+        return true;
+    }
+
+    function _createLayer(layerDefinition) {
+        if (!isValidLayerType(layerDefinition)) {
+            return;
+        }
+
+        if (!isString(layerDefinition.name)) {
+            $log.error('[AngularJS - Leaflet] A base layer must have a name');
+            return;
+        }
+        if (!isObject(layerDefinition.layerParams)) {
+            layerDefinition.layerParams = {};
+        }
+        if (!isObject(layerDefinition.layerOptions)) {
+            layerDefinition.layerOptions = {};
+        }
+
+        // Mix the layer specific parameters with the general Leaflet options. Although this is an overhead
+        // the definition of a base layers is more 'clean' if the two types of parameters are differentiated
+        for (var attrname in layerDefinition.layerParams) {
+            layerDefinition.layerOptions[attrname] = layerDefinition.layerParams[attrname];
+        }
+
+        var params = {
+            url: layerDefinition.url,
+            data: layerDefinition.data,
+            options: layerDefinition.layerOptions,
+            layer: layerDefinition.layer,
+            icon: layerDefinition.icon,
+            type: layerDefinition.layerType,
+            bounds: layerDefinition.bounds,
+            key: layerDefinition.key,
+            apiKey: layerDefinition.apiKey,
+            pluginOptions: layerDefinition.pluginOptions,
+            user: layerDefinition.user,
+            $parent: layerDefinition
+        };
+
+        //TODO Add $watch to the layer properties
+        return layerTypes[layerDefinition.type].createLayer(params);
+    }
+
+    function safeAddLayer(map, layer) {
+        if (layer && typeof layer.addTo === 'function') {
+            layer.addTo(map);
+        } else {
+            map.addLayer(layer);
+        }
+    }
+
+    function safeRemoveLayer(map, layer, layerOptions) {
+        if (isDefined(layerOptions) && isDefined(layerOptions.loadedDefer)) {
+            if (angular.isFunction(layerOptions.loadedDefer)) {
+                var defers = layerOptions.loadedDefer();
+                $log.debug('Loaded Deferred', defers);
+                var count = defers.length;
+                if (count > 0) {
+                    var resolve = function resolve() {
+                        count--;
+                        if (count === 0) {
+                            map.removeLayer(layer);
+                        }
+                    };
+
+                    for (var i = 0; i < defers.length; i++) {
+                        defers[i].promise.then(resolve);
+                    }
+                } else {
+                    map.removeLayer(layer);
+                }
+            } else {
+                layerOptions.loadedDefer.promise.then(function () {
+                    map.removeLayer(layer);
+                });
+            }
+        } else {
+            map.removeLayer(layer);
+        }
+    }
+
+    var changeOpacityListener = function changeOpacityListener(op) {
+        return function (ly) {
+            if (isDefined(ly.setOpacity)) {
+                ly.setOpacity(op);
+            }
+        };
+    };
+
+    return {
+        createLayer: _createLayer,
+        layerTypes: layerTypes,
+        safeAddLayer: safeAddLayer,
+        safeRemoveLayer: safeRemoveLayer,
+        changeOpacityListener: changeOpacityListener
+    };
+});
+
+'use strict';
+
+angular.module("ui-leaflet").factory('leafletLegendHelpers', function ($http, $q, $log, leafletHelpers) {
+	var requestQueue = {},
+	    isDefined = leafletHelpers.isDefined;
+
+	var _execNext = function _execNext(mapId) {
+		var queue = requestQueue[mapId];
+		var task = queue[0];
+		$http(task.c).then(function (data) {
+			queue.shift();
+			task.d.resolve(data);
+			if (queue.length > 0) {
+				_execNext(mapId);
+			}
+		}, function (err) {
+			queue.shift();
+			task.d.reject(err);
+			if (queue.length > 0) {
+				_execNext(mapId);
+			}
+		});
+	};
+
+	var _updateLegend = function _updateLegend(div, legendData, type, url) {
+		div.innerHTML = '';
+		if (legendData.error) {
+			div.innerHTML += '<div class="info-title alert alert-danger">' + legendData.error.message + '</div>';
+		} else {
+			if (type === 'arcgis') {
+				for (var i = 0; i < legendData.layers.length; i++) {
+					var layer = legendData.layers[i];
+					div.innerHTML += '<div class="info-title" data-layerid="' + layer.layerId + '">' + layer.layerName + '</div>';
+					for (var j = 0; j < layer.legend.length; j++) {
+						var leg = layer.legend[j];
+						div.innerHTML += '<div class="inline" data-layerid="' + layer.layerId + '"><img src="data:' + leg.contentType + ';base64,' + leg.imageData + '" /></div>' + '<div class="info-label" data-layerid="' + layer.layerId + '">' + leg.label + '</div>';
+					}
+				}
+			} else if (type === 'image') {
+				div.innerHTML = '<img src="' + url + '"/>';
+			}
+		}
+	};
+
+	var _getOnAddLegend = function _getOnAddLegend(legendData, legendClass, type, url) {
+		return function () /*map*/{
+			var div = L.DomUtil.create('div', legendClass);
+
+			if (!L.Browser.touch) {
+				L.DomEvent.disableClickPropagation(div);
+				L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
+			} else {
+				L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
+			}
+			_updateLegend(div, legendData, type, url);
+			return div;
+		};
+	};
+
+	var _getOnAddArrayLegend = function _getOnAddArrayLegend(legend, legendClass) {
+		return function () /*map*/{
+			var div = L.DomUtil.create('div', legendClass);
+			for (var i = 0; i < legend.colors.length; i++) {
+				div.innerHTML += '<div class="outline"><i style="background:' + legend.colors[i] + '"></i></div>' + '<div class="info-label">' + legend.labels[i] + '</div>';
+			}
+			if (!L.Browser.touch) {
+				L.DomEvent.disableClickPropagation(div);
+				L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
+			} else {
+				L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
+			}
+			return div;
+		};
+	};
+
+	return {
+		getOnAddLegend: _getOnAddLegend,
+		getOnAddArrayLegend: _getOnAddArrayLegend,
+		updateLegend: _updateLegend,
+		addLegendURL: function addLegendURL(mapId, config) {
+			var d = $q.defer();
+			if (!isDefined(requestQueue[mapId])) {
+				requestQueue[mapId] = [];
+			}
+			requestQueue[mapId].push({ c: config, d: d });
+			if (requestQueue[mapId].length === 1) {
+				_execNext(mapId);
+			}
+			return d.promise;
+		}
+	};
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletMapDefaults', function ($q, leafletHelpers) {
+    function _getDefaults() {
+        return {
+            keyboard: true,
+            dragging: true,
+            worldCopyJump: false,
+            doubleClickZoom: true,
+            scrollWheelZoom: true,
+            tap: true,
+            touchZoom: true,
+            zoomControl: true,
+            zoomsliderControl: false,
+            zoomControlPosition: 'topleft',
+            attributionControl: true,
+            controls: {
+                layers: {
+                    visible: true,
+                    position: 'topright',
+                    collapsed: true
+                }
+            },
+            nominatim: {
+                server: ' http://nominatim.openstreetmap.org/search'
+            },
+            crs: L.CRS.EPSG3857,
+            tileLayer: '//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
+            tileLayerOptions: {
+                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
+            },
+            path: {
+                weight: 10,
+                opacity: 1,
+                color: '#0000ff'
+            },
+            center: {
+                lat: 0,
+                lng: 0,
+                zoom: 1
+            },
+            trackResize: true
+        };
+    }
+
+    var isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        obtainEffectiveMapId = leafletHelpers.obtainEffectiveMapId,
+        defaults = {};
+
+    // Get the _defaults dictionary, and override the properties defined by the user
+    return {
+        reset: function reset() {
+            defaults = {};
+        },
+        getDefaults: function getDefaults(scopeId) {
+            var mapId = obtainEffectiveMapId(defaults, scopeId);
+            return defaults[mapId];
+        },
+
+        getMapCreationDefaults: function getMapCreationDefaults(scopeId) {
+            var mapId = obtainEffectiveMapId(defaults, scopeId);
+            var d = defaults[mapId];
+
+            var mapDefaults = {
+                maxZoom: d.maxZoom,
+                keyboard: d.keyboard,
+                dragging: d.dragging,
+                zoomControl: d.zoomControl,
+                doubleClickZoom: d.doubleClickZoom,
+                scrollWheelZoom: d.scrollWheelZoom,
+                tap: d.tap,
+                touchZoom: d.touchZoom,
+                attributionControl: d.attributionControl,
+                worldCopyJump: d.worldCopyJump,
+                crs: d.crs,
+                trackResize: d.trackResize
+            };
+
+            if (isDefined(d.minZoom)) {
+                mapDefaults.minZoom = d.minZoom;
+            }
+
+            if (isDefined(d.zoomAnimation)) {
+                mapDefaults.zoomAnimation = d.zoomAnimation;
+            }
+
+            if (isDefined(d.fadeAnimation)) {
+                mapDefaults.fadeAnimation = d.fadeAnimation;
+            }
+
+            if (isDefined(d.markerZoomAnimation)) {
+                mapDefaults.markerZoomAnimation = d.markerZoomAnimation;
+            }
+
+            if (d.map) {
+                for (var option in d.map) {
+                    mapDefaults[option] = d.map[option];
+                }
+            }
+
+            return mapDefaults;
+        },
+
+        setDefaults: function setDefaults(userDefaults, scopeId) {
+            var newDefaults = _getDefaults();
+
+            if (isDefined(userDefaults)) {
+                newDefaults.doubleClickZoom = isDefined(userDefaults.doubleClickZoom) ? userDefaults.doubleClickZoom : newDefaults.doubleClickZoom;
+                newDefaults.scrollWheelZoom = isDefined(userDefaults.scrollWheelZoom) ? userDefaults.scrollWheelZoom : newDefaults.doubleClickZoom;
+                newDefaults.tap = isDefined(userDefaults.tap) ? userDefaults.tap : newDefaults.tap;
+                newDefaults.touchZoom = isDefined(userDefaults.touchZoom) ? userDefaults.touchZoom : newDefaults.doubleClickZoom;
+                newDefaults.zoomControl = isDefined(userDefaults.zoomControl) ? userDefaults.zoomControl : newDefaults.zoomControl;
+                newDefaults.zoomsliderControl = isDefined(userDefaults.zoomsliderControl) ? userDefaults.zoomsliderControl : newDefaults.zoomsliderControl;
+                newDefaults.attributionControl = isDefined(userDefaults.attributionControl) ? userDefaults.attributionControl : newDefaults.attributionControl;
+                newDefaults.tileLayer = isDefined(userDefaults.tileLayer) ? userDefaults.tileLayer : newDefaults.tileLayer;
+                newDefaults.zoomControlPosition = isDefined(userDefaults.zoomControlPosition) ? userDefaults.zoomControlPosition : newDefaults.zoomControlPosition;
+                newDefaults.keyboard = isDefined(userDefaults.keyboard) ? userDefaults.keyboard : newDefaults.keyboard;
+                newDefaults.dragging = isDefined(userDefaults.dragging) ? userDefaults.dragging : newDefaults.dragging;
+                newDefaults.trackResize = isDefined(userDefaults.trackResize) ? userDefaults.trackResize : newDefaults.trackResize;
+
+                if (isDefined(userDefaults.controls)) {
+                    angular.extend(newDefaults.controls, userDefaults.controls);
+                }
+
+                if (isObject(userDefaults.crs)) {
+                    newDefaults.crs = userDefaults.crs;
+                } else if (isDefined(L.CRS[userDefaults.crs])) {
+                    newDefaults.crs = L.CRS[userDefaults.crs];
+                }
+
+                if (isDefined(userDefaults.center)) {
+                    angular.copy(userDefaults.center, newDefaults.center);
+                }
+
+                if (isDefined(userDefaults.tileLayerOptions)) {
+                    angular.copy(userDefaults.tileLayerOptions, newDefaults.tileLayerOptions);
+                }
+
+                if (isDefined(userDefaults.maxZoom)) {
+                    newDefaults.maxZoom = userDefaults.maxZoom;
+                }
+
+                if (isDefined(userDefaults.minZoom)) {
+                    newDefaults.minZoom = userDefaults.minZoom;
+                }
+
+                if (isDefined(userDefaults.zoomAnimation)) {
+                    newDefaults.zoomAnimation = userDefaults.zoomAnimation;
+                }
+
+                if (isDefined(userDefaults.fadeAnimation)) {
+                    newDefaults.fadeAnimation = userDefaults.fadeAnimation;
+                }
+
+                if (isDefined(userDefaults.markerZoomAnimation)) {
+                    newDefaults.markerZoomAnimation = userDefaults.markerZoomAnimation;
+                }
+
+                if (isDefined(userDefaults.worldCopyJump)) {
+                    newDefaults.worldCopyJump = userDefaults.worldCopyJump;
+                }
+
+                if (isDefined(userDefaults.map)) {
+                    newDefaults.map = userDefaults.map;
+                }
+
+                if (isDefined(userDefaults.path)) {
+                    newDefaults.path = userDefaults.path;
+                }
+            }
+
+            var mapId = obtainEffectiveMapId(defaults, scopeId);
+            defaults[mapId] = newDefaults;
+            return newDefaults;
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletMarkersHelpers', function ($rootScope, $timeout, leafletHelpers, leafletLogger, $compile, leafletGeoJsonHelpers, leafletWatchHelpers) {
+    var isDefined = leafletHelpers.isDefined,
+        defaultTo = leafletHelpers.defaultTo,
+        MarkerClusterPlugin = leafletHelpers.MarkerClusterPlugin,
+        AwesomeMarkersPlugin = leafletHelpers.AwesomeMarkersPlugin,
+        VectorMarkersPlugin = leafletHelpers.VectorMarkersPlugin,
+        MakiMarkersPlugin = leafletHelpers.MakiMarkersPlugin,
+        ExtraMarkersPlugin = leafletHelpers.ExtraMarkersPlugin,
+        DomMarkersPlugin = leafletHelpers.DomMarkersPlugin,
+        safeApply = leafletHelpers.safeApply,
+        Helpers = leafletHelpers,
+        isString = leafletHelpers.isString,
+        isNumber = leafletHelpers.isNumber,
+        isObject = leafletHelpers.isObject,
+        groups = {},
+        geoHlp = leafletGeoJsonHelpers,
+        errorHeader = leafletHelpers.errorHeader,
+        maybeWatch = leafletWatchHelpers.maybeWatch,
+        $log = leafletLogger;
+
+    var _string = function _string(marker) {
+        //this exists since JSON.stringify barfs on cyclic
+        var retStr = '';
+        ['_icon', '_latlng', '_leaflet_id', '_map', '_shadow'].forEach(function (prop) {
+            retStr += prop + ': ' + defaultTo(marker[prop], 'undefined') + ' \n';
+        });
+        return '[leafletMarker] : \n' + retStr;
+    };
+    var _log = function _log(marker, useConsole) {
+        var logger = useConsole ? console : $log;
+        logger.debug(_string(marker));
+    };
+
+    var existDomContainer = function existDomContainer(groupName) {
+        return angular.element(groups[groupName]._map._container).parent().length > 0;
+    };
+
+    var createLeafletIcon = function createLeafletIcon(iconData) {
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'awesomeMarker') {
+            if (!AwesomeMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + ' The AwesomeMarkers Plugin is not loaded.');
+            }
+
+            return new L.AwesomeMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'vectorMarker') {
+            if (!VectorMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + ' The VectorMarkers Plugin is not loaded.');
+            }
+
+            return new L.VectorMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'makiMarker') {
+            if (!MakiMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + 'The MakiMarkers Plugin is not loaded.');
+            }
+
+            return new L.MakiMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'extraMarker') {
+            if (!ExtraMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + 'The ExtraMarkers Plugin is not loaded.');
+            }
+            return new L.ExtraMarkers.icon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'div') {
+            return new L.divIcon(iconData);
+        }
+
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'dom') {
+            if (!DomMarkersPlugin.isLoaded()) {
+                $log.error(errorHeader + 'The DomMarkers Plugin is not loaded.');
+            }
+            var markerScope = angular.isFunction(iconData.getMarkerScope) ? iconData.getMarkerScope().$new() : $rootScope,
+                template = $compile(iconData.template)(markerScope),
+                iconDataCopy = angular.copy(iconData);
+            iconDataCopy.ngElement = template;
+            iconDataCopy.element = template[0];
+            if (angular.isFunction(iconData.getMarkerScope)) iconDataCopy.scope = markerScope;
+            return new L.DomMarkers.icon(iconDataCopy);
+        }
+
+        // allow for any custom icon to be used... assumes the icon has already been initialized
+        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'icon') {
+            return iconData.icon;
+        }
+
+        var base64icon = "data:image/png;base64,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";
+        var base64shadow = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=";
+
+        if (!isDefined(iconData) || !isDefined(iconData.iconUrl)) {
+            return new L.Icon.Default({
+                iconUrl: base64icon,
+                shadowUrl: base64shadow,
+                iconSize: [25, 41],
+                iconAnchor: [12, 41],
+                popupAnchor: [1, -34],
+                shadowSize: [41, 41]
+            });
+        }
+
+        return new L.Icon(iconData);
+    };
+
+    var _resetMarkerGroup = function _resetMarkerGroup(groupName) {
+        if (isDefined(groups[groupName])) {
+            delete groups[groupName];
+        }
+    };
+
+    var _resetMarkerGroups = function _resetMarkerGroups() {
+        groups = {};
+    };
+
+    var _resetUnusedMarkerGroups = function _resetUnusedMarkerGroups() {
+        for (var groupName in groups) {
+            if (!existDomContainer(groupName)) {
+                _resetMarkerGroup(groupName);
+            }
+        }
+    };
+
+    var _cleanDomIcon = function _cleanDomIcon(marker) {
+        if (marker.options.icon.options.ngElement) {
+            marker.options.icon.options.ngElement.remove();
+        }
+        if (marker.options.icon.options.scope) {
+            marker.options.icon.options.scope.$destroy();
+        }
+    };
+
+    var _deleteMarker = function _deleteMarker(marker, map, layers) {
+        marker.closePopup();
+
+        // if it's a dom icon, clean it
+        if (marker.options.icon && marker.options.icon.options && marker.options.icon.options.type === 'dom') {
+            _cleanDomIcon(marker);
+        }
+
+        // There is no easy way to know if a marker is added to a layer, so we search for it
+        // if there are overlays
+        if (isDefined(layers) && isDefined(layers.overlays)) {
+            for (var key in layers.overlays) {
+                if (layers.overlays[key] instanceof L.LayerGroup || layers.overlays[key] instanceof L.FeatureGroup) {
+                    if (layers.overlays[key].hasLayer(marker)) {
+                        layers.overlays[key].removeLayer(marker);
+                        return;
+                    }
+                }
+            }
+        }
+
+        if (isDefined(groups)) {
+            for (var groupKey in groups) {
+                if (groups[groupKey].hasLayer(marker)) {
+                    groups[groupKey].removeLayer(marker);
+                }
+            }
+        }
+
+        if (map.hasLayer(marker)) {
+            map.removeLayer(marker);
+        }
+    };
+
+    var adjustPopupPan = function adjustPopupPan(marker, map) {
+        var containerHeight = marker._popup._container.offsetHeight,
+            layerPos = new L.Point(marker._popup._containerLeft, -containerHeight - marker._popup._containerBottom),
+            containerPos = map.layerPointToContainerPoint(layerPos);
+        if (containerPos !== null) {
+            marker._popup._adjustPan();
+        }
+    };
+
+    var compilePopup = function compilePopup(marker, markerScope) {
+        $compile(marker._popup._contentNode)(markerScope);
+    };
+
+    var updatePopup = function updatePopup(marker, markerScope, map) {
+        //The innerText should be more than 1 once angular has compiled.
+        //We need to keep trying until angular has compiled before we _updateLayout and _updatePosition
+        //This should take care of any scenario , eg ngincludes, whatever.
+        //Is there a better way to check for this?
+        var innerText = marker._popup._contentNode.innerText || marker._popup._contentNode.textContent;
+        if (innerText.length < 1) {
+            $timeout(function () {
+                updatePopup(marker, markerScope, map);
+            });
+        }
+
+        //cause a reflow - this is also very important - if we don't do this then the widths are from before $compile
+        var reflow = marker._popup._contentNode.offsetWidth;
+
+        marker._popup._updateLayout();
+        marker._popup._updatePosition();
+
+        if (marker._popup.options.autoPan) {
+            adjustPopupPan(marker, map);
+        }
+
+        //using / returning reflow so jshint doesn't moan
+        return reflow;
+    };
+
+    var _manageOpenPopup = function _manageOpenPopup(marker, markerData, map) {
+        // The marker may provide a scope returning function used to compile the message
+        // default to $rootScope otherwise
+        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,
+            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;
+
+        if (compileMessage) {
+            if (!isDefined(marker._popup) || !isDefined(marker._popup._contentNode)) {
+                $log.error(errorHeader + 'Popup is invalid or does not have any content.');
+                return false;
+            }
+
+            compilePopup(marker, markerScope);
+            updatePopup(marker, markerData, map);
+        }
+    };
+
+    var _manageOpenLabel = function _manageOpenLabel(marker, markerData) {
+        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,
+            labelScope = angular.isFunction(markerData.getLabelScope) ? markerData.getLabelScope() : markerScope,
+            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;
+
+        if (Helpers.LabelPlugin.isLoaded() && isDefined(markerData.label)) {
+            if (isDefined(markerData.label.options) && markerData.label.options.noHide === true) {
+                marker.showLabel();
+            }
+            if (compileMessage && isDefined(marker.label)) {
+                $compile(marker.label._container)(labelScope);
+            }
+        }
+    };
+
+    var _updateMarker = function _updateMarker(markerData, oldMarkerData, marker, name, leafletScope, layers, map) {
+        if (!isDefined(oldMarkerData)) {
+            return;
+        }
+
+        // Update the lat-lng property (always present in marker properties)
+        if (!geoHlp.validateCoords(markerData)) {
+            $log.warn('There are problems with lat-lng data, please verify your marker model');
+            _deleteMarker(marker, map, layers);
+            return;
+        }
+
+        // watch is being initialized if old and new object is the same
+        var isInitializing = markerData === oldMarkerData;
+
+        // Update marker rotation
+        if (isDefined(markerData.iconAngle) && oldMarkerData.iconAngle !== markerData.iconAngle) {
+            marker.setIconAngle(markerData.iconAngle);
+        }
+
+        // It is possible that the layer has been removed or the layer marker does not exist
+        // Update the layer group if present or move it to the map if not
+        if (!isString(markerData.layer)) {
+            // There is no layer information, we move the marker to the map if it was in a layer group
+            if (isString(oldMarkerData.layer)) {
+                // Remove from the layer group that is supposed to be
+                if (isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {
+                    layers.overlays[oldMarkerData.layer].removeLayer(marker);
+                    marker.closePopup();
+                }
+                // Test if it is not on the map and add it
+                if (!map.hasLayer(marker)) {
+                    map.addLayer(marker);
+                }
+            }
+        }
+
+        if ((isNumber(markerData.opacity) || isNumber(parseFloat(markerData.opacity))) && markerData.opacity !== oldMarkerData.opacity) {
+            // There was a different opacity so we update it
+            marker.setOpacity(markerData.opacity);
+        }
+
+        if (isString(markerData.layer) && oldMarkerData.layer !== markerData.layer) {
+            // If it was on a layer group we have to remove it
+            if (isString(oldMarkerData.layer) && isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {
+                layers.overlays[oldMarkerData.layer].removeLayer(marker);
+            }
+            marker.closePopup();
+
+            // Remove it from the map in case the new layer is hidden or there is an error in the new layer
+            if (map.hasLayer(marker)) {
+                map.removeLayer(marker);
+            }
+
+            // The markerData.layer is defined so we add the marker to the layer if it is different from the old data
+            if (!isDefined(layers.overlays[markerData.layer])) {
+                $log.error(errorHeader + 'You must use a name of an existing layer');
+                return;
+            }
+            // Is a group layer?
+            var layerGroup = layers.overlays[markerData.layer];
+            if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {
+                $log.error(errorHeader + 'A marker can only be added to a layer of type "group" or "featureGroup"');
+                return;
+            }
+            // The marker goes to a correct layer group, so first of all we add it
+            layerGroup.addLayer(marker);
+            // The marker is automatically added to the map depending on the visibility
+            // of the layer, so we only have to open the popup if the marker is in the map
+            if (map.hasLayer(marker) && markerData.focus === true) {
+                marker.openPopup();
+            }
+        }
+
+        // Update the draggable property
+        if (markerData.draggable !== true && oldMarkerData.draggable === true && isDefined(marker.dragging)) {
+            marker.dragging.disable();
+        }
+
+        if (markerData.draggable === true && oldMarkerData.draggable !== true) {
+            // The markerData.draggable property must be true so we update if there wasn't a previous value or it wasn't true
+            if (marker.dragging) {
+                marker.dragging.enable();
+            } else {
+                if (L.Handler.MarkerDrag) {
+                    marker.dragging = new L.Handler.MarkerDrag(marker);
+                    marker.options.draggable = true;
+                    marker.dragging.enable();
+                }
+            }
+        }
+
+        // Update the icon property
+        if (!isObject(markerData.icon)) {
+            // If there is no icon property or it's not an object
+            if (isObject(oldMarkerData.icon)) {
+                if (oldMarkerData.icon.type === 'dom') {
+                    // clean previous icon if it's a dom one
+                    _cleanDomIcon(marker);
+                }
+                // If there was an icon before restore to the default
+                marker.setIcon(createLeafletIcon());
+                marker.closePopup();
+                marker.unbindPopup();
+                if (isString(markerData.message)) {
+                    marker.bindPopup(markerData.message, markerData.popupOptions);
+                }
+            }
+        }
+
+        if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {
+            var dragG = false;
+            if (marker.dragging) {
+                dragG = marker.dragging.enabled();
+            }
+            if (oldMarkerData.icon.type === 'dom') {
+                // clean previous icon if it's a dom one
+                _cleanDomIcon(marker);
+            }
+            marker.setIcon(createLeafletIcon(markerData.icon));
+            if (dragG) {
+                marker.dragging.enable();
+            }
+            marker.closePopup();
+            marker.unbindPopup();
+            if (isString(markerData.message)) {
+                marker.bindPopup(markerData.message, markerData.popupOptions);
+                // if marker has been already focused, reopen popup
+                if (map.hasLayer(marker) && markerData.focus === true) {
+                    marker.openPopup();
+                }
+            }
+        }
+
+        // Update the Popup message property
+        if (!isString(markerData.message) && isString(oldMarkerData.message)) {
+            marker.closePopup();
+            marker.unbindPopup();
+        }
+
+        // Update the label content or bind a new label if the old one has been removed.
+        if (Helpers.LabelPlugin.isLoaded()) {
+            if (isDefined(markerData.label) && isDefined(markerData.label.message)) {
+                if ('label' in oldMarkerData && 'message' in oldMarkerData.label && !angular.equals(markerData.label.message, oldMarkerData.label.message)) {
+                    marker.updateLabelContent(markerData.label.message);
+                } else if (!angular.isFunction(marker.getLabel) || angular.isFunction(marker.getLabel) && !isDefined(marker.getLabel())) {
+                    marker.bindLabel(markerData.label.message, markerData.label.options);
+                    _manageOpenLabel(marker, markerData);
+                } else {
+                    _manageOpenLabel(marker, markerData);
+                }
+            } else if (!('label' in markerData && !('message' in markerData.label))) {
+                if (angular.isFunction(marker.unbindLabel)) {
+                    marker.unbindLabel();
+                }
+            }
+        }
+
+        // There is some text in the popup, so we must show the text or update existing
+        if (isString(markerData.message) && !isString(oldMarkerData.message)) {
+            // There was no message before so we create it
+            marker.bindPopup(markerData.message, markerData.popupOptions);
+        }
+
+        if (isString(markerData.message) && isString(oldMarkerData.message) && markerData.message !== oldMarkerData.message) {
+            // There was a different previous message so we update it
+            marker.setPopupContent(markerData.message);
+        }
+
+        // Update the focus property
+        var updatedFocus = false;
+        if (markerData.focus !== true && oldMarkerData.focus === true) {
+            // If there was a focus property and was true we turn it off
+            marker.closePopup();
+            updatedFocus = true;
+        }
+
+        // The markerData.focus property must be true so we update if there wasn't a previous value or it wasn't true
+        if (markerData.focus === true && (!isDefined(oldMarkerData.focus) || oldMarkerData.focus === false) || isInitializing && markerData.focus === true) {
+            // Reopen the popup when focus is still true
+            marker.openPopup();
+            updatedFocus = true;
+        }
+
+        // zIndexOffset adjustment
+        if (oldMarkerData.zIndexOffset !== markerData.zIndexOffset) {
+            marker.setZIndexOffset(markerData.zIndexOffset);
+        }
+
+        var markerLatLng = marker.getLatLng();
+        var isCluster = isString(markerData.layer) && Helpers.MarkerClusterPlugin.is(layers.overlays[markerData.layer]);
+        // If the marker is in a cluster it has to be removed and added to the layer when the location is changed
+        if (isCluster) {
+            // The focus has changed even by a user click or programatically
+            if (updatedFocus) {
+                // We only have to update the location if it was changed programatically, because it was
+                // changed by a user drag the marker data has already been updated by the internal event
+                // listened by the directive
+                if (markerData.lat !== oldMarkerData.lat || markerData.lng !== oldMarkerData.lng) {
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    marker.setLatLng([markerData.lat, markerData.lng]);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                }
+            } else {
+                // The marker has possibly moved. It can be moved by a user drag (marker location and data are equal but old
+                // data is diferent) or programatically (marker location and data are diferent)
+                if (markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng) {
+                    // The marker was moved by a user drag
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    marker.setLatLng([markerData.lat, markerData.lng]);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                } else if (markerData.lat !== oldMarkerData.lat || markerData.lng !== oldMarkerData.lng) {
+                    // The marker was moved programatically
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    marker.setLatLng([markerData.lat, markerData.lng]);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                } else if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {
+                    layers.overlays[markerData.layer].removeLayer(marker);
+                    layers.overlays[markerData.layer].addLayer(marker);
+                }
+            }
+        } else if (markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng) {
+            marker.setLatLng([markerData.lat, markerData.lng]);
+        }
+    };
+
+    var _getLayerModels = function _getLayerModels(models, layerName) {
+        if (!isDefined(models)) return;
+        if (layerName) return models[layerName];
+        return models;
+    };
+
+    var _getModelFromModels = function _getModelFromModels(models, id, layerName) {
+        if (!isDefined(models)) return;
+        if (!id) {
+            $log.error(errorHeader + 'marker id missing in getMarker');
+            return;
+        }
+        if (layerName) return models[layerName][id];
+
+        return models[id];
+    };
+    return {
+        resetMarkerGroup: _resetMarkerGroup,
+
+        resetMarkerGroups: _resetMarkerGroups,
+
+        resetUnusedMarkerGroups: _resetUnusedMarkerGroups,
+
+        deleteMarker: _deleteMarker,
+
+        manageOpenPopup: _manageOpenPopup,
+
+        manageOpenLabel: _manageOpenLabel,
+
+        createMarker: function createMarker(markerData) {
+            if (!isDefined(markerData) || !geoHlp.validateCoords(markerData)) {
+                $log.error(errorHeader + 'The marker definition is not valid.');
+                return;
+            }
+            var coords = geoHlp.getCoords(markerData);
+
+            if (!isDefined(coords)) {
+                $log.error(errorHeader + 'Unable to get coordinates from markerData.');
+                return;
+            }
+
+            var markerOptions = {
+                icon: createLeafletIcon(markerData.icon),
+                title: isDefined(markerData.title) ? markerData.title : '',
+                draggable: isDefined(markerData.draggable) ? markerData.draggable : false,
+                clickable: isDefined(markerData.clickable) ? markerData.clickable : true,
+                riseOnHover: isDefined(markerData.riseOnHover) ? markerData.riseOnHover : false,
+                zIndexOffset: isDefined(markerData.zIndexOffset) ? markerData.zIndexOffset : 0,
+                iconAngle: isDefined(markerData.iconAngle) ? markerData.iconAngle : 0
+            };
+            // Add any other options not added above to markerOptions
+            for (var markerDatum in markerData) {
+                if (markerData.hasOwnProperty(markerDatum) && !markerOptions.hasOwnProperty(markerDatum)) {
+                    markerOptions[markerDatum] = markerData[markerDatum];
+                }
+            }
+
+            var marker = new L.marker(coords, markerOptions);
+
+            if (!isString(markerData.message)) {
+                marker.unbindPopup();
+            }
+
+            return marker;
+        },
+
+        addMarkerToGroup: function addMarkerToGroup(marker, groupName, groupOptions, map) {
+            if (!isString(groupName)) {
+                $log.error(errorHeader + 'The marker group you have specified is invalid.');
+                return;
+            }
+
+            if (!MarkerClusterPlugin.isLoaded()) {
+                $log.error(errorHeader + "The MarkerCluster plugin is not loaded.");
+                return;
+            }
+            if (!isDefined(groups[groupName])) {
+                groups[groupName] = new L.MarkerClusterGroup(groupOptions);
+                map.addLayer(groups[groupName]);
+            }
+            groups[groupName].addLayer(marker);
+        },
+
+        listenMarkerEvents: function listenMarkerEvents(marker, markerData, leafletScope, watchType, map) {
+            marker.on("popupopen", function () /* event */{
+                safeApply(leafletScope, function () {
+                    if (isDefined(marker._popup) || isDefined(marker._popup._contentNode)) {
+                        markerData.focus = true;
+                        _manageOpenPopup(marker, markerData, map); //needed since markerData is now a copy
+                    }
+                });
+            });
+            marker.on("popupclose", function () /* event */{
+                safeApply(leafletScope, function () {
+                    markerData.focus = false;
+                });
+            });
+            marker.on("add", function () /* event */{
+                safeApply(leafletScope, function () {
+                    if ('label' in markerData) _manageOpenLabel(marker, markerData);
+                });
+            });
+        },
+
+        updateMarker: _updateMarker,
+
+        addMarkerWatcher: function addMarkerWatcher(marker, name, leafletScope, layers, map, watchOptions) {
+            var markerWatchPath = Helpers.getObjectArrayPath("markers." + name);
+
+            maybeWatch(leafletScope, markerWatchPath, watchOptions, function (markerData, oldMarkerData, clearWatch) {
+                if (!isDefined(markerData)) {
+                    _deleteMarker(marker, map, layers);
+                    clearWatch();
+                    return;
+                }
+                _updateMarker(markerData, oldMarkerData, marker, name, leafletScope, layers, map);
+            });
+        },
+        string: _string,
+        log: _log,
+        getModelFromModels: _getModelFromModels,
+        getLayerModels: _getLayerModels
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletPathsHelpers', function ($rootScope, leafletLogger, leafletHelpers) {
+    var isDefined = leafletHelpers.isDefined,
+        isArray = leafletHelpers.isArray,
+        isNumber = leafletHelpers.isNumber,
+        isValidPoint = leafletHelpers.isValidPoint,
+        $log = leafletLogger;
+
+    var availableOptions = [
+    // Path options
+    'stroke', 'weight', 'color', 'opacity', 'fill', 'fillColor', 'fillOpacity', 'dashArray', 'lineCap', 'lineJoin', 'clickable', 'pointerEvents', 'className',
+
+    // Polyline options
+    'smoothFactor', 'noClip'];
+    function _convertToLeafletLatLngs(latlngs) {
+        return latlngs.filter(function (latlng) {
+            return isValidPoint(latlng);
+        }).map(function (latlng) {
+            return _convertToLeafletLatLng(latlng);
+        });
+    }
+
+    function _convertToLeafletLatLng(latlng) {
+        if (isArray(latlng)) {
+            return new L.LatLng(latlng[0], latlng[1]);
+        } else {
+            return new L.LatLng(latlng.lat, latlng.lng);
+        }
+    }
+
+    function _convertToLeafletMultiLatLngs(paths) {
+        return paths.map(function (latlngs) {
+            return _convertToLeafletLatLngs(latlngs);
+        });
+    }
+
+    function _getOptions(path, defaults) {
+        var options = {};
+        for (var i = 0; i < availableOptions.length; i++) {
+            var optionName = availableOptions[i];
+
+            if (isDefined(path[optionName])) {
+                options[optionName] = path[optionName];
+            } else if (isDefined(defaults.path[optionName])) {
+                options[optionName] = defaults.path[optionName];
+            }
+        }
+
+        return options;
+    }
+
+    var _updatePathOptions = function _updatePathOptions(path, data) {
+        var updatedStyle = {};
+        for (var i = 0; i < availableOptions.length; i++) {
+            var optionName = availableOptions[i];
+            if (isDefined(data[optionName])) {
+                updatedStyle[optionName] = data[optionName];
+            }
+        }
+        path.setStyle(data);
+    };
+
+    var _isValidPolyline = function _isValidPolyline(latlngs) {
+        if (!isArray(latlngs)) {
+            return false;
+        }
+        for (var i = 0; i < latlngs.length; i++) {
+            var point = latlngs[i];
+            if (!isValidPoint(point)) {
+                return false;
+            }
+        }
+        return true;
+    };
+
+    var pathTypes = {
+        polyline: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+                return _isValidPolyline(latlngs);
+            },
+            createPath: function createPath(options) {
+                return new L.Polyline([], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        multiPolyline: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+                if (!isArray(latlngs)) {
+                    return false;
+                }
+
+                for (var i in latlngs) {
+                    var polyline = latlngs[i];
+                    if (!_isValidPolyline(polyline)) {
+                        return false;
+                    }
+                }
+
+                return true;
+            },
+            createPath: function createPath(options) {
+                return new L.multiPolyline([[[0, 0], [1, 1]]], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        polygon: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+                return _isValidPolyline(latlngs);
+            },
+            createPath: function createPath(options) {
+                return new L.Polygon([], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        multiPolygon: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+
+                if (!isArray(latlngs)) {
+                    return false;
+                }
+
+                for (var i in latlngs) {
+                    var polyline = latlngs[i];
+                    if (!_isValidPolyline(polyline)) {
+                        return false;
+                    }
+                }
+
+                return true;
+            },
+            createPath: function createPath(options) {
+                return new L.MultiPolygon([[[0, 0], [1, 1], [0, 1]]], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));
+                _updatePathOptions(path, data);
+                return;
+            }
+        },
+        rectangle: {
+            isValid: function isValid(pathData) {
+                var latlngs = pathData.latlngs;
+
+                if (!isArray(latlngs) || latlngs.length !== 2) {
+                    return false;
+                }
+
+                for (var i in latlngs) {
+                    var point = latlngs[i];
+                    if (!isValidPoint(point)) {
+                        return false;
+                    }
+                }
+
+                return true;
+            },
+            createPath: function createPath(options) {
+                return new L.Rectangle([[0, 0], [1, 1]], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setBounds(new L.LatLngBounds(_convertToLeafletLatLngs(data.latlngs)));
+                _updatePathOptions(path, data);
+            }
+        },
+        circle: {
+            isValid: function isValid(pathData) {
+                var point = pathData.latlngs;
+                return isValidPoint(point) && isNumber(pathData.radius);
+            },
+            createPath: function createPath(options) {
+                return new L.Circle([0, 0], 1, options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLng(_convertToLeafletLatLng(data.latlngs));
+                if (isDefined(data.radius)) {
+                    path.setRadius(data.radius);
+                }
+                _updatePathOptions(path, data);
+            }
+        },
+        circleMarker: {
+            isValid: function isValid(pathData) {
+                var point = pathData.latlngs;
+                return isValidPoint(point) && isNumber(pathData.radius);
+            },
+            createPath: function createPath(options) {
+                return new L.CircleMarker([0, 0], options);
+            },
+            setPath: function setPath(path, data) {
+                path.setLatLng(_convertToLeafletLatLng(data.latlngs));
+                if (isDefined(data.radius)) {
+                    path.setRadius(data.radius);
+                }
+                _updatePathOptions(path, data);
+            }
+        }
+    };
+
+    var _getPathData = function _getPathData(path) {
+        var pathData = {};
+        if (path.latlngs) {
+            pathData.latlngs = path.latlngs;
+        }
+
+        if (path.radius) {
+            pathData.radius = path.radius;
+        }
+
+        return pathData;
+    };
+
+    return {
+        setPathOptions: function setPathOptions(leafletPath, pathType, data) {
+            if (!isDefined(pathType)) {
+                pathType = "polyline";
+            }
+            pathTypes[pathType].setPath(leafletPath, data);
+        },
+        createPath: function createPath(name, path, defaults) {
+            if (!isDefined(path.type)) {
+                path.type = "polyline";
+            }
+            var options = _getOptions(path, defaults);
+            var pathData = _getPathData(path);
+
+            if (!pathTypes[path.type].isValid(pathData)) {
+                $log.error("[AngularJS - Leaflet] Invalid data passed to the " + path.type + " path");
+                return;
+            }
+
+            return pathTypes[path.type].createPath(options);
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletWatchHelpers', function () {
+
+    var _maybe = function _maybe(scope, watchFunctionName, thingToWatchStr, watchOptions, initCb) {
+        var unWatch = scope[watchFunctionName](thingToWatchStr, function (newValue, oldValue) {
+            //make the unWatch function available to the callback as well.
+            initCb(newValue, oldValue, unWatch);
+            if (watchOptions.type === null) unWatch();
+        }, watchOptions.type === 'watchDeep');
+
+        return unWatch;
+    };
+
+    /*
+    @name: maybeWatch
+    @description: Utility to watch something once or forever.
+    @returns unWatch function
+    @param watchOptions - This object is used to determine the type of
+    watch used.
+    */
+    var _maybeWatch = function _maybeWatch(scope, thingToWatchStr, watchOptions, initCb) {
+        var watchMethod;
+
+        if (watchOptions.type === 'watchCollection') {
+            watchMethod = '$watchCollection';
+        } else {
+            watchMethod = '$watch';
+        }
+
+        return _maybe(scope, watchMethod, thingToWatchStr, watchOptions, initCb);
+    };
+
+    return {
+        maybeWatch: _maybeWatch
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').service('leafletLogger', function (nemSimpleLogger) {
+  return nemSimpleLogger.spawn();
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('nominatimService', function ($q, $http, leafletHelpers, leafletMapDefaults) {
+    var isDefined = leafletHelpers.isDefined;
+
+    return {
+        query: function query(address, mapId) {
+            var defaults = leafletMapDefaults.getDefaults(mapId);
+            var url = defaults.nominatim.server;
+            var df = $q.defer();
+
+            $http.get(url, { params: { format: 'json', limit: 1, q: address } }).success(function (data) {
+                if (data.length > 0 && isDefined(data[0].boundingbox)) {
+                    df.resolve(data[0]);
+                } else {
+                    df.reject('[Nominatim] Invalid address');
+                }
+            });
+
+            return df.promise;
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('bounds', function (leafletLogger, $timeout, $http, leafletHelpers, nominatimService, leafletBoundsHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet'],
+
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined;
+            var createLeafletBounds = leafletBoundsHelpers.createLeafletBounds;
+            var leafletScope = controller[0].getLeafletScope();
+            var mapController = controller[0];
+            var errorHeader = leafletHelpers.errorHeader + ' [Bounds] ';
+
+            var emptyBounds = function emptyBounds(bounds) {
+                return bounds._southWest.lat === 0 && bounds._southWest.lng === 0 && bounds._northEast.lat === 0 && bounds._northEast.lng === 0;
+            };
+
+            mapController.getMap().then(function (map) {
+                leafletScope.$on('boundsChanged', function (event) {
+                    var scope = event.currentScope;
+                    var bounds = map.getBounds();
+
+                    if (emptyBounds(bounds) || scope.settingBoundsFromScope) {
+                        return;
+                    }
+                    scope.settingBoundsFromLeaflet = true;
+                    var newScopeBounds = {
+                        northEast: {
+                            lat: bounds._northEast.lat,
+                            lng: bounds._northEast.lng
+                        },
+                        southWest: {
+                            lat: bounds._southWest.lat,
+                            lng: bounds._southWest.lng
+                        },
+                        options: bounds.options
+                    };
+                    if (!angular.equals(scope.bounds, newScopeBounds)) {
+                        scope.bounds = newScopeBounds;
+                    }
+                    $timeout(function () {
+                        scope.settingBoundsFromLeaflet = false;
+                    });
+                });
+
+                var lastNominatimQuery;
+                leafletScope.$watch('bounds', function (bounds) {
+                    if (scope.settingBoundsFromLeaflet) return;
+                    if (isDefined(bounds.address) && bounds.address !== lastNominatimQuery) {
+                        scope.settingBoundsFromScope = true;
+                        nominatimService.query(bounds.address, attrs.id).then(function (data) {
+                            var b = data.boundingbox;
+                            var newBounds = [[b[0], b[2]], [b[1], b[3]]];
+                            map.fitBounds(newBounds);
+                        }, function (errMsg) {
+                            $log.error(errorHeader + ' ' + errMsg + '.');
+                        });
+                        lastNominatimQuery = bounds.address;
+                        $timeout(function () {
+                            scope.settingBoundsFromScope = false;
+                        });
+                        return;
+                    }
+
+                    var leafletBounds = createLeafletBounds(bounds);
+                    if (leafletBounds && !map.getBounds().equals(leafletBounds)) {
+                        scope.settingBoundsFromScope = true;
+                        map.fitBounds(leafletBounds, bounds.options);
+                        $timeout(function () {
+                            scope.settingBoundsFromScope = false;
+                        });
+                    }
+                }, true);
+            });
+        }
+    };
+});
+
+'use strict';
+
+var centerDirectiveTypes = ['center', 'lfCenter'],
+    centerDirectives = {};
+
+centerDirectiveTypes.forEach(function (directiveName) {
+    centerDirectives[directiveName] = ['leafletLogger', '$q', '$location', '$timeout', 'leafletMapDefaults', 'leafletHelpers', 'leafletBoundsHelpers', 'leafletMapEvents', function (leafletLogger, $q, $location, $timeout, leafletMapDefaults, leafletHelpers, leafletBoundsHelpers, leafletMapEvents) {
+
+        var isDefined = leafletHelpers.isDefined,
+            isNumber = leafletHelpers.isNumber,
+            isSameCenterOnMap = leafletHelpers.isSameCenterOnMap,
+            safeApply = leafletHelpers.safeApply,
+            isValidCenter = leafletHelpers.isValidCenter,
+            isValidBounds = leafletBoundsHelpers.isValidBounds,
+            isUndefinedOrEmpty = leafletHelpers.isUndefinedOrEmpty,
+            errorHeader = leafletHelpers.errorHeader,
+            $log = leafletLogger;
+
+        var shouldInitializeMapWithBounds = function shouldInitializeMapWithBounds(bounds, center) {
+            return isDefined(bounds) && isValidBounds(bounds) && isUndefinedOrEmpty(center);
+        };
+
+        var _leafletCenter;
+        return {
+            restrict: "A",
+            scope: false,
+            replace: false,
+            require: 'leaflet',
+            controller: function controller() {
+                _leafletCenter = $q.defer();
+                this.getCenter = function () {
+                    return _leafletCenter.promise;
+                };
+            },
+            link: function link(scope, element, attrs, controller) {
+                var leafletScope = controller.getLeafletScope(),
+                    centerModel = leafletScope[directiveName];
+
+                controller.getMap().then(function (map) {
+                    var defaults = leafletMapDefaults.getDefaults(attrs.id);
+
+                    if (attrs[directiveName].search("-") !== -1) {
+                        $log.error(errorHeader + ' The "center" variable can\'t use a "-" on its key name: "' + attrs[directiveName] + '".');
+                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                        return;
+                    } else if (shouldInitializeMapWithBounds(leafletScope.bounds, centerModel)) {
+                        map.fitBounds(leafletBoundsHelpers.createLeafletBounds(leafletScope.bounds), leafletScope.bounds.options);
+                        centerModel = map.getCenter();
+                        safeApply(leafletScope, function (scope) {
+                            angular.extend(scope[directiveName], {
+                                lat: map.getCenter().lat,
+                                lng: map.getCenter().lng,
+                                zoom: map.getZoom(),
+                                autoDiscover: false
+                            });
+                        });
+                        safeApply(leafletScope, function (scope) {
+                            var mapBounds = map.getBounds();
+                            scope.bounds = {
+                                northEast: {
+                                    lat: mapBounds._northEast.lat,
+                                    lng: mapBounds._northEast.lng
+                                },
+                                southWest: {
+                                    lat: mapBounds._southWest.lat,
+                                    lng: mapBounds._southWest.lng
+                                }
+                            };
+                        });
+                    } else if (!isDefined(centerModel)) {
+                        $log.error(errorHeader + ' The "center" property is not defined in the main scope');
+                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                        return;
+                    } else if (!(isDefined(centerModel.lat) && isDefined(centerModel.lng)) && !isDefined(centerModel.autoDiscover)) {
+                        angular.copy(defaults.center, centerModel);
+                    }
+
+                    var urlCenterHash, mapReady;
+                    if (attrs.urlHashCenter === "yes") {
+                        var extractCenterFromUrl = function extractCenterFromUrl() {
+                            var search = $location.search();
+                            var centerParam;
+                            var centerKey = attrs.urlHashParam ? attrs.urlHashParam : 'c';
+                            if (isDefined(search[centerKey])) {
+                                var cParam = search[centerKey].split(":");
+                                if (cParam.length === 3) {
+                                    centerParam = {
+                                        lat: parseFloat(cParam[0]),
+                                        lng: parseFloat(cParam[1]),
+                                        zoom: parseInt(cParam[2], 10)
+                                    };
+                                }
+                            }
+                            return centerParam;
+                        };
+                        urlCenterHash = extractCenterFromUrl();
+
+                        leafletScope.$on('$locationChangeSuccess', function (event) {
+                            var scope = event.currentScope;
+                            //$log.debug("updated location...");
+                            var urlCenter = extractCenterFromUrl();
+                            if (isDefined(urlCenter) && !isSameCenterOnMap(urlCenter, map)) {
+                                //$log.debug("updating center model...", urlCenter);
+                                angular.extend(scope[directiveName], {
+                                    lat: urlCenter.lat,
+                                    lng: urlCenter.lng,
+                                    zoom: urlCenter.zoom
+                                });
+                            }
+                        });
+                    }
+
+                    leafletScope.$watch(directiveName, function (center) {
+                        if (leafletScope.settingCenterFromLeaflet) return;
+                        //$log.debug("updated center model...");
+                        // The center from the URL has priority
+                        if (isDefined(urlCenterHash)) {
+                            angular.copy(urlCenterHash, center);
+                            urlCenterHash = undefined;
+                        }
+
+                        if (!isValidCenter(center) && center.autoDiscover !== true) {
+                            $log.warn(errorHeader + " invalid 'center'");
+                            //map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                            return;
+                        }
+
+                        if (center.autoDiscover === true) {
+                            if (!isNumber(center.zoom)) {
+                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                            }
+                            if (isNumber(center.zoom) && center.zoom > defaults.center.zoom) {
+                                map.locate({
+                                    setView: true,
+                                    maxZoom: center.zoom
+                                });
+                            } else if (isDefined(defaults.maxZoom)) {
+                                map.locate({
+                                    setView: true,
+                                    maxZoom: defaults.maxZoom
+                                });
+                            } else {
+                                map.locate({
+                                    setView: true
+                                });
+                            }
+                            return;
+                        }
+
+                        if (mapReady && isSameCenterOnMap(center, map)) {
+                            //$log.debug("no need to update map again.");
+                            return;
+                        }
+
+                        //$log.debug("updating map center...", center);
+                        leafletScope.settingCenterFromScope = true;
+                        map.setView([center.lat, center.lng], center.zoom);
+                        leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                        $timeout(function () {
+                            leafletScope.settingCenterFromScope = false;
+                            //$log.debug("allow center scope updates");
+                        });
+                    }, true);
+
+                    map.whenReady(function () {
+                        mapReady = true;
+                    });
+
+                    map.on('moveend', function () /* event */{
+                        // Resolve the center after the first map position
+                        _leafletCenter.resolve();
+                        leafletMapEvents.notifyCenterUrlHashChanged(leafletScope, map, attrs, $location.search());
+                        //$log.debug("updated center on map...");
+                        if (isSameCenterOnMap(centerModel, map) || leafletScope.settingCenterFromScope) {
+                            //$log.debug("same center in model, no need to update again.");
+                            return;
+                        }
+                        leafletScope.settingCenterFromLeaflet = true;
+                        safeApply(leafletScope, function (scope) {
+                            if (!leafletScope.settingCenterFromScope) {
+                                //$log.debug("updating center model...", map.getCenter(), map.getZoom());
+                                angular.extend(scope[directiveName], {
+                                    lat: map.getCenter().lat,
+                                    lng: map.getCenter().lng,
+                                    zoom: map.getZoom(),
+                                    autoDiscover: false
+                                });
+                            }
+                            leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                            $timeout(function () {
+                                leafletScope.settingCenterFromLeaflet = false;
+                            });
+                        });
+                    });
+
+                    if (centerModel.autoDiscover === true) {
+                        map.on('locationerror', function () {
+                            $log.warn(errorHeader + " The Geolocation API is unauthorized on this page.");
+                            if (isValidCenter(centerModel)) {
+                                map.setView([centerModel.lat, centerModel.lng], centerModel.zoom);
+                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                            } else {
+                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);
+                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);
+                            }
+                        });
+                    }
+                });
+            }
+        };
+    }];
+});
+
+centerDirectiveTypes.forEach(function (dirType) {
+    angular.module('ui-leaflet').directive(dirType, centerDirectives[dirType]);
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('controls', function (leafletLogger, leafletHelpers, leafletControlHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: '?^leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            if (!controller) {
+                return;
+            }
+
+            var createControl = leafletControlHelpers.createControl;
+            var isValidControlType = leafletControlHelpers.isValidControlType;
+            var leafletScope = controller.getLeafletScope();
+            var isDefined = leafletHelpers.isDefined;
+            var isArray = leafletHelpers.isArray;
+            var leafletControls = {};
+            var errorHeader = leafletHelpers.errorHeader + ' [Controls] ';
+
+            scope.$on('$destroy', function () {
+                leafletControlHelpers.destroyMapLayersControl(scope.mapId);
+            });
+
+            controller.getMap().then(function (map) {
+
+                leafletScope.$watchCollection('controls', function (newControls) {
+
+                    // Delete controls from the array
+                    for (var name in leafletControls) {
+                        if (!isDefined(newControls[name])) {
+                            if (map.hasControl(leafletControls[name])) {
+                                map.removeControl(leafletControls[name]);
+                            }
+                            delete leafletControls[name];
+                        }
+                    }
+
+                    for (var newName in newControls) {
+                        var control;
+
+                        var controlType = isDefined(newControls[newName].type) ? newControls[newName].type : newName;
+
+                        if (!isValidControlType(controlType)) {
+                            $log.error(errorHeader + ' Invalid control type: ' + controlType + '.');
+                            return;
+                        }
+
+                        if (controlType !== 'custom') {
+                            control = createControl(controlType, newControls[newName]);
+                            map.addControl(control);
+                            leafletControls[newName] = control;
+                        } else {
+                            var customControlValue = newControls[newName];
+                            if (isArray(customControlValue)) {
+                                for (var i = 0; i < customControlValue.length; i++) {
+                                    var customControl = customControlValue[i];
+                                    map.addControl(customControl);
+                                    leafletControls[newName] = !isDefined(leafletControls[newName]) ? [customControl] : leafletControls[newName].concat([customControl]);
+                                }
+                            } else {
+                                map.addControl(customControlValue);
+                                leafletControls[newName] = customControlValue;
+                            }
+                        }
+                    }
+                });
+            });
+        }
+    };
+});
+
+"use strict";
+
+angular.module('ui-leaflet').directive("decorations", function (leafletLogger, leafletHelpers) {
+	var $log = leafletLogger;
+	return {
+		restrict: "A",
+		scope: false,
+		replace: false,
+		require: 'leaflet',
+
+		link: function link(scope, element, attrs, controller) {
+			var leafletScope = controller.getLeafletScope(),
+			    PolylineDecoratorPlugin = leafletHelpers.PolylineDecoratorPlugin,
+			    isDefined = leafletHelpers.isDefined,
+			    leafletDecorations = {};
+
+			/* Creates an "empty" decoration with a set of coordinates, but no pattern. */
+			function createDecoration(options) {
+				if (isDefined(options) && isDefined(options.coordinates)) {
+					if (!PolylineDecoratorPlugin.isLoaded()) {
+						$log.error('[AngularJS - Leaflet] The PolylineDecorator Plugin is not loaded.');
+					}
+				}
+
+				return L.polylineDecorator(options.coordinates);
+			}
+
+			/* Updates the path and the patterns for the provided decoration, and returns the decoration. */
+			function setDecorationOptions(decoration, options) {
+				if (isDefined(decoration) && isDefined(options)) {
+					if (isDefined(options.coordinates) && isDefined(options.patterns)) {
+						decoration.setPaths(options.coordinates);
+						decoration.setPatterns(options.patterns);
+						return decoration;
+					}
+				}
+			}
+
+			controller.getMap().then(function (map) {
+				leafletScope.$watch("decorations", function (newDecorations) {
+					for (var name in leafletDecorations) {
+						if (!isDefined(newDecorations[name]) || !angular.equals(newDecorations[name], leafletDecorations)) {
+							map.removeLayer(leafletDecorations[name]);
+							delete leafletDecorations[name];
+						}
+					}
+
+					for (var newName in newDecorations) {
+						var decorationData = newDecorations[newName],
+						    newDecoration = createDecoration(decorationData);
+
+						if (isDefined(newDecoration)) {
+							leafletDecorations[newName] = newDecoration;
+							map.addLayer(newDecoration);
+							setDecorationOptions(newDecoration, decorationData);
+						}
+					}
+				}, true);
+			});
+		}
+	};
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('eventBroadcast', function (leafletLogger, $rootScope, leafletHelpers, leafletMapEvents, leafletIterators) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var isObject = leafletHelpers.isObject,
+                isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                eventBroadcast = leafletScope.eventBroadcast,
+                availableMapEvents = leafletMapEvents.getAvailableMapEvents(),
+                addEvents = leafletMapEvents.addEvents;
+
+            controller.getMap().then(function (map) {
+
+                var mapEvents = [],
+                    logic = "broadcast";
+
+                // We have a possible valid object
+                if (!isDefined(eventBroadcast.map)) {
+                    // We do not have events enable/disable do we do nothing (all enabled by default)
+                    mapEvents = availableMapEvents;
+                } else if (!isObject(eventBroadcast.map)) {
+                    // Not a valid object
+                    $log.warn("[AngularJS - Leaflet] event-broadcast.map must be an object check your model.");
+                } else {
+                    // We have a possible valid map object
+                    // Event propadation logic
+                    if (eventBroadcast.map.logic !== "emit" && eventBroadcast.map.logic !== "broadcast") {
+                        // This is an error
+                        $log.warn("[AngularJS - Leaflet] Available event propagation logic are: 'emit' or 'broadcast'.");
+                    } else {
+                        logic = eventBroadcast.map.logic;
+                    }
+
+                    if (!(isObject(eventBroadcast.map.enable) && eventBroadcast.map.enable.length >= 0)) {
+                        $log.warn("[AngularJS - Leaflet] event-broadcast.map.enable must be an object check your model.");
+                    } else {
+                        // Enable events
+                        leafletIterators.each(eventBroadcast.map.enable, function (eventName) {
+                            // Do we have already the event enabled?
+                            if (mapEvents.indexOf(eventName) === -1 && availableMapEvents.indexOf(eventName) !== -1) {
+                                mapEvents.push(eventName);
+                            }
+                        });
+                    }
+                }
+                // as long as the map is removed in the root leaflet directive we
+                // do not need ot clean up the events as leaflet does it itself
+                addEvents(map, attrs.id, mapEvents, "eventName", leafletScope, logic);
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('geojson', function ($timeout, leafletLogger, leafletData, leafletHelpers, leafletWatchHelpers, leafletDirectiveControlsHelpers, leafletIterators, leafletGeoJsonEvents) {
+    var _maybeWatch = leafletWatchHelpers.maybeWatch,
+        _defaultWatchOptions = leafletHelpers.watchOptions,
+        _extendDirectiveControls = leafletDirectiveControlsHelpers.extend,
+        hlp = leafletHelpers,
+        $it = leafletIterators,
+        watchTrap = { changeFromDirective: false };
+    // $log = leafletLogger;
+
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                leafletGeoJSON = {},
+                _hasSetLeafletData = false;
+
+            controller.getMap().then(function (map) {
+                var watchOptions;
+                if (leafletScope.watchOptions && leafletScope.watchOptions.geojson) {
+                    watchOptions = leafletScope.watchOptions.geojson;
+                } else {
+                    watchOptions = _defaultWatchOptions;
+                }
+
+                var _hookUpEvents = function _hookUpEvents(geojson, maybeName) {
+                    var onEachFeature;
+
+                    if (angular.isFunction(geojson.onEachFeature)) {
+                        onEachFeature = geojson.onEachFeature;
+                    } else {
+                        onEachFeature = function onEachFeature(feature, layer) {
+                            if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(feature.properties.description)) {
+                                layer.bindLabel(feature.properties.description);
+                            }
+
+                            leafletGeoJsonEvents.bindEvents(attrs.id, layer, null, feature, leafletScope, maybeName, { resetStyleOnMouseout: geojson.resetStyleOnMouseout,
+                                mapId: attrs.id });
+                        };
+                    }
+                    return onEachFeature;
+                };
+
+                var isNested = hlp.isDefined(attrs.geojsonNested) && hlp.isTruthy(attrs.geojsonNested);
+
+                var _clean = function _clean() {
+                    if (!leafletGeoJSON) return;
+                    var _remove = function _remove(lObject) {
+                        if (isDefined(lObject) && map.hasLayer(lObject)) {
+                            map.removeLayer(lObject);
+                        }
+                    };
+                    if (isNested) {
+                        $it.each(leafletGeoJSON, function (lObject) {
+                            _remove(lObject);
+                        });
+                        return;
+                    }
+                    _remove(leafletGeoJSON);
+                };
+
+                var _addGeojson = function _addGeojson(geojson, maybeName) {
+
+                    if (!(isDefined(geojson) && isDefined(geojson.data))) {
+                        return;
+                    }
+                    var onEachFeature = _hookUpEvents(geojson, maybeName);
+
+                    if (!isDefined(geojson.options)) {
+                        hlp.modelChangeInDirective(watchTrap, "changeFromDirective", function () {
+                            geojson.options = {
+                                style: geojson.style,
+                                filter: geojson.filter,
+                                onEachFeature: onEachFeature,
+                                pointToLayer: geojson.pointToLayer
+                            };
+                        });
+                    }
+
+                    var lObject = L.geoJson(geojson.data, geojson.options);
+
+                    if (maybeName && hlp.isString(maybeName)) {
+                        leafletGeoJSON[maybeName] = lObject;
+                    } else {
+                        leafletGeoJSON = lObject;
+                    }
+
+                    lObject.addTo(map);
+
+                    if (!_hasSetLeafletData) {
+                        //only do this once and play with the same ref forever
+                        _hasSetLeafletData = true;
+                        leafletData.setGeoJSON(leafletGeoJSON, attrs.id);
+                    }
+                };
+
+                var _create = function _create(model) {
+                    _clean();
+                    if (isNested) {
+                        if (!model || !Object.keys(model).length) return;
+                        $it.each(model, function (m, name) {
+                            //name could be layerName and or groupName
+                            //for now it is not tied to a layer
+                            _addGeojson(m, name);
+                        });
+                        return;
+                    }
+                    _addGeojson(model);
+                };
+
+                _extendDirectiveControls(attrs.id, 'geojson', _create, _clean);
+
+                _maybeWatch(leafletScope, 'geojson', watchOptions, function (geojson) {
+                    if (watchTrap.changeFromDirective) return;
+                    _create(geojson);
+                });
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('layercontrol', function ($filter, leafletLogger, leafletData, leafletHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "E",
+        scope: {
+            icons: '=?',
+            autoHideOpacity: '=?', // Hide other opacity controls when one is activated.
+            showGroups: '=?', // Hide other opacity controls when one is activated.
+            title: '@',
+            baseTitle: '@',
+            overlaysTitle: '@'
+        },
+        replace: true,
+        transclude: false,
+        require: '^leaflet',
+        controller: function controller($scope, $element, $sce) {
+            $log.debug('[Angular Directive - Layers] layers', $scope, $element);
+            var safeApply = leafletHelpers.safeApply,
+                isDefined = leafletHelpers.isDefined;
+            angular.extend($scope, {
+                baselayer: '',
+                oldGroup: '',
+                layerProperties: {},
+                groupProperties: {},
+                rangeIsSupported: leafletHelpers.rangeIsSupported(),
+                changeBaseLayer: function changeBaseLayer(key, e) {
+                    leafletHelpers.safeApply($scope, function (scp) {
+                        scp.baselayer = key;
+                        leafletData.getMap().then(function (map) {
+                            leafletData.getLayers().then(function (leafletLayers) {
+                                if (map.hasLayer(leafletLayers.baselayers[key])) {
+                                    return;
+                                }
+                                for (var i in scp.layers.baselayers) {
+                                    scp.layers.baselayers[i].icon = scp.icons.unradio;
+                                    if (map.hasLayer(leafletLayers.baselayers[i])) {
+                                        map.removeLayer(leafletLayers.baselayers[i]);
+                                    }
+                                }
+                                map.addLayer(leafletLayers.baselayers[key]);
+                                scp.layers.baselayers[key].icon = $scope.icons.radio;
+                            });
+                        });
+                    });
+                    e.preventDefault();
+                },
+                moveLayer: function moveLayer(ly, newIndex, e) {
+                    var delta = Object.keys($scope.layers.baselayers).length;
+                    if (newIndex >= 1 + delta && newIndex <= $scope.overlaysArray.length + delta) {
+                        var oldLy;
+                        for (var key in $scope.layers.overlays) {
+                            if ($scope.layers.overlays[key].index === newIndex) {
+                                oldLy = $scope.layers.overlays[key];
+                                break;
+                            }
+                        }
+                        if (oldLy) {
+                            safeApply($scope, function () {
+                                oldLy.index = ly.index;
+                                ly.index = newIndex;
+                            });
+                        }
+                    }
+                    e.stopPropagation();
+                    e.preventDefault();
+                },
+                initIndex: function initIndex(layer, idx) {
+                    var delta = Object.keys($scope.layers.baselayers).length;
+                    layer.index = isDefined(layer.index) ? layer.index : idx + delta + 1;
+                },
+                initGroup: function initGroup(groupName) {
+                    $scope.groupProperties[groupName] = $scope.groupProperties[groupName] ? $scope.groupProperties[groupName] : {};
+                },
+                toggleOpacity: function toggleOpacity(e, layer) {
+                    if (layer.visible) {
+                        if ($scope.autoHideOpacity && !$scope.layerProperties[layer.name].opacityControl) {
+                            for (var k in $scope.layerProperties) {
+                                $scope.layerProperties[k].opacityControl = false;
+                            }
+                        }
+                        $scope.layerProperties[layer.name].opacityControl = !$scope.layerProperties[layer.name].opacityControl;
+                    }
+                    e.stopPropagation();
+                    e.preventDefault();
+                },
+                toggleLegend: function toggleLegend(layer) {
+                    $scope.layerProperties[layer.name].showLegend = !$scope.layerProperties[layer.name].showLegend;
+                },
+                showLegend: function showLegend(layer) {
+                    return layer.legend && $scope.layerProperties[layer.name].showLegend;
+                },
+                unsafeHTML: function unsafeHTML(html) {
+                    return $sce.trustAsHtml(html);
+                },
+                getOpacityIcon: function getOpacityIcon(layer) {
+                    return layer.visible && $scope.layerProperties[layer.name].opacityControl ? $scope.icons.close : $scope.icons.open;
+                },
+                getGroupIcon: function getGroupIcon(group) {
+                    return group.visible ? $scope.icons.check : $scope.icons.uncheck;
+                },
+                changeGroupVisibility: function changeGroupVisibility(groupName) {
+                    if (!isDefined($scope.groupProperties[groupName])) {
+                        return;
+                    }
+                    var visible = $scope.groupProperties[groupName].visible;
+                    for (var k in $scope.layers.overlays) {
+                        var layer = $scope.layers.overlays[k];
+                        if (layer.group === groupName) {
+                            layer.visible = visible;
+                        }
+                    }
+                }
+            });
+
+            var div = $element.get(0);
+            if (!L.Browser.touch) {
+                L.DomEvent.disableClickPropagation(div);
+                L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);
+            } else {
+                L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);
+            }
+        },
+        template: '<div class="angular-leaflet-control-layers" ng-show="overlaysArray.length">' + '<h4 ng-if="title">{{ title }}</h4>' + '<div class="lf-baselayers">' + '<h5 class="lf-title" ng-if="baseTitle">{{ baseTitle }}</h5>' + '<div class="lf-row" ng-repeat="(key, layer) in baselayersArray">' + '<label class="lf-icon-bl" ng-click="changeBaseLayer(key, $event)">' + '<input class="leaflet-control-layers-selector" type="radio" name="lf-radio" ' + 'ng-show="false" ng-checked="baselayer === key" ng-value="key" /> ' + '<i class="lf-icon lf-icon-radio" ng-class="layer.icon"></i>' + '<div class="lf-text">{{layer.name}}</div>' + '</label>' + '</div>' + '</div>' + '<div class="lf-overlays">' + '<h5 class="lf-title" ng-if="overlaysTitle">{{ overlaysTitle }}</h5>' + '<div class="lf-container">' + '<div class="lf-row" ng-repeat="layer in (o = (overlaysArray | orderBy:\'index\':order))" ng-init="initIndex(layer, $index)">' + '<label class="lf-icon-ol-group" ng-if="showGroups &amp;&amp; layer.group &amp;&amp; layer.group != o[$index-1].group">' + '<input class="lf-control-layers-selector" type="checkbox" ng-show="false" ' + 'ng-change="changeGroupVisibility(layer.group)" ng-model="groupProperties[layer.group].visible"/> ' + '<i class="lf-icon lf-icon-check" ng-class="getGroupIcon(groupProperties[layer.group])"></i>' + '<div class="lf-text">{{ layer.group }}</div>' + '</label>' + '<label class="lf-icon-ol">' + '<input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-model="layer.visible"/> ' + '<i class="lf-icon lf-icon-check" ng-class="layer.icon"></i>' + '<div class="lf-text">{{layer.name}}</div>' + '</label>' + '<div class="lf-icons">' + '<i class="lf-icon lf-up" ng-class="icons.up" ng-click="moveLayer(layer, layer.index - orderNumber, $event)"></i> ' + '<i class="lf-icon lf-down" ng-class="icons.down" ng-click="moveLayer(layer, layer.index + orderNumber, $event)"></i> ' + '<i class="lf-icon lf-toggle-legend" ng-class="icons.toggleLegend" ng-if="layer.legend" ng-click="toggleLegend(layer)"></i> ' + '<i class="lf-icon lf-open" ng-class="getOpacityIcon(layer)" ng-click="toggleOpacity($event, layer)"></i>' + '</div>' + '<div class="lf-legend" ng-if="showLegend(layer)" ng-bind-html="unsafeHTML(layer.legend)"></div>' + '<div class="lf-opacity clearfix" ng-if="layer.visible &amp;&amp; layerProperties[layer.name].opacityControl">' + '<label ng-if="rangeIsSupported" class="pull-left" style="width: 50%">0</label>' + '<label ng-if="rangeIsSupported" class="pull-left text-right" style="width: 50%">100</label>' + '<input ng-if="rangeIsSupported" class="clearfix" type="range" min="0" max="1" step="0.05" ' + 'class="lf-opacity-control" ng-model="layerProperties[layer.name].layerOptions.opacity"/>' + '<h6 ng-if="!rangeIsSupported">Range is not supported in this browser</h6>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>',
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                layers = leafletScope.layers;
+
+            scope.$watch('icons', function () {
+                var defaultIcons = {
+                    uncheck: 'fa fa-square-o',
+                    check: 'fa fa-check-square-o',
+                    radio: 'fa fa-dot-circle-o',
+                    unradio: 'fa fa-circle-o',
+                    up: 'fa fa-angle-up',
+                    down: 'fa fa-angle-down',
+                    open: 'fa fa-angle-double-down',
+                    close: 'fa fa-angle-double-up',
+                    toggleLegend: 'fa fa-pencil-square-o'
+                };
+                if (isDefined(scope.icons)) {
+                    angular.extend(defaultIcons, scope.icons);
+                    angular.extend(scope.icons, defaultIcons);
+                } else {
+                    scope.icons = defaultIcons;
+                }
+            });
+
+            // Setting layer stack order.
+            attrs.order = isDefined(attrs.order) && (attrs.order === 'normal' || attrs.order === 'reverse') ? attrs.order : 'normal';
+            scope.order = attrs.order === 'normal';
+            scope.orderNumber = attrs.order === 'normal' ? -1 : 1;
+
+            scope.layers = layers;
+            controller.getMap().then(function (map) {
+                leafletScope.$watch('layers.baselayers', function (newBaseLayers) {
+                    var baselayersArray = {};
+                    leafletData.getLayers().then(function (leafletLayers) {
+                        var key;
+                        for (key in newBaseLayers) {
+                            var layer = newBaseLayers[key];
+                            layer.icon = scope.icons[map.hasLayer(leafletLayers.baselayers[key]) ? 'radio' : 'unradio'];
+                            baselayersArray[key] = layer;
+                        }
+                        scope.baselayersArray = baselayersArray;
+                    });
+                });
+
+                leafletScope.$watch('layers.overlays', function (newOverlayLayers) {
+                    var overlaysArray = [];
+                    var groupVisibleCount = {};
+                    leafletData.getLayers().then(function () {
+                        var key;
+                        for (key in newOverlayLayers) {
+                            var layer = newOverlayLayers[key];
+                            layer.icon = scope.icons[layer.visible ? 'check' : 'uncheck'];
+                            overlaysArray.push(layer);
+
+                            if (!isDefined(scope.layerProperties[layer.name])) {
+                                if (isDefined(layer.layerOptions.opacity)) {
+                                    layer.layerOptions.opacity = 1;
+                                }
+                                scope.layerProperties[layer.name] = {
+                                    opacityControl: false,
+                                    showLegend: true,
+                                    layerOptions: layer.layerOptions
+                                };
+                            }
+                            if (isDefined(layer.group)) {
+                                if (!isDefined(scope.groupProperties[layer.group])) {
+                                    scope.groupProperties[layer.group] = {
+                                        visible: false
+                                    };
+                                }
+                                groupVisibleCount[layer.group] = isDefined(groupVisibleCount[layer.group]) ? groupVisibleCount[layer.group] : {
+                                    count: 0,
+                                    visibles: 0
+                                };
+                                groupVisibleCount[layer.group].count++;
+                                if (layer.visible) {
+                                    groupVisibleCount[layer.group].visibles++;
+                                }
+                            }
+                            /*
+                            if(isDefined(layer.index) && leafletLayers.overlays[key].setZIndex) {
+                                leafletLayers.overlays[key].setZIndex(newOverlayLayers[key].index);
+                            }
+                            */
+                        }
+
+                        for (key in groupVisibleCount) {
+                            scope.groupProperties[key].visible = groupVisibleCount[key].visibles === groupVisibleCount[key].count;
+                        }
+                        scope.overlaysArray = overlaysArray;
+                    });
+                }, true);
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('layers', function (leafletLogger, $q, leafletData, leafletHelpers, leafletLayerHelpers, leafletControlHelpers) {
+    // var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+        controller: function controller($scope) {
+            $scope._leafletLayers = $q.defer();
+            this.getLayers = function () {
+                return $scope._leafletLayers.promise;
+            };
+        },
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletLayers = {},
+                leafletScope = controller.getLeafletScope(),
+                layers = leafletScope.layers,
+                createLayer = leafletLayerHelpers.createLayer,
+                safeAddLayer = leafletLayerHelpers.safeAddLayer,
+                safeRemoveLayer = leafletLayerHelpers.safeRemoveLayer,
+                changeOpacityListener = leafletLayerHelpers.changeOpacityListener,
+                updateLayersControl = leafletControlHelpers.updateLayersControl,
+                isLayersControlVisible = false;
+
+            scope.$on('$destroy', function () {
+                leafletControlHelpers.destroyMapLayersControl(scope.mapId);
+            });
+
+            controller.getMap().then(function (map) {
+
+                // We have baselayers to add to the map
+                scope._leafletLayers.resolve(leafletLayers);
+                leafletData.setLayers(leafletLayers, attrs.id);
+
+                leafletLayers.baselayers = {};
+                leafletLayers.overlays = {};
+
+                var mapId = attrs.id;
+
+                // Setup all baselayers definitions
+                var oneVisibleLayer = false;
+                for (var layerName in layers.baselayers) {
+                    var newBaseLayer = createLayer(layers.baselayers[layerName]);
+                    if (!isDefined(newBaseLayer)) {
+                        delete layers.baselayers[layerName];
+                        continue;
+                    }
+                    leafletLayers.baselayers[layerName] = newBaseLayer;
+                    // Only add the visible layer to the map, layer control manages the addition to the map
+                    // of layers in its control
+                    if (layers.baselayers[layerName].top === true) {
+                        safeAddLayer(map, leafletLayers.baselayers[layerName]);
+                        oneVisibleLayer = true;
+                    }
+                }
+
+                // If there is no visible layer add first to the map
+                if (!oneVisibleLayer && Object.keys(leafletLayers.baselayers).length > 0) {
+                    safeAddLayer(map, leafletLayers.baselayers[Object.keys(layers.baselayers)[0]]);
+                }
+
+                // Setup the Overlays
+                for (layerName in layers.overlays) {
+                    if (layers.overlays[layerName].type === 'cartodb') {}
+                    var newOverlayLayer = createLayer(layers.overlays[layerName]);
+                    if (!isDefined(newOverlayLayer)) {
+                        delete layers.overlays[layerName];
+                        continue;
+                    }
+                    leafletLayers.overlays[layerName] = newOverlayLayer;
+                    // Only add the visible overlays to the map
+                    if (layers.overlays[layerName].visible === true) {
+                        safeAddLayer(map, leafletLayers.overlays[layerName]);
+                    }
+                }
+
+                // Watch for the base layers
+                leafletScope.$watch('layers.baselayers', function (newBaseLayers, oldBaseLayers) {
+                    if (angular.equals(newBaseLayers, oldBaseLayers)) {
+                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);
+                        return true;
+                    }
+                    // Delete layers from the array
+                    for (var name in leafletLayers.baselayers) {
+                        if (!isDefined(newBaseLayers[name]) || newBaseLayers[name].doRefresh) {
+                            // Remove from the map if it's on it
+                            if (map.hasLayer(leafletLayers.baselayers[name])) {
+                                map.removeLayer(leafletLayers.baselayers[name]);
+                            }
+                            delete leafletLayers.baselayers[name];
+
+                            if (newBaseLayers[name] && newBaseLayers[name].doRefresh) {
+                                newBaseLayers[name].doRefresh = false;
+                            }
+                        }
+                    }
+                    // add new layers
+                    for (var newName in newBaseLayers) {
+                        if (!isDefined(leafletLayers.baselayers[newName])) {
+                            var testBaseLayer = createLayer(newBaseLayers[newName]);
+                            if (isDefined(testBaseLayer)) {
+                                leafletLayers.baselayers[newName] = testBaseLayer;
+                                // Only add the visible layer to the map
+                                if (newBaseLayers[newName].top === true) {
+                                    safeAddLayer(map, leafletLayers.baselayers[newName]);
+                                }
+                            }
+                        } else {
+                            if (newBaseLayers[newName].top === true && !map.hasLayer(leafletLayers.baselayers[newName])) {
+                                safeAddLayer(map, leafletLayers.baselayers[newName]);
+                            } else if (newBaseLayers[newName].top === false && map.hasLayer(leafletLayers.baselayers[newName])) {
+                                map.removeLayer(leafletLayers.baselayers[newName]);
+                            }
+                        }
+                    }
+
+                    //we have layers, so we need to make, at least, one active
+                    var found = false;
+                    // search for an active layer
+                    for (var key in leafletLayers.baselayers) {
+                        if (map.hasLayer(leafletLayers.baselayers[key])) {
+                            found = true;
+                            break;
+                        }
+                    }
+                    // If there is no active layer make one active
+                    if (!found && Object.keys(leafletLayers.baselayers).length > 0) {
+                        safeAddLayer(map, leafletLayers.baselayers[Object.keys(leafletLayers.baselayers)[0]]);
+                    }
+
+                    // Only show the layers switch selector control if we have more than one baselayer + overlay
+                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);
+                }, true);
+
+                // Watch for the overlay layers
+                leafletScope.$watch('layers.overlays', function (newOverlayLayers, oldOverlayLayers) {
+                    if (angular.equals(newOverlayLayers, oldOverlayLayers)) {
+                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);
+                        return true;
+                    }
+
+                    // Delete layers from the array
+                    for (var name in leafletLayers.overlays) {
+                        if (!isDefined(newOverlayLayers[name]) || newOverlayLayers[name].doRefresh) {
+                            // Remove from the map if it's on it
+                            if (map.hasLayer(leafletLayers.overlays[name])) {
+                                // Safe remove when ArcGIS layers is loading.
+                                var options = isDefined(newOverlayLayers[name]) ? newOverlayLayers[name].layerOptions : null;
+                                safeRemoveLayer(map, leafletLayers.overlays[name], options);
+                            }
+                            // TODO: Depending on the layer type we will have to delete what's included on it
+                            delete leafletLayers.overlays[name];
+
+                            if (newOverlayLayers[name] && newOverlayLayers[name].doRefresh) {
+                                newOverlayLayers[name].doRefresh = false;
+                            }
+                        }
+                    }
+
+                    // add new overlays
+                    for (var newName in newOverlayLayers) {
+                        if (!isDefined(leafletLayers.overlays[newName])) {
+                            var testOverlayLayer = createLayer(newOverlayLayers[newName]);
+                            if (!isDefined(testOverlayLayer)) {
+                                // If the layer creation fails, continue to the next overlay
+                                continue;
+                            }
+                            leafletLayers.overlays[newName] = testOverlayLayer;
+                            if (newOverlayLayers[newName].visible === true) {
+                                safeAddLayer(map, leafletLayers.overlays[newName]);
+                            }
+
+                            if (isDefined(newOverlayLayers[newName].index) && leafletLayers.overlays[newName].setZIndex) {
+                                leafletLayers.overlays[newName].setZIndex(newOverlayLayers[newName].index);
+                            }
+                        } else {
+                            // check for the .visible property to hide/show overLayers
+                            if (newOverlayLayers[newName].visible && !map.hasLayer(leafletLayers.overlays[newName])) {
+                                safeAddLayer(map, leafletLayers.overlays[newName]);
+                            } else if (newOverlayLayers[newName].visible === false && map.hasLayer(leafletLayers.overlays[newName])) {
+                                // Safe remove when ArcGIS layers is loading.
+                                safeRemoveLayer(map, leafletLayers.overlays[newName], newOverlayLayers[newName].layerOptions);
+                            }
+
+                            // check for the .layerOptions.opacity property has changed.
+                            var ly = leafletLayers.overlays[newName];
+                            if (map.hasLayer(leafletLayers.overlays[newName])) {
+                                if (newOverlayLayers[newName].layerOptions.opacity !== oldOverlayLayers[newName].layerOptions.opacity) {
+
+                                    if (isDefined(ly.setOpacity)) {
+                                        ly.setOpacity(newOverlayLayers[newName].layerOptions.opacity);
+                                    }
+                                    if (isDefined(ly.getLayers) && isDefined(ly.eachLayer)) {
+                                        ly.eachLayer(changeOpacityListener(newOverlayLayers[newName].layerOptions.opacity));
+                                    }
+                                }
+
+                                if (isDefined(newOverlayLayers[newName].index) && ly.setZIndex && newOverlayLayers[newName].index !== oldOverlayLayers[newName].index) {
+                                    ly.setZIndex(newOverlayLayers[newName].index);
+                                }
+                            }
+                        }
+
+                        //refresh heatmap data if present
+                        if (newOverlayLayers[newName].visible && map._loaded && newOverlayLayers[newName].data && newOverlayLayers[newName].type === "heatmap") {
+                            leafletLayers.overlays[newName].setData(newOverlayLayers[newName].data);
+                            leafletLayers.overlays[newName].update();
+                        }
+                    }
+
+                    // Only add the layers switch selector control if we have more than one baselayer + overlay
+                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);
+                }, true);
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module("ui-leaflet").directive('legend', function (leafletLogger, $http, $timeout, leafletHelpers, leafletLegendHelpers) {
+    var $log = leafletLogger,
+        errorHeader = leafletHelpers.errorHeader + ' [Legend] ';
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+        transclude: false,
+
+        link: function link(scope, element, attrs, controller) {
+
+            var isArray = leafletHelpers.isArray,
+                isString = leafletHelpers.isString,
+                isDefined = leafletHelpers.isDefined,
+                isFunction = leafletHelpers.isFunction,
+                leafletScope = controller.getLeafletScope(),
+                legend = leafletScope.legend;
+
+            var legendClass;
+            var position;
+            var leafletLegend;
+            var type;
+
+            leafletScope.$watch('legend', function (newLegend) {
+
+                if (isDefined(newLegend)) {
+                    legendClass = newLegend.legendClass ? newLegend.legendClass : "legend";
+                    position = newLegend.position || 'bottomright';
+                    // default to arcgis
+                    type = newLegend.type || 'arcgis';
+                }
+            }, true);
+
+            var createLegend = function createLegend(map, legendData, newURL) {
+                if (legendData && legendData.layers && legendData.layers.length > 0) {
+                    if (isDefined(leafletLegend)) {
+                        leafletLegendHelpers.updateLegend(leafletLegend.getContainer(), legendData, type, newURL);
+                    } else {
+                        leafletLegend = L.control({
+                            position: position
+                        });
+                        leafletLegend.onAdd = leafletLegendHelpers.getOnAddLegend(legendData, legendClass, type, newURL);
+                        leafletLegend.addTo(map);
+                    }
+
+                    if (isDefined(legend.loadedData) && isFunction(legend.loadedData)) {
+                        legend.loadedData();
+                    }
+                }
+            };
+
+            controller.getMap().then(function (map) {
+                leafletScope.$watch('legend', function (newLegend) {
+                    if (!isDefined(newLegend)) {
+                        if (isDefined(leafletLegend)) {
+                            leafletLegend.removeFrom(map);
+                            leafletLegend = null;
+                        }
+
+                        return;
+                    }
+
+                    if (!isDefined(newLegend.url) && type === 'arcgis' && (!isArray(newLegend.colors) || !isArray(newLegend.labels) || newLegend.colors.length !== newLegend.labels.length)) {
+                        $log.warn(errorHeader + " legend.colors and legend.labels must be set.");
+                        return;
+                    }
+
+                    if (isDefined(newLegend.url)) {
+                        $log.info(errorHeader + " loading legend service.");
+                        return;
+                    }
+
+                    if (isDefined(leafletLegend)) {
+                        leafletLegend.removeFrom(map);
+                        leafletLegend = null;
+                    }
+
+                    leafletLegend = L.control({
+                        position: position
+                    });
+
+                    if (type === 'arcgis') {
+                        leafletLegend.onAdd = leafletLegendHelpers.getOnAddArrayLegend(newLegend, legendClass);
+                    }
+                    leafletLegend.addTo(map);
+                });
+
+                leafletScope.$watch('legend.url', function (newURL) {
+                    if (!isDefined(newURL)) {
+                        return;
+                    }
+
+                    if (!isArray(newURL) && !isString(newURL)) {
+                        $log.warn(errorHeader + " legend.url must be an array or string.");
+                        return;
+                    }
+
+                    var urls = isString(newURL) ? [newURL] : newURL;
+
+                    var legendData;
+                    var onResult = function onResult(idx, url) {
+                        return function (ld) {
+                            if (isDefined(ld.data.error)) {
+                                $log.warn(errorHeader + 'Error loadin legend from: ' + url, ld.data.error.message);
+                            } else {
+                                if (legendData && legendData.layers && legendData.layers.length > 0) {
+                                    legendData.layers = legendData.layers.concat(ld.data.layers);
+                                } else {
+                                    legendData = ld.data;
+                                }
+                            }
+
+                            if (idx === urls.length - 1) {
+                                createLegend(map, legendData, newURL);
+                            }
+                        };
+                    };
+                    var onError = function onError(err) {
+                        $log.warn(errorHeader + ' legend.url not loaded.', err);
+                    };
+
+                    for (var i = 0; i < urls.length; i++) {
+                        leafletLegendHelpers.addLegendURL(attrs.id, {
+                            url: urls[i],
+                            method: 'GET'
+                        }).then(onResult(i)).catch(onError);
+                    }
+                });
+
+                leafletScope.$watch('legend.legendData', function (legendData) {
+                    $log.debug('legendData', legendData);
+                    if (isDefined(leafletScope.legend.url) || !isDefined(legendData)) {
+                        return;
+                    }
+
+                    createLegend(map, legendData);
+                }, true);
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('markers', function (leafletLogger, $rootScope, $q, leafletData, leafletHelpers, leafletMapDefaults, leafletMarkersHelpers, leafletMarkerEvents, leafletIterators, leafletWatchHelpers, leafletDirectiveControlsHelpers) {
+    //less terse vars to helpers
+    var isDefined = leafletHelpers.isDefined,
+        errorHeader = leafletHelpers.errorHeader,
+        Helpers = leafletHelpers,
+        isString = leafletHelpers.isString,
+        addMarkerWatcher = leafletMarkersHelpers.addMarkerWatcher,
+        updateMarker = leafletMarkersHelpers.updateMarker,
+        listenMarkerEvents = leafletMarkersHelpers.listenMarkerEvents,
+        addMarkerToGroup = leafletMarkersHelpers.addMarkerToGroup,
+        createMarker = leafletMarkersHelpers.createMarker,
+        deleteMarker = leafletMarkersHelpers.deleteMarker,
+        getModelFromModels = leafletMarkersHelpers.getModelFromModels,
+        getLayerModels = leafletMarkersHelpers.getLayerModels,
+        resetUnusedMarkerGroups = leafletMarkersHelpers.resetUnusedMarkerGroups,
+        $it = leafletIterators,
+        _defaultWatchOptions = leafletHelpers.watchOptions,
+        maybeWatch = leafletWatchHelpers.maybeWatch,
+        extendDirectiveControls = leafletDirectiveControlsHelpers.extend,
+        $log = leafletLogger,
+        watchTrap = { changeFromDirective: false };
+
+    var _getLMarker = function _getLMarker(leafletMarkers, name, maybeLayerName) {
+        if (!Object.keys(leafletMarkers).length) return;
+        if (maybeLayerName && isString(maybeLayerName)) {
+            if (!leafletMarkers[maybeLayerName] || !Object.keys(leafletMarkers[maybeLayerName]).length) return;
+            return leafletMarkers[maybeLayerName][name];
+        }
+        return leafletMarkers[name];
+    };
+
+    var _setLMarker = function _setLMarker(lObject, leafletMarkers, name, maybeLayerName) {
+        if (maybeLayerName && isString(maybeLayerName)) {
+            if (!isDefined(leafletMarkers[maybeLayerName])) leafletMarkers[maybeLayerName] = {};
+            leafletMarkers[maybeLayerName][name] = lObject;
+        } else leafletMarkers[name] = lObject;
+        return lObject;
+    };
+
+    var _maybeAddMarkerToLayer = function _maybeAddMarkerToLayer(layerName, layers, model, marker, watchType, map) {
+
+        if (!isString(layerName)) {
+            $log.error(errorHeader + ' A layername must be a string');
+            return false;
+        }
+
+        if (!isDefined(layers)) {
+            $log.error(errorHeader + ' You must add layers to the directive if the markers are going to use this functionality.');
+            return false;
+        }
+
+        if (!isDefined(layers.overlays) || !isDefined(layers.overlays[layerName])) {
+            $log.error(errorHeader + ' A marker can only be added to a layer of type "group"');
+            return false;
+        }
+        var layerGroup = layers.overlays[layerName];
+        if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {
+            $log.error(errorHeader + ' Adding a marker to an overlay needs a overlay of the type "group" or "featureGroup"');
+            return false;
+        }
+
+        // The marker goes to a correct layer group, so first of all we add it
+        layerGroup.addLayer(marker);
+
+        // The marker is automatically added to the map depending on the visibility
+        // of the layer, so we only have to open the popup if the marker is in the map
+        if (watchType === null && map.hasLayer(marker) && model.focus === true) {
+            marker.openPopup();
+        }
+        return true;
+    };
+    //TODO: move to leafletMarkersHelpers??? or make a new class/function file (leafletMarkersHelpers is large already)
+    var _addMarkers = function _addMarkers(mapId, markersToRender, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, maybeLayerName, skips) {
+        $it.each(markersToRender, function (model, newName) {
+            if (skips[newName]) return;
+
+            if (newName.search("-") !== -1) {
+                $log.error('The marker can\'t use a "-" on his key name: "' + newName + '".');
+                return;
+            }
+
+            var pathToMarker = Helpers.getObjectDotPath(maybeLayerName ? [maybeLayerName, newName] : [newName]);
+            var maybeLMarker = _getLMarker(leafletMarkers, newName, maybeLayerName);
+            Helpers.modelChangeInDirective(watchTrap, "changeFromDirective", function () {
+                if (!isDefined(maybeLMarker)) {
+
+                    var marker = createMarker(model);
+                    var layerName = (model ? model.layer : undefined) || maybeLayerName; //original way takes pref
+                    if (!isDefined(marker)) {
+                        $log.error(errorHeader + ' Received invalid data on the marker ' + newName + '.');
+                        return;
+                    }
+                    _setLMarker(marker, leafletMarkers, newName, maybeLayerName);
+
+                    // Bind message
+                    if (isDefined(model.message)) {
+                        marker.bindPopup(model.message, model.popupOptions);
+                    }
+
+                    // Add the marker to a cluster group if needed
+                    if (isDefined(model.group)) {
+                        var groupOptions = isDefined(model.groupOption) ? model.groupOption : null;
+                        addMarkerToGroup(marker, model.group, groupOptions, map);
+                    }
+
+                    // Show label if defined
+                    if (Helpers.LabelPlugin.isLoaded() && isDefined(model.label) && isDefined(model.label.message)) {
+                        marker.bindLabel(model.label.message, model.label.options);
+                    }
+
+                    // Check if the marker should be added to a layer
+                    if (isDefined(model) && (isDefined(model.layer) || isDefined(maybeLayerName))) {
+
+                        var pass = _maybeAddMarkerToLayer(layerName, layers, model, marker, watchOptions.individual.type, map);
+                        if (!pass) return; //something went wrong move on in the loop
+                    } else if (!isDefined(model.group)) {
+                        // We do not have a layer attr, so the marker goes to the map layer
+                        map.addLayer(marker);
+                        if (watchOptions.individual.type === null && model.focus === true) {
+                            marker.openPopup();
+                        }
+                    }
+
+                    if (watchOptions.individual.type !== null) {
+                        addMarkerWatcher(marker, pathToMarker, leafletScope, layers, map, watchOptions.individual);
+                    }
+
+                    listenMarkerEvents(marker, model, leafletScope, watchOptions.individual.type, map);
+                    leafletMarkerEvents.bindEvents(mapId, marker, pathToMarker, model, leafletScope, layerName);
+                } else {
+                    var oldModel = getModelFromModels(oldModels, newName, maybeLayerName);
+                    updateMarker(model, oldModel, maybeLMarker, pathToMarker, leafletScope, layers, map);
+                }
+            });
+        });
+    };
+    var _seeWhatWeAlreadyHave = function _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, isEqual, cb) {
+        var hasLogged = false,
+            equals = false,
+            oldMarker,
+            newMarker;
+
+        var doCheckOldModel = isDefined(oldMarkerModels);
+        for (var name in lMarkers) {
+            if (!hasLogged) {
+                $log.debug(errorHeader + "[markers] destroy: ");
+                hasLogged = true;
+            }
+
+            if (doCheckOldModel) {
+                //might want to make the option (in watch options) to disable deep checking
+                //ie the options to only check !== (reference check) instead of angular.equals (slow)
+                newMarker = markerModels[name];
+                oldMarker = oldMarkerModels[name];
+                equals = isEqual && angular.equals(newMarker, oldMarker);
+            }
+            if (!isDefined(markerModels) || !Object.keys(markerModels).length || !isDefined(markerModels[name]) || !Object.keys(markerModels[name]).length || equals) {
+                if (cb && Helpers.isFunction(cb)) cb(newMarker, oldMarker, name);
+            }
+        }
+    };
+    var _destroy = function _destroy(markerModels, oldMarkerModels, lMarkers, map, layers) {
+        _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, false, function (newMarker, oldMarker, lMarkerName) {
+            $log.debug(errorHeader + '[marker] is deleting marker: ' + lMarkerName);
+            deleteMarker(lMarkers[lMarkerName], map, layers);
+            delete lMarkers[lMarkerName];
+        });
+    };
+
+    var _getNewModelsToSkipp = function _getNewModelsToSkipp(newModels, oldModels, lMarkers) {
+        var skips = {};
+        _seeWhatWeAlreadyHave(newModels, oldModels, lMarkers, true, function (newMarker, oldMarker, lMarkerName) {
+            $log.debug(errorHeader + '[marker] is already rendered, marker: ' + lMarkerName);
+            skips[lMarkerName] = newMarker;
+        });
+        return skips;
+    };
+
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet', '?layers'],
+
+        link: function link(scope, element, attrs, controller) {
+            var mapController = controller[0],
+                leafletScope = mapController.getLeafletScope();
+
+            mapController.getMap().then(function (map) {
+                var leafletMarkers = {},
+                    getLayers;
+
+                // If the layers attribute is used, we must wait until the layers are created
+                if (isDefined(controller[1])) {
+                    getLayers = controller[1].getLayers;
+                } else {
+                    getLayers = function getLayers() {
+                        var deferred = $q.defer();
+                        deferred.resolve();
+                        return deferred.promise;
+                    };
+                }
+
+                var watchOptions;
+                if (leafletScope.watchOptions && leafletScope.watchOptions.markers) {
+                    watchOptions = leafletScope.watchOptions.markers;
+                } else {
+                    watchOptions = _defaultWatchOptions;
+                }
+
+                var isNested = isDefined(attrs.markersNested) && Helpers.isTruthy(attrs.markersNested);
+
+                getLayers().then(function (layers) {
+                    var _clean = function _clean(models, oldModels) {
+                        resetUnusedMarkerGroups();
+                        if (isNested) {
+                            $it.each(models, function (markerToMaybeDel, layerName) {
+                                var oldLayerModels = getLayerModels(oldModels, layerName);
+                                _destroy(markerToMaybeDel, oldLayerModels, leafletMarkers[layerName], map, layers);
+                            });
+                            return;
+                        }
+                        _destroy(models, oldModels, leafletMarkers, map, layers);
+                    };
+
+                    var _create = function _create(models, oldModels) {
+                        _clean(models, oldModels);
+                        var skips = null;
+                        if (isNested) {
+                            $it.each(models, function (markersToAdd, layerName) {
+                                var oldLayerModels = getLayerModels(oldModels, layerName);
+                                var newlayerModels = getLayerModels(models, layerName);
+                                skips = _getNewModelsToSkipp(newlayerModels, oldLayerModels, leafletMarkers[layerName]);
+                                _addMarkers(attrs.id, markersToAdd, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, layerName, skips);
+                            });
+                            return;
+                        }
+                        skips = _getNewModelsToSkipp(models, oldModels, leafletMarkers);
+                        _addMarkers(attrs.id, models, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, undefined, skips);
+                    };
+                    extendDirectiveControls(attrs.id, 'markers', _create, _clean);
+                    leafletData.setMarkers(leafletMarkers, attrs.id);
+
+                    maybeWatch(leafletScope, 'markers', watchOptions, function (newMarkers, oldMarkers) {
+                        if (watchTrap.changeFromDirective) return;
+                        _create(newMarkers, oldMarkers);
+                    });
+                    scope.$on('$destroy', function () {
+                        _destroy(leafletScope.markers, {}, leafletMarkers, map, layers);
+                    });
+                });
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('maxbounds', function (leafletLogger, leafletMapDefaults, leafletBoundsHelpers, leafletHelpers) {
+    // var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var leafletScope = controller.getLeafletScope(),
+                isValidBounds = leafletBoundsHelpers.isValidBounds,
+                isNumber = leafletHelpers.isNumber;
+
+            controller.getMap().then(function (map) {
+                leafletScope.$watch("maxbounds", function (maxbounds) {
+                    if (!isValidBounds(maxbounds)) {
+                        // Unset any previous maxbounds
+                        map.setMaxBounds();
+                        return;
+                    }
+
+                    var leafletBounds = leafletBoundsHelpers.createLeafletBounds(maxbounds);
+                    if (isNumber(maxbounds.pad)) {
+                        leafletBounds = leafletBounds.pad(maxbounds.pad);
+                    }
+
+                    map.setMaxBounds(leafletBounds);
+                    if (!attrs.center && !attrs.lfCenter) {
+                        map.fitBounds(leafletBounds);
+                    }
+                });
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('paths', function (leafletLogger, $q, leafletData, leafletMapDefaults, leafletHelpers, leafletPathsHelpers, leafletPathEvents, leafletWatchHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet', '?layers'],
+
+        link: function link(scope, element, attrs, controller) {
+            var mapController = controller[0],
+                isDefined = leafletHelpers.isDefined,
+                isString = leafletHelpers.isString,
+                leafletScope = mapController.getLeafletScope(),
+                paths = leafletScope.paths,
+                createPath = leafletPathsHelpers.createPath,
+                bindPathEvents = leafletPathEvents.bindPathEvents,
+                setPathOptions = leafletPathsHelpers.setPathOptions,
+                maybeWatch = leafletWatchHelpers.maybeWatch;
+
+            mapController.getMap().then(function (map) {
+                var defaults = leafletMapDefaults.getDefaults(attrs.id),
+                    getLayers;
+
+                // If the layers attribute is used, we must wait until the layers are created
+                if (isDefined(controller[1])) {
+                    getLayers = controller[1].getLayers;
+                } else {
+                    getLayers = function getLayers() {
+                        var deferred = $q.defer();
+                        deferred.resolve();
+                        return deferred.promise;
+                    };
+                }
+
+                if (!isDefined(paths)) {
+                    return;
+                }
+
+                //legacy behaviour does a watch collection on the paths
+                var _legacyWatchOptions = {
+                    type: 'watchCollection',
+                    individual: {
+                        type: 'watchDeep'
+                    }
+                };
+
+                var watchOptions;
+                if (leafletScope.watchOptions && leafletScope.watchOptions.paths) {
+                    watchOptions = leafletScope.watchOptions.paths;
+                } else {
+                    watchOptions = _legacyWatchOptions;
+                }
+
+                getLayers().then(function (layers) {
+
+                    var leafletPaths = {};
+                    leafletData.setPaths(leafletPaths, attrs.id);
+
+                    // Function for listening every single path once created
+                    var watchPathFn = function watchPathFn(leafletPath, name, watchOptions) {
+                        var pathWatchPath = "paths[\"" + name + "\"]";
+
+                        maybeWatch(leafletScope, pathWatchPath, watchOptions, function (pathData, old, clearWatch) {
+                            if (!isDefined(pathData)) {
+                                if (isDefined(old.layer)) {
+                                    for (var i in layers.overlays) {
+                                        var overlay = layers.overlays[i];
+                                        overlay.removeLayer(leafletPath);
+                                    }
+                                }
+                                map.removeLayer(leafletPath);
+                                clearWatch();
+                                return;
+                            }
+                            setPathOptions(leafletPath, pathData.type, pathData);
+                        });
+                    };
+
+                    var _clean = function _clean(newPaths) {
+                        // Delete paths (by name) from the array
+                        for (var name in leafletPaths) {
+                            if (!isDefined(newPaths[name])) {
+                                map.removeLayer(leafletPaths[name]);
+                                delete leafletPaths[name];
+                            }
+                        }
+                    };
+
+                    var _create = function _create(newPaths) {
+                        _clean(newPaths);
+                        // Create the new paths
+                        for (var newName in newPaths) {
+                            if (newName.search('\\$') === 0) {
+                                continue;
+                            }
+                            if (newName.search("-") !== -1) {
+                                $log.error('[AngularJS - Leaflet] The path name "' + newName + '" is not valid. It must not include "-" and a number.');
+                                continue;
+                            }
+
+                            if (!isDefined(leafletPaths[newName])) {
+                                var pathData = newPaths[newName];
+                                var newPath = createPath(newName, newPaths[newName], defaults);
+
+                                // bind popup if defined
+                                if (isDefined(newPath) && isDefined(pathData.message)) {
+                                    newPath.bindPopup(pathData.message, pathData.popupOptions);
+                                }
+
+                                // Show label if defined
+                                if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(pathData.label) && isDefined(pathData.label.message)) {
+                                    newPath.bindLabel(pathData.label.message, pathData.label.options);
+                                }
+
+                                // Check if the marker should be added to a layer
+                                if (isDefined(pathData) && isDefined(pathData.layer)) {
+
+                                    if (!isString(pathData.layer)) {
+                                        $log.error('[AngularJS - Leaflet] A layername must be a string');
+                                        continue;
+                                    }
+                                    if (!isDefined(layers)) {
+                                        $log.error('[AngularJS - Leaflet] You must add layers to the directive if the markers are going to use this functionality.');
+                                        continue;
+                                    }
+
+                                    if (!isDefined(layers.overlays) || !isDefined(layers.overlays[pathData.layer])) {
+                                        $log.error('[AngularJS - Leaflet] A path can only be added to a layer of type "group"');
+                                        continue;
+                                    }
+                                    var layerGroup = layers.overlays[pathData.layer];
+                                    if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {
+                                        $log.error('[AngularJS - Leaflet] Adding a path to an overlay needs a overlay of the type "group" or "featureGroup"');
+                                        continue;
+                                    }
+
+                                    // Listen for changes on the new path
+                                    leafletPaths[newName] = newPath;
+                                    // The path goes to a correct layer group, so first of all we add it
+                                    layerGroup.addLayer(newPath);
+
+                                    if (watchOptions.individual.type !== null) {
+                                        watchPathFn(newPath, newName, watchOptions.individual);
+                                    } else {
+                                        setPathOptions(newPath, pathData.type, pathData);
+                                    }
+                                } else if (isDefined(newPath)) {
+                                    // Listen for changes on the new path
+                                    leafletPaths[newName] = newPath;
+                                    map.addLayer(newPath);
+
+                                    if (watchOptions.individual.type !== null) {
+                                        watchPathFn(newPath, newName, watchOptions.individual);
+                                    } else {
+                                        setPathOptions(newPath, pathData.type, pathData);
+                                    }
+                                }
+
+                                bindPathEvents(attrs.id, newPath, newName, pathData, leafletScope);
+                            }
+                        }
+                    };
+
+                    maybeWatch(leafletScope, 'paths', watchOptions, function (newPaths) {
+                        _create(newPaths);
+                    });
+                });
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('tiles', function (leafletLogger, leafletData, leafletMapDefaults, leafletHelpers) {
+    var $log = leafletLogger;
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: 'leaflet',
+
+        link: function link(scope, element, attrs, controller) {
+            var isDefined = leafletHelpers.isDefined,
+                leafletScope = controller.getLeafletScope(),
+                tiles = leafletScope.tiles;
+
+            if (!isDefined(tiles) || !isDefined(tiles.url)) {
+                $log.warn("[AngularJS - Leaflet] The 'tiles' definition doesn't have the 'url' property.");
+                return;
+            }
+
+            controller.getMap().then(function (map) {
+                var defaults = leafletMapDefaults.getDefaults(attrs.id);
+                var tileLayerObj;
+                leafletScope.$watch("tiles", function (tiles) {
+                    var tileLayerOptions = defaults.tileLayerOptions;
+                    var tileLayerUrl = defaults.tileLayer;
+
+                    // If no valid tiles are in the scope, remove the last layer
+                    if (!isDefined(tiles.url) && isDefined(tileLayerObj)) {
+                        map.removeLayer(tileLayerObj);
+                        return;
+                    }
+
+                    // No leafletTiles object defined yet
+                    if (!isDefined(tileLayerObj)) {
+                        if (isDefined(tiles.options)) {
+                            angular.copy(tiles.options, tileLayerOptions);
+                        }
+
+                        if (isDefined(tiles.url)) {
+                            tileLayerUrl = tiles.url;
+                        }
+
+                        tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);
+                        tileLayerObj.addTo(map);
+                        leafletData.setTiles(tileLayerObj, attrs.id);
+                        return;
+                    }
+
+                    // If the options of the tilelayer is changed, we need to redraw the layer
+                    if (isDefined(tiles.url) && isDefined(tiles.options) && !angular.equals(tiles.options, tileLayerOptions)) {
+                        map.removeLayer(tileLayerObj);
+                        tileLayerOptions = defaults.tileLayerOptions;
+                        angular.copy(tiles.options, tileLayerOptions);
+                        tileLayerUrl = tiles.url;
+                        tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);
+                        tileLayerObj.addTo(map);
+                        leafletData.setTiles(tileLayerObj, attrs.id);
+                        return;
+                    }
+
+                    // Only the URL of the layer is changed, update the tiles object
+                    if (isDefined(tiles.url)) {
+                        tileLayerObj.setUrl(tiles.url);
+                    }
+                }, true);
+            });
+        }
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').directive('watchOptions', ['$log', '$rootScope', '$q', 'leafletData', 'leafletHelpers', function (leafletLogger, $rootScope, $q, leafletData, leafletHelpers) {
+
+    var isDefined = leafletHelpers.isDefined,
+        errorHeader = leafletHelpers.errorHeader,
+        isObject = leafletHelpers.isObject,
+        $log = leafletLogger;
+
+    return {
+        restrict: "A",
+        scope: false,
+        replace: false,
+        require: ['leaflet'],
+
+        link: function link(scope, element, attrs, controller) {
+            var mapController = controller[0],
+                leafletScope = mapController.getLeafletScope();
+
+            var _isValidWatchType = function _isValidWatchType(type) {
+                return type === 'watch' || type === 'watchCollection' || type === 'watchDeep' || type === null;
+            };
+
+            if (isDefined(leafletScope.watchOptions) && isObject(leafletScope.watchOptions)) {
+                angular.forEach(['markers', 'geojson', 'paths'], function (name) {
+                    if (isDefined(leafletScope.watchOptions[name])) {
+                        if (!_isValidWatchType(leafletScope.watchOptions[name].type)) {
+                            $log.error(errorHeader + ' watchOptions.' + name + '.type is not a valid type.');
+                        }
+                        if (isDefined(leafletScope.watchOptions[name].individual)) {
+                            if (!_isValidWatchType(leafletScope.watchOptions[name].individual.type)) {
+                                $log.error(errorHeader + ' watchOptions.' + name + '.individual.type is not a valid type.');
+                            }
+                        } else {
+                            $log.error(errorHeader + ' watchOptions.' + name + '.type.individual must be defined.');
+                        }
+                    }
+                });
+            }
+        }
+    };
+}]);
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletEventsHelpersFactory', function ($rootScope, $q, leafletLogger, leafletHelpers) {
+    var safeApply = leafletHelpers.safeApply,
+        isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        isArray = leafletHelpers.isArray,
+        errorHeader = leafletHelpers.errorHeader,
+        $log = leafletLogger;
+
+    var EventsHelper = function EventsHelper(rootBroadcastName, lObjectType) {
+        this.rootBroadcastName = rootBroadcastName;
+        $log.debug("leafletEventsHelpersFactory: lObjectType: " + lObjectType + "rootBroadcastName: " + rootBroadcastName);
+        //used to path/key out certain properties based on the type , "markers", "geojson"
+        this.lObjectType = lObjectType;
+    };
+
+    EventsHelper.prototype.getAvailableEvents = function () {
+        return [];
+    };
+
+    /*
+     argument: name: Note this can be a single string or dot notation
+     Example:
+     markerModel : {
+     m1: { lat:_, lon: _}
+     }
+     //would yield name of
+     name = "m1"
+      If nested:
+     markerModel : {
+     cars: {
+     m1: { lat:_, lon: _}
+     }
+     }
+     //would yield name of
+     name = "cars.m1"
+     */
+    EventsHelper.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {
+        var _this = this;
+
+        maybeMapId = maybeMapId || '';
+        if (maybeMapId) maybeMapId = '.' + maybeMapId;
+
+        return function (e) {
+            var broadcastName = _this.rootBroadcastName + maybeMapId + '.' + eventName;
+            $log.debug(broadcastName);
+            _this.fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName, extra);
+        };
+    };
+
+    EventsHelper.prototype.fire = function (scope, broadcastName, logic, event, lObject, model, modelName, layerName, extra) {
+        // Safely broadcast the event
+        safeApply(scope, function () {
+            var toSend = {
+                leafletEvent: event,
+                leafletObject: lObject,
+                modelName: modelName,
+                model: model
+            };
+            if (isDefined(layerName)) angular.extend(toSend, { layerName: layerName });
+
+            if (logic === "emit") {
+                scope.$emit(broadcastName, toSend);
+            } else {
+                $rootScope.$broadcast(broadcastName, toSend);
+            }
+        });
+    };
+
+    EventsHelper.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName, extra) {
+        var events = [];
+        var logic = 'emit';
+        var _this = this;
+
+        if (!isDefined(leafletScope.eventBroadcast)) {
+            // Backward compatibility, if no event-broadcast attribute, all events are broadcasted
+            events = this.getAvailableEvents();
+        } else if (!isObject(leafletScope.eventBroadcast)) {
+            // Not a valid object
+            $log.error(errorHeader + "event-broadcast must be an object check your model.");
+        } else {
+            // We have a possible valid object
+            if (!isDefined(leafletScope.eventBroadcast[_this.lObjectType])) {
+                // We do not have events enable/disable do we do nothing (all enabled by default)
+                events = this.getAvailableEvents();
+            } else if (!isObject(leafletScope.eventBroadcast[_this.lObjectType])) {
+                // Not a valid object
+                $log.warn(errorHeader + 'event-broadcast.' + [_this.lObjectType] + ' must be an object check your model.');
+            } else {
+                // We have a possible valid map object
+                // Event propadation logic
+                if (isDefined(leafletScope.eventBroadcast[this.lObjectType].logic)) {
+                    // We take care of possible propagation logic
+                    if (leafletScope.eventBroadcast[_this.lObjectType].logic !== "emit" && leafletScope.eventBroadcast[_this.lObjectType].logic !== "broadcast") $log.warn(errorHeader + "Available event propagation logic are: 'emit' or 'broadcast'.");
+                }
+                // Enable / Disable
+                var eventsEnable = false,
+                    eventsDisable = false;
+                if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].enable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].enable)) eventsEnable = true;
+                if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].disable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].disable)) eventsDisable = true;
+
+                if (eventsEnable && eventsDisable) {
+                    // Both are active, this is an error
+                    $log.warn(errorHeader + "can not enable and disable events at the same time");
+                } else if (!eventsEnable && !eventsDisable) {
+                    // Both are inactive, this is an error
+                    $log.warn(errorHeader + "must enable or disable events");
+                } else {
+                    // At this point the object is OK, lets enable or disable events
+                    if (eventsEnable) {
+                        // Enable events
+                        leafletScope.eventBroadcast[this.lObjectType].enable.forEach(function (eventName) {
+                            // Do we have already the event enabled?
+                            if (events.indexOf(eventName) !== -1) {
+                                // Repeated event, this is an error
+                                $log.warn(errorHeader + "This event " + eventName + " is already enabled");
+                            } else {
+                                // Does the event exists?
+                                if (_this.getAvailableEvents().indexOf(eventName) === -1) {
+                                    // The event does not exists, this is an error
+                                    $log.warn(errorHeader + "This event " + eventName + " does not exist");
+                                } else {
+                                    // All ok enable the event
+                                    events.push(eventName);
+                                }
+                            }
+                        });
+                    } else {
+                        // Disable events
+                        events = this.getAvailableEvents();
+                        leafletScope.eventBroadcast[_this.lObjectType].disable.forEach(function (eventName) {
+                            var index = events.indexOf(eventName);
+                            if (index === -1) {
+                                // The event does not exist
+                                $log.warn(errorHeader + "This event " + eventName + " does not exist or has been already disabled");
+                            } else {
+                                events.splice(index, 1);
+                            }
+                        });
+                    }
+                }
+            }
+        }
+
+        events.forEach(function (eventName) {
+            lObject.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra));
+        });
+        return logic;
+    };
+
+    return EventsHelper;
+}).service('leafletEventsHelpers', function (leafletEventsHelpersFactory) {
+    return new leafletEventsHelpersFactory();
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletGeoJsonEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory, leafletData) {
+    var safeApply = leafletHelpers.safeApply,
+        EventsHelper = leafletEventsHelpersFactory;
+    // $log = leafletLogger;
+
+    var GeoJsonEvents = function GeoJsonEvents() {
+        EventsHelper.call(this, 'leafletDirectiveGeoJson', 'geojson');
+    };
+
+    GeoJsonEvents.prototype = new EventsHelper();
+
+    GeoJsonEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {
+        var base = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName),
+            _this = this;
+
+        return function (e) {
+            if (eventName === 'mouseout') {
+                if (extra.resetStyleOnMouseout) {
+                    leafletData.getGeoJSON(extra.mapId).then(function (leafletGeoJSON) {
+                        //this is broken on nested needs to traverse or user layerName (nested)
+                        var lobj = layerName ? leafletGeoJSON[layerName] : leafletGeoJSON;
+                        lobj.resetStyle(e.target);
+                    });
+                }
+                safeApply(leafletScope, function () {
+                    $rootScope.$broadcast(_this.rootBroadcastName + '.mouseout', e);
+                });
+            }
+            base(e); //common
+        };
+    };
+
+    GeoJsonEvents.prototype.getAvailableEvents = function () {
+        return ['click', 'dblclick', 'mouseover', 'mouseout'];
+    };
+
+    return new GeoJsonEvents();
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletLabelEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory) {
+    var Helpers = leafletHelpers,
+        EventsHelper = leafletEventsHelpersFactory;
+    //$log = leafletLogger;
+
+    var LabelEvents = function LabelEvents() {
+        EventsHelper.call(this, 'leafletDirectiveLabel', 'markers');
+    };
+    LabelEvents.prototype = new EventsHelper();
+
+    LabelEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        var markerName = name.replace('markers.', '');
+        return EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, markerName, model, layerName);
+    };
+
+    LabelEvents.prototype.getAvailableEvents = function () {
+        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];
+    };
+
+    LabelEvents.prototype.genEvents = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        var _this = this;
+        var labelEvents = this.getAvailableEvents();
+        var scopeWatchName = Helpers.getObjectArrayPath("markers." + name);
+        labelEvents.forEach(function (eventName) {
+            lObject.label.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject.label, scopeWatchName, model, layerName));
+        });
+    };
+
+    LabelEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {};
+
+    return new LabelEvents();
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletMapEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpers, leafletIterators) {
+    var isDefined = leafletHelpers.isDefined,
+        fire = leafletEventsHelpers.fire;
+
+    var _getAvailableMapEvents = function _getAvailableMapEvents() {
+        return ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'contextmenu', 'focus', 'blur', 'preclick', 'load', 'unload', 'viewreset', 'movestart', 'move', 'moveend', 'dragstart', 'drag', 'dragend', 'zoomstart', 'zoomanim', 'zoomend', 'zoomlevelschange', 'resize', 'autopanstart', 'layeradd', 'layerremove', 'baselayerchange', 'overlayadd', 'overlayremove', 'locationfound', 'locationerror', 'popupopen', 'popupclose', 'draw:created', 'draw:edited', 'draw:deleted', 'draw:drawstart', 'draw:drawstop', 'draw:editstart', 'draw:editstop', 'draw:deletestart', 'draw:deletestop'];
+    };
+
+    var _genDispatchMapEvent = function _genDispatchMapEvent(scope, eventName, logic, maybeMapId) {
+        if (maybeMapId) {
+            maybeMapId = maybeMapId + '.';
+        }
+        return function (e) {
+            // Put together broadcast name
+            var broadcastName = 'leafletDirectiveMap.' + maybeMapId + eventName;
+            leafletLogger.debug(broadcastName);
+            // Safely broadcast the event
+            fire(scope, broadcastName, logic, e, e.target, scope);
+        };
+    };
+
+    var _notifyCenterChangedToBounds = function _notifyCenterChangedToBounds(scope) {
+        scope.$broadcast("boundsChanged");
+    };
+
+    var _notifyCenterUrlHashChanged = function _notifyCenterUrlHashChanged(scope, map, attrs, search) {
+        if (!isDefined(attrs.urlHashCenter)) {
+            return;
+        }
+        var center = map.getCenter();
+        var centerUrlHash = center.lat.toFixed(4) + ":" + center.lng.toFixed(4) + ":" + map.getZoom();
+        if (!isDefined(search.c) || search.c !== centerUrlHash) {
+            //$log.debug("notified new center...");
+            scope.$emit("centerUrlHash", centerUrlHash);
+        }
+    };
+
+    var _addEvents = function _addEvents(map, mapId, mapEvents, contextName, scope, logic) {
+        leafletIterators.each(mapEvents, function (eventName) {
+            var context = {};
+            context[contextName] = eventName;
+            if (!mapId) {
+                mapId = map._container.id || '';
+            }
+
+            map.on(eventName, _genDispatchMapEvent(scope, eventName, logic, mapId), context);
+        });
+    };
+
+    return {
+        getAvailableMapEvents: _getAvailableMapEvents,
+        genDispatchMapEvent: _genDispatchMapEvent,
+        notifyCenterChangedToBounds: _notifyCenterChangedToBounds,
+        notifyCenterUrlHashChanged: _notifyCenterUrlHashChanged,
+        addEvents: _addEvents
+    };
+});
+
+'use strict';
+
+angular.module('ui-leaflet').factory('leafletMarkerEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletEventsHelpersFactory, leafletLabelEvents) {
+    var safeApply = leafletHelpers.safeApply,
+        isDefined = leafletHelpers.isDefined,
+        Helpers = leafletHelpers,
+        lblHelp = leafletLabelEvents,
+        EventsHelper = leafletEventsHelpersFactory,
+        $log = leafletLogger;
+
+    var MarkerEvents = function MarkerEvents() {
+        EventsHelper.call(this, 'leafletDirectiveMarker', 'markers');
+    };
+
+    MarkerEvents.prototype = new EventsHelper();
+
+    MarkerEvents.prototype.genDispatchEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        var handle = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName);
+        return function (e) {
+            // Broadcast old marker click name for backwards compatibility
+            if (eventName === "click") {
+                safeApply(leafletScope, function () {
+                    $rootScope.$broadcast('leafletDirectiveMarkersClick', name);
+                });
+            } else if (eventName === 'dragend') {
+                safeApply(leafletScope, function () {
+                    model.lat = lObject.getLatLng().lat;
+                    model.lng = lObject.getLatLng().lng;
+                });
+                if (model.message && model.focus === true) {
+                    lObject.openPopup();
+                }
+            }
+            handle(e); //common
+        };
+    };
+
+    MarkerEvents.prototype.getAvailableEvents = function () {
+        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu', 'dragstart', 'drag', 'dragend', 'move', 'remove', 'popupopen', 'popupclose', 'touchend', 'touchstart', 'touchmove', 'touchcancel', 'touchleave'];
+    };
+
+    MarkerEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {
+        var logic = EventsHelper.prototype.bindEvents.call(this, maybeMapId, lObject, name, model, leafletScope, layerName);
+
+        if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {
+            lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model, layerName);
+        }
+    };
+
+    return new MarkerEvents();
+});
+
+'use strict';
+
+var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
+
+angular.module('ui-leaflet').factory('leafletPathEvents', function ($rootScope, $q, leafletLogger, leafletHelpers, leafletLabelEvents, leafletEventsHelpers) {
+    var isDefined = leafletHelpers.isDefined,
+        isObject = leafletHelpers.isObject,
+        Helpers = leafletHelpers,
+        errorHeader = leafletHelpers.errorHeader,
+        lblHelp = leafletLabelEvents,
+        fire = leafletEventsHelpers.fire,
+        $log = leafletLogger;
+
+    /*
+    TODO (nmccready) This EventsHelper needs to be derrived from leafletEventsHelpers to elminate copy and paste code.
+    */
+
+    var _genDispatchPathEvent = function _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
+        maybeMapId = maybeMapId || '';
+
+        if (maybeMapId) maybeMapId = '.' + maybeMapId;
+
+        return function (e) {
+            var broadcastName = 'leafletDirectivePath' + maybeMapId + '.' + eventName;
+            $log.debug(broadcastName);
+            fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName);
+        };
+    };
+
+    var _bindPathEvents = function _bindPathEvents(maybeMapId, lObject, name, model, leafletScope) {
+        var pathEvents = [],
+            i,
+            eventName,
+            logic = "broadcast";
+
+        if (!isDefined(leafletScope.eventBroadcast)) {
+            // Backward compatibility, if no event-broadcast attribute, all events are broadcasted
+            pathEvents = _getAvailablePathEvents();
+        } else if (!isObject(leafletScope.eventBroadcast)) {
+            // Not a valid object
+            $log.error(errorHeader + "event-broadcast must be an object check your model.");
+        } else {
+            // We have a possible valid object
+            if (!isDefined(leafletScope.eventBroadcast.path)) {
+                // We do not have events enable/disable do we do nothing (all enabled by default)
+                pathEvents = _getAvailablePathEvents();
+            } else if (isObject(leafletScope.eventBroadcast.paths)) {
+                // Not a valid object
+                $log.warn(errorHeader + "event-broadcast.path must be an object check your model.");
+            } else {
+                // We have a possible valid map object
+                // Event propadation logic
+                if (leafletScope.eventBroadcast.path.logic !== undefined && leafletScope.eventBroadcast.path.logic !== null) {
+                    // We take care of possible propagation logic
+                    if (leafletScope.eventBroadcast.path.logic !== "emit" && leafletScope.eventBroadcast.path.logic !== "broadcast") {
+                        // This is an error
+                        $log.warn(errorHeader + "Available event propagation logic are: 'emit' or 'broadcast'.");
+                    } else if (leafletScope.eventBroadcast.path.logic === "emit") {
+                        logic = "emit";
+                    }
+                }
+                // Enable / Disable
+                var pathEventsEnable = false,
+                    pathEventsDisable = false;
+                if (leafletScope.eventBroadcast.path.enable !== undefined && leafletScope.eventBroadcast.path.enable !== null) {
+                    if (_typeof(leafletScope.eventBroadcast.path.enable) === 'object') {
+                        pathEventsEnable = true;
+                    }
+                }
+                if (leafletScope.eventBroadcast.path.disable !== undefined && leafletScope.eventBroadcast.path.disable !== null) {
+                    if (_typeof(leafletScope.eventBroadcast.path.disable) === 'object') {
+                        pathEventsDisable = true;
+                    }
+                }
+                if (pathEventsEnable && pathEventsDisable) {
+                    // Both are active, this is an error
+                    $log.warn(errorHeader + "can not enable and disable events at the same time");
+                } else if (!pathEventsEnable && !pathEventsDisable) {
+                    // Both are inactive, this is an error
+                    $log.warn(errorHeader + "must enable or disable events");
+                } else {
+                    // At this point the path object is OK, lets enable or disable events
+                    if (pathEventsEnable) {
+                        // Enable events
+                        for (i = 0; i < leafletScope.eventBroadcast.path.enable.length; i++) {
+                            eventName = leafletScope.eventBroadcast.path.enable[i];
+                            // Do we have already the event enabled?
+                            if (pathEvents.indexOf(eventName) !== -1) {
+                                // Repeated event, this is an error
+                                $log.warn(errorHeader + "This event " + eventName + " is already enabled");
+                            } else {
+                                // Does the event exists?
+                                if (_getAvailablePathEvents().indexOf(eventName) === -1) {
+                                    // The event does not exists, this is an error
+                                    $log.warn(errorHeader + "This event " + eventName + " does not exist");
+                                } else {
+                                    // All ok enable the event
+                                    pathEvents.push(eventName);
+                                }
+                            }
+                        }
+                    } else {
+                        // Disable events
+                        pathEvents = _getAvailablePathEvents();
+                        for (i = 0; i < leafletScope.eventBroadcast.path.disable.length; i++) {
+                            eventName = leafletScope.eventBroadcast.path.disable[i];
+                            var index = pathEvents.indexOf(eventName);
+                            if (index === -1) {
+                                // The event does not exist
+                                $log.warn(errorHeader + "This event " + eventName + " does not exist or has been already disabled");
+                            } else {
+                                pathEvents.splice(index, 1);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        for (i = 0; i < pathEvents.length; i++) {
+            eventName = pathEvents[i];
+            lObject.on(eventName, _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, pathEvents, name));
+        }
+
+        if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {
+            lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model);
+        }
+    };
+
+    var _getAvailablePathEvents = function _getAvailablePathEvents() {
+        return ['click', 'dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu', 'add', 'remove', 'popupopen', 'popupclose'];
+    };
+
+    return {
+        getAvailablePathEvents: _getAvailablePathEvents,
+        bindPathEvents: _bindPathEvents
+    };
+});
+
+}(angular));
+//# sourceMappingURL=ui-leaflet_dev_mapped.js.map
\ No newline at end of file
